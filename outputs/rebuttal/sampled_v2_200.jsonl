{"idx": 198736, "project": "linux", "commit_id": "d563131ef23cbc756026f839a82598c8445bc45f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d563131ef23cbc756026f839a82598c8445bc45f", "commit_message": "rsi: release skb if rsi_prepare_beacon fails\n\nIn rsi_send_beacon, if rsi_prepare_beacon fails the allocated skb should\nbe released.\n\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>", "target": 1, "func": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\n\treturn 0;\n}", "func_hash": 130931178778692254191224779038755080046, "file_name": "rsi_91x_mgmt.c", "file_hash": 125660046646447806158908760119804627111, "cwe": ["CWE-401"], "cve": "CVE-2019-19071", "cve_desc": "A memory leak in the rsi_send_beacon() function in drivers/net/wireless/rsi/rsi_91x_mgmt.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering rsi_prepare_beacon() failures, aka CID-d563131ef23c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19071"}
{"idx": 208506, "project": "heimdal", "commit_id": "04171147948d0a3636bc6374181926f0fb2ec83a", "project_url": "https://github.com/heimdal/heimdal", "commit_url": "https://github.com/heimdal/heimdal/commit/04171147948d0a3636bc6374181926f0fb2ec83a", "commit_message": "kdc: validate sname in TGS-REQ\n\nIn tgs_build_reply(), validate the server name in the TGS-REQ is present before\ndereferencing.", "target": 1, "func": "tgs_build_reply(astgs_request_t priv,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_enctype krbtgt_etype,\n\t\tconst krb5_keyblock *replykey,\n\t\tint rk_is_subkey,\n\t\tkrb5_ticket *ticket,\n\t\tconst char **e_text,\n\t\tAuthorizationData **auth_data,\n\t\tconst struct sockaddr *from_addr)\n{\n    krb5_context context = priv->context;\n    krb5_kdc_configuration *config = priv->config;\n    KDC_REQ *req = &priv->req;\n    KDC_REQ_BODY *b = &priv->req.req_body;\n    const char *from = priv->from;\n    krb5_error_code ret, ret2;\n    krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;\n    krb5_principal krbtgt_out_principal = NULL;\n    char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;\n    hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;\n    HDB *clientdb, *s4u2self_impersonated_clientdb;\n    krb5_realm ref_realm = NULL;\n    EncTicketPart *tgt = &ticket->ticket;\n    krb5_principals spp = NULL;\n    const EncryptionKey *ekey;\n    krb5_keyblock sessionkey;\n    krb5_kvno kvno;\n    krb5_data rspac;\n    const char *tgt_realm = /* Realm of TGT issuer */\n        krb5_principal_get_realm(context, krbtgt->entry.principal);\n    const char *our_realm = /* Realm of this KDC */\n        krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);\n    char **capath = NULL;\n    size_t num_capath = 0;\n\n    hdb_entry_ex *krbtgt_out = NULL;\n\n    METHOD_DATA enc_pa_data;\n\n    PrincipalName *s;\n    Realm r;\n    EncTicketPart adtkt;\n    char opt_str[128];\n    int signedpath = 0;\n\n    Key *tkey_check;\n    Key *tkey_sign;\n    int flags = HDB_F_FOR_TGS_REQ;\n\n    memset(&sessionkey, 0, sizeof(sessionkey));\n    memset(&adtkt, 0, sizeof(adtkt));\n    krb5_data_zero(&rspac);\n    memset(&enc_pa_data, 0, sizeof(enc_pa_data));\n\n    s = b->sname;\n    r = b->realm;\n\n    /*\n     * The canonicalize KDC option is passed as a hint to the backend, but\n     * can typically be ignored. Per RFC 6806, names are not canonicalized\n     * in response to a TGS request (although we make an exception, see\n     * force-canonicalize below).\n     */\n    if (b->kdc_options.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->kdc_options.enc_tkt_in_skey){\n\tTicket *t;\n\thdb_entry_ex *uu;\n\tkrb5_principal p;\n\tKey *uukey;\n\tkrb5uint32 second_kvno = 0;\n\tkrb5uint32 *kvno_ptr = NULL;\n\n\tif(b->additional_tickets == NULL ||\n\t   b->additional_tickets->len == 0){\n\t    ret = KRB5KDC_ERR_BADOPTION; /* ? */\n\t    kdc_log(context, config, 4,\n\t\t    \"No second ticket present in user-to-user request\");\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"No second ticket present in user-to-user request\");\n\t    goto out;\n\t}\n\tt = &b->additional_tickets->val[0];\n\tif(!get_krbtgt_realm(&t->sname)){\n\t    kdc_log(context, config, 4,\n\t\t    \"Additional ticket is not a ticket-granting ticket\");\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Additional ticket is not a ticket-granting ticket\");\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    goto out;\n\t}\n\t_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);\n\tret = krb5_unparse_name(context, p, &tpn);\n\tif (ret)\n\t\tgoto out;\n\tif(t->enc_part.kvno){\n\t    second_kvno = *t->enc_part.kvno;\n\t    kvno_ptr = &second_kvno;\n\t}\n\tret = _kdc_db_fetch(context, config, p,\n\t\t\t    HDB_F_GET_KRBTGT, kvno_ptr,\n\t\t\t    NULL, &uu);\n\tkrb5_free_principal(context, p);\n\tif(ret){\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user service principal (TGS) unknown\");\n\t    goto out;\n\t}\n\tret = hdb_enctype2key(context, &uu->entry, NULL,\n\t\t\t      t->enc_part.etype, &uukey);\n\tif(ret){\n\t    _kdc_free_ent(context, uu);\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user enctype not supported\");\n\t    goto out;\n\t}\n\tret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);\n\t_kdc_free_ent(context, uu);\n\tif(ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user TGT decrypt failure\");\n\t    goto out;\n        }\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user TGT expired or invalid\");\n\t    goto out;\n        }\n\n\ts = &adtkt.cname;\n\tr = adtkt.crealm;\n    }\n\n    _krb5_principalname2krb5_principal(context, &sp, *s, r);\n    ret = krb5_unparse_name(context, sp, &priv->sname);\n    if (ret)\n\tgoto out;\n    spn = priv->sname;\n    _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);\n    ret = krb5_unparse_name(context, cp, &priv->cname);\n    if (ret)\n\tgoto out;\n    cpn = priv->cname;\n    unparse_flags (KDCOptions2int(b->kdc_options),\n\t\t   asn1_KDCOptions_units(),\n\t\t   opt_str, sizeof(opt_str));\n    if(*opt_str)\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ %s from %s for %s [%s]\",\n\t\tcpn, from, spn, opt_str);\n    else\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ %s from %s for %s\", cpn, from, spn);\n\n    /*\n     * Fetch server\n     */\n\nserver_lookup:\n    ret = _kdc_db_fetch(context, config, sp,\n                        HDB_F_GET_SERVER | HDB_F_DELAY_NEW_KEYS | flags,\n\t\t\tNULL, NULL, &server);\n    priv->server = server;\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\", spn);\n        _kdc_audit_addreason((kdc_request_t)priv, \"Target not found here\");\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n        free(ref_realm);\n\tref_realm = strdup(server->entry.principal->realm);\n\tif (ref_realm == NULL) {\n            ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 4,\n\t\t\"Returning a referral to realm %s for \"\n\t\t\"server %s.\",\n\t\tref_realm, spn);\n\tkrb5_free_principal(context, sp);\n\tsp = NULL;\n\tret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t  ref_realm, NULL);\n\tif (ret)\n\t    goto out;\n\tfree(priv->sname);\n        priv->sname = NULL;\n\tret = krb5_unparse_name(context, sp, &priv->sname);\n\tif (ret)\n\t    goto out;\n\tspn = priv->sname;\n\n\tgoto server_lookup;\n    } else if (ret) {\n\tconst char *new_rlm, *msg;\n\tRealm req_rlm;\n\tkrb5_realm *realms;\n\n\tif ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {\n            if (capath == NULL) {\n                /* With referalls, hierarchical capaths are always enabled */\n                ret2 = _krb5_find_capath(context, tgt->crealm, our_realm,\n                                         req_rlm, TRUE, &capath, &num_capath);\n                if (ret2) {\n                    ret = ret2;\n                    _kdc_audit_addreason((kdc_request_t)priv,\n                                         \"No trusted path from client realm to ours\");\n                    goto out;\n                }\n            }\n            new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;\n            if (new_rlm) {\n                kdc_log(context, config, 5, \"krbtgt from %s via %s for \"\n                        \"realm %s not found, trying %s\", tgt->crealm,\n                        our_realm, req_rlm, new_rlm);\n\n                free(ref_realm);\n                ref_realm = strdup(new_rlm);\n                if (ref_realm == NULL) {\n                    ret = krb5_enomem(context);\n                    goto out;\n                }\n\n                krb5_free_principal(context, sp);\n                sp = NULL;\n                krb5_make_principal(context, &sp, r,\n                                    KRB5_TGS_NAME, ref_realm, NULL);\n                free(priv->sname);\n                priv->sname = NULL;\n                ret = krb5_unparse_name(context, sp, &priv->sname);\n                if (ret)\n                    goto out;\n                spn = priv->sname;\n                goto server_lookup;\n            }\n\t} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {\n\t    if (strcmp(realms[0], sp->realm) != 0) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Returning a referral to realm %s for \"\n\t\t\t\"server %s that was not found\",\n\t\t\trealms[0], spn);\n\t\tkrb5_free_principal(context, sp);\n                sp = NULL;\n\t\tkrb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t    realms[0], NULL);\n\t\tfree(priv->sname);\n                priv->sname = NULL;\n\t\tret = krb5_unparse_name(context, sp, &priv->sname);\n\t\tif (ret) {\n\t\t    krb5_free_host_realm(context, realms);\n\t\t    goto out;\n\t\t}\n\t\tspn = priv->sname;\n\n                free(ref_realm);\n\t\tref_realm = strdup(realms[0]);\n\n\t\tkrb5_free_host_realm(context, realms);\n\t\tgoto server_lookup;\n\t    }\n\t    krb5_free_host_realm(context, realms);\n\t}\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 3,\n\t\t\"Server not found in database: %s: %s\", spn, msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == HDB_ERR_NOENTRY)\n\t    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Service principal unknown\");\n\tgoto out;\n    }\n\n    /*\n     * RFC 6806 notes that names MUST NOT be changed in the response to\n     * a TGS request. Hence we ignore the setting of the canonicalize\n     * KDC option. However, for legacy interoperability we do allow the\n     * backend to override this by setting the force-canonicalize HDB\n     * flag in the server entry.\n     */\n    if (server->entry.flags.force_canonicalize)\n\trsp = server->entry.principal;\n    else\n\trsp = sp;\n\n    /*\n     * Select enctype, return key and kvno.\n     */\n\n    {\n\tkrb5_enctype etype;\n\n\tif(b->kdc_options.enc_tkt_in_skey) {\n\t    size_t i;\n\t    ekey = &adtkt.key;\n\t    for(i = 0; i < b->etype.len; i++)\n\t\tif (b->etype.val[i] == adtkt.key.keytype)\n\t\t    break;\n\t    if(i == b->etype.len) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Addition ticket have not matching etypes\");\n\t\tkrb5_clear_error_message(context);\n\t\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"No matching enctypes for 2nd ticket\");\n\t\tgoto out;\n\t    }\n\t    etype = b->etype.val[i];\n\t    kvno = 0;\n\t} else {\n\t    Key *skey;\n\n\t    ret = _kdc_find_etype(priv, krb5_principal_is_krbtgt(context, sp)\n\t\t\t\t\t\t\t     ? KFE_IS_TGS : 0,\n\t\t\t\t  b->etype.val, b->etype.len, &etype, NULL,\n\t\t\t\t  NULL);\n\t    if(ret) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Server (%s) has no support for etypes\", spn);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Enctype not supported\");\n\t\tgoto out;\n\t    }\n\t    ret = _kdc_get_preferred_key(context, config, server, spn,\n\t\t\t\t\t NULL, &skey);\n\t    if(ret) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Server (%s) has no supported etypes\", spn);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Enctype not supported\");\n\t\tgoto out;\n\t    }\n\t    ekey = &skey->key;\n\t    kvno = server->entry.kvno;\n\t}\n\n\tret = krb5_generate_random_keyblock(context, etype, &sessionkey);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * Check that service is in the same realm as the krbtgt. If it's\n     * not the same, it's someone that is using a uni-directional trust\n     * backward.\n     */\n\n    /*\n     * Validate authorization data\n     */\n\n    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use the right kvno! */\n\t\t\t  krbtgt_etype, &tkey_check);\n    if(ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC check\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"No key for krbtgt PAC check\");\n\tgoto out;\n    }\n\n    /* \n     * Now refetch the primary krbtgt, and get the current kvno (the\n     * sign check may have been on an old kvno, and the server may\n     * have been an incoming trust)\n     */\n    \n    ret = krb5_make_principal(context,\n                              &krbtgt_out_principal,\n                              our_realm,\n                              KRB5_TGS_NAME,\n                              our_realm,\n                              NULL);\n    if (ret) {\n        kdc_log(context, config, 4,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n    ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);\n    if (ret) {\n        kdc_log(context, config, 4,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, krbtgt_out_principal,\n\t\t\tHDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);\n    if (ret) {\n\tchar *ktpn = NULL;\n\tret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);\n\tkdc_log(context, config, 4,\n\t\t\"No such principal %s (needed for authz-data signature keys) \"\n\t\t\"while processing TGS-REQ for service %s with krbtg %s\",\n\t\tkrbtgt_out_n, spn, (ret == 0) ? ktpn : \"<unknown>\");\n\tfree(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    /* \n     * The first realm is the realm of the service, the second is\n     * krbtgt/<this>/@REALM component of the krbtgt DN the request was\n     * encrypted to.  The redirection via the krbtgt_out entry allows\n     * the DB to possibly correct the case of the realm (Samba4 does\n     * this) before the strcmp() \n     */\n    if (strcmp(krb5_principal_get_realm(context, server->entry.principal),\n\t       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {\n\tchar *ktpn;\n\tret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);\n\tkdc_log(context, config, 4,\n\t\t\"Request with wrong krbtgt: %s\",\n\t\t(ret == 0) ? ktpn : \"<unknown>\");\n\tif(ret == 0)\n\t    free(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n        _kdc_audit_addreason((kdc_request_t)priv, \"Request with wrong TGT\");\n\tgoto out;\n    }\n\n    ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,\n\t\t\t\t NULL, &tkey_sign);\n    if (ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n    ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,\n\t\t\t  tkey_sign->key.keytype, &tkey_sign);\n    if(ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n\n    {\n        krb5_data verified_cas;\n\n        /*\n         * If the client doesn't exist in the HDB but has a TGT and it's\n         * obtained with PKINIT then we assume it's a synthetic client -- that\n         * is, a client whose name was vouched for by a CA using a PKINIT SAN,\n         * but which doesn't exist in the HDB proper.  We'll allow such a\n         * client to do TGT requests even though normally we'd reject all\n         * clients that don't exist in the HDB.\n         */\n        ret = krb5_ticket_get_authorization_data_type(context, ticket,\n                                                      KRB5_AUTHDATA_INITIAL_VERIFIED_CAS,\n                                                      &verified_cas);\n        if (ret == 0) {\n            krb5_data_free(&verified_cas);\n            flags |= HDB_F_SYNTHETIC_OK;\n        }\n    }\n    ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,\n\t\t\tNULL, &clientdb, &client);\n    flags &= ~HDB_F_SYNTHETIC_OK;\n    priv->client = client;\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* This is OK, we are just trying to find out if they have\n\t * been disabled or deleted in the meantime, missing secrets\n\t * is OK */\n    } else if(ret){\n\tconst char *krbtgt_realm, *msg;\n\n\t/*\n\t * If the client belongs to the same realm as our krbtgt, it\n\t * should exist in the local database.\n\t *\n\t */\n\n\tkrbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);\n\n\tif(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    kdc_log(context, config, 4, \"Client no longer in database: %s\",\n\t\t    cpn);\n            _kdc_audit_addreason((kdc_request_t)priv, \"Client no longer in HDB\");\n\t    goto out;\n\t}\n\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4, \"Client not found in database: %s\", msg);\n        _kdc_audit_addreason((kdc_request_t)priv, \"Client does not exist\");\n\tkrb5_free_error_message(context, msg);\n    } else if (ret == 0 &&\n               (client->entry.flags.invalid || !client->entry.flags.client)) {\n        _kdc_audit_addreason((kdc_request_t)priv, \"Client has invalid bit set\");\n        kdc_log(context, config, 4, \"Client has invalid bit set\");\n        ret = KRB5KDC_ERR_POLICY;\n        goto out;\n    }\n\n    ret = check_PAC(context, config, cp, NULL,\n\t\t    client, server, krbtgt,\n\t\t    &tkey_check->key,\n\t\t    ekey, &tkey_sign->key,\n\t\t    tgt, &rspac, &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n        _kdc_audit_addreason((kdc_request_t)priv, \"PAC check failed\");\n\tkdc_log(context, config, 4,\n\t\t\"Verify PAC failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /* also check the krbtgt for signature */\n    ret = check_KRB5SignedPath(context,\n\t\t\t       config,\n\t\t\t       krbtgt,\n\t\t\t       cp,\n\t\t\t       tgt,\n\t\t\t       &spp,\n\t\t\t       &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n        _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath check failed\");\n\tkdc_log(context, config, 4,\n\t\t\"KRB5SignedPath check failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /*\n     * Process request\n     */\n\n    /* by default the tgt principal matches the client principal */\n    tp = cp;\n    tpn = cpn;\n\n    if (client) {\n\tconst PA_DATA *sdata;\n\tint i = 0;\n\n\tsdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);\n\tif (sdata) {\n\t    struct astgs_request_desc imp_req;\n\t    krb5_crypto crypto;\n\t    krb5_data datack;\n\t    PA_S4U2Self self;\n\t    const char *str;\n\n\t    ret = decode_PA_S4U2Self(sdata->padata_value.data,\n\t\t\t\t     sdata->padata_value.length,\n\t\t\t\t     &self, NULL);\n\t    if (ret) {\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Failed to decode PA-S4U2Self\");\n\t\tkdc_log(context, config, 4, \"Failed to decode PA-S4U2Self\");\n\t\tgoto out;\n\t    }\n\n\t    if (!krb5_checksum_is_keyed(context, self.cksum.cksumtype)) {\n\t\tfree_PA_S4U2Self(&self);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"PA-S4U2Self with unkeyed checksum\");\n\t\tkdc_log(context, config, 4, \"Reject PA-S4U2Self with unkeyed checksum\");\n\t\tret = KRB5KRB_AP_ERR_INAPP_CKSUM;\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkrb5_data_free(&datack);\n\t\tkdc_log(context, config, 4, \"krb5_crypto_init failed: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    /* Allow HMAC_MD5 checksum with any key type */\n\t    if (self.cksum.cksumtype == CKSUMTYPE_HMAC_MD5) {\n\t\tstruct krb5_crypto_iov iov;\n\t\tunsigned char csdata[16];\n\t\tChecksum cs;\n\n\t\tcs.checksum.length = sizeof(csdata);\n\t\tcs.checksum.data = &csdata;\n\n\t\tiov.data.data = datack.data;\n\t\tiov.data.length = datack.length;\n\t\tiov.flags = KRB5_CRYPTO_TYPE_DATA;\n\n\t\tret = _krb5_HMAC_MD5_checksum(context, NULL, &crypto->key,\n\t\t\t\t\t      KRB5_KU_OTHER_CKSUM, &iov, 1,\n\t\t\t\t\t      &cs);\n\t\tif (ret == 0 &&\n\t\t    krb5_data_ct_cmp(&cs.checksum, &self.cksum.checksum) != 0)\n\t\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t    }\n\t    else {\n\t\tret = krb5_verify_checksum(context,\n\t\t\t\t\t   crypto,\n\t\t\t\t\t   KRB5_KU_OTHER_CKSUM,\n\t\t\t\t\t   datack.data,\n\t\t\t\t\t   datack.length,\n\t\t\t\t\t   &self.cksum);\n\t    }\n\t    krb5_data_free(&datack);\n\t    krb5_crypto_destroy(context, crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"S4U2Self checksum failed\");\n\t\tkdc_log(context, config, 4,\n\t\t\t\"krb5_verify_checksum failed for S4U2Self: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t     &tp,\n\t\t\t\t\t\t     self.name,\n\t\t\t\t\t\t     self.realm);\n\t    free_PA_S4U2Self(&self);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_unparse_name(context, tp, &tpn);\n\t    if (ret)\n\t\tgoto out;\n\n            /*\n             * Note no HDB_F_SYNTHETIC_OK -- impersonating non-existent clients\n             * is probably not desirable!\n             */\n\t    ret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,\n\t\t\t\tNULL, &s4u2self_impersonated_clientdb,\n\t\t\t\t&s4u2self_impersonated_client);\n\t    if (ret) {\n\t\tconst char *msg;\n\n\t\t/*\n\t\t * If the client belongs to the same realm as our krbtgt, it\n\t\t * should exist in the local database.\n\t\t *\n\t\t */\n\n\t\tif (ret == HDB_ERR_NOENTRY)\n\t\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t\tmsg = krb5_get_error_message(context, ret);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"S4U2Self principal to impersonate not found\");\n\t\tkdc_log(context, config, 2,\n\t\t\t\"S4U2Self principal to impersonate %s not found in database: %s\",\n\t\t\ttpn, msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    /* Ignore require_pwchange and pw_end attributes (as Windows does),\n\t     * since S4U2Self is not password authentication. */\n\t    s4u2self_impersonated_client->entry.flags.require_pwchange = FALSE;\n\t    free(s4u2self_impersonated_client->entry.pw_end);\n\t    s4u2self_impersonated_client->entry.pw_end = NULL;\n\n\t    imp_req = *priv;\n\t    imp_req.client = s4u2self_impersonated_client;\n\t    imp_req.client_princ = tp;\n\n\t    ret = kdc_check_flags(&imp_req, FALSE);\n\t    if (ret)\n\t\tgoto out; /* kdc_check_flags() calls _kdc_audit_addreason() */\n\n\t    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */\n\t    if(rspac.data) {\n\t\tkrb5_pac p = NULL;\n\t\tkrb5_data_free(&rspac);\n\t\tret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);\n\t\tif (ret) {\n                    _kdc_audit_addreason((kdc_request_t)priv,\n                                         \"KRB5SignedPath missing\");\n\t\t    kdc_log(context, config, 4, \"PAC generation failed for -- %s\",\n\t\t\t    tpn);\n\t\t    goto out;\n\t\t}\n\t\tif (p != NULL) {\n\t\t    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,\n\t\t\t\t\t s4u2self_impersonated_client->entry.principal,\n\t\t\t\t\t ekey, &tkey_sign->key,\n\t\t\t\t\t &rspac);\n\t\t    krb5_pac_free(context, p);\n\t\t    if (ret) {\n\t\t\tkdc_log(context, config, 4, \"PAC signing failed for -- %s\",\n\t\t\t\ttpn);\n\t\t\tgoto out;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check that service doing the impersonating is\n\t     * requesting a ticket to it-self.\n\t     */\n\t    ret = check_s4u2self(context, config, clientdb, client, sp);\n\t    if (ret) {\n\t\tkdc_log(context, config, 4, \"S4U2Self: %s is not allowed \"\n\t\t\t\"to impersonate to service \"\n\t\t\t\"(tried for user %s to service %s)\",\n\t\t\tcpn, tpn, spn);\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * If the service isn't trusted for authentication to\n\t     * delegation or if the impersonate client is disallowed\n\t     * forwardable, remove the forwardable flag.\n\t     */\n\n\t    if (client->entry.flags.trusted_for_delegation &&\n\t\ts4u2self_impersonated_client->entry.flags.forwardable) {\n\t\tstr = \"[forwardable]\";\n\t    } else {\n\t\tb->kdc_options.forwardable = 0;\n\t\tstr = \"\";\n\t    }\n\t    kdc_log(context, config, 4, \"s4u2self %s impersonating %s to \"\n\t\t    \"service %s %s\", cpn, tpn, spn, str);\n\t}\n    }\n\n    /*\n     * Constrained delegation\n     */\n\n    if (client != NULL\n\t&& b->additional_tickets != NULL\n\t&& b->additional_tickets->len != 0\n\t&& b->kdc_options.cname_in_addl_tkt\n\t&& b->kdc_options.enc_tkt_in_skey == 0)\n    {\n\tint ad_signedpath = 0;\n\tKey *clientkey;\n\tTicket *t;\n\n\t/*\n\t * Require that the KDC have issued the service's krbtgt (not\n\t * self-issued ticket with kimpersonate(1).\n\t */\n\tif (!signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n            _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath missing\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Constrained delegation done on service ticket %s/%s\",\n\t\t    cpn, spn);\n\t    goto out;\n\t}\n\n\tt = &b->additional_tickets->val[0];\n\n\tret = hdb_enctype2key(context, &client->entry,\n\t\t\t      hdb_kvno2keys(context, &client->entry,\n\t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),\n\t\t\t      t->enc_part.etype, &clientkey);\n\tif(ret){\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\n\tret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Failed to decrypt constrained delegation ticket\");\n\t    kdc_log(context, config, 4,\n\t\t    \"failed to decrypt ticket for \"\n\t\t    \"constrained delegation from %s to %s \", cpn, spn);\n\t    goto out;\n\t}\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &tp,\n\t\t\t\t\t\t adtkt.cname,\n\t\t\t\t\t\t adtkt.crealm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, tp, &tpn);\n\tif (ret)\n\t    goto out;\n\n        _kdc_audit_addkv((kdc_request_t)priv, 0, \"impersonatee\", \"%s\", tpn);\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &dp,\n\t\t\t\t\t\t t->sname,\n\t\t\t\t\t\t t->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, dp, &dpn);\n\tif (ret)\n\t    goto out;\n\n\t/* check that ticket is valid */\n\tif (adtkt.flags.forwardable == 0) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Missing forwardable flag on ticket for constrained delegation\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Missing forwardable flag on ticket for \"\n\t\t    \"constrained delegation from %s (%s) as %s to %s \",\n\t\t    cpn, dpn, tpn, spn);\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    goto out;\n\t}\n\n\tret = check_constrained_delegation(context, config, clientdb,\n\t\t\t\t\t   client, server, sp);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation not allowed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"constrained delegation from %s (%s) as %s to %s not allowed\",\n\t\t    cpn, dpn, tpn, spn);\n\t    goto out;\n\t}\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket expired or invalid\");\n\t    goto out;\n\t}\n\n\tkrb5_data_free(&rspac);\n\n\t/*\n\t * generate the PAC for the user.\n\t *\n\t * TODO: pass in t->sname and t->realm and build\n\t * a S4U_DELEGATION_INFO blob to the PAC.\n\t */\n\tret = check_PAC(context, config, tp, dp,\n\t\t\tclient, server, krbtgt,\n\t\t\t&clientkey->key,\n\t\t\tekey, &tkey_sign->key,\n\t\t\t&adtkt, &rspac, &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket PAC check failed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Verify delegated PAC failed to %s for client\"\n\t\t    \"%s (%s) as %s from %s with %s\",\n\t\t    spn, cpn, dpn, tpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\t/*\n\t * Check that the KDC issued the user's ticket.\n\t */\n\tret = check_KRB5SignedPath(context,\n\t\t\t\t   config,\n\t\t\t\t   krbtgt,\n\t\t\t\t   cp,\n\t\t\t\t   &adtkt,\n\t\t\t\t   NULL,\n\t\t\t\t   &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 4,\n\t\t    \"KRB5SignedPath check from service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s failed with %s\",\n\t\t    spn, tpn, dpn, cpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"KRB5SignedPath check failed\");\n\t    goto out;\n\t}\n\n\tif (!ad_signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 4,\n\t\t    \"Ticket not signed with PAC nor SignedPath service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s\",\n\t\t    spn, tpn, dpn, cpn, from);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket not signed\");\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 4, \"constrained delegation for %s \"\n\t\t\"from %s (%s) to %s\", tpn, cpn, dpn, spn);\n    }\n\n    /*\n     * Check flags\n     */\n\n    ret = kdc_check_flags(priv, FALSE);\n    if(ret)\n\tgoto out;\n\n    if((b->kdc_options.validate || b->kdc_options.renew) &&\n       !krb5_principal_compare(context,\n\t\t\t       krbtgt->entry.principal,\n\t\t\t       server->entry.principal)){\n        _kdc_audit_addreason((kdc_request_t)priv, \"Inconsistent request\");\n\tkdc_log(context, config, 4, \"Inconsistent request.\");\n\tret = KRB5KDC_ERR_SERVER_NOMATCH;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if (!_kdc_check_addresses(priv, tgt->caddr, from_addr)) {\n        if (config->check_ticket_addresses) {\n            ret = KRB5KRB_AP_ERR_BADADDR;\n            _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n            kdc_log(context, config, 4, \"Request from wrong address\");\n            _kdc_audit_addreason((kdc_request_t)priv, \"Request from wrong address\");\n            goto out;\n        } else if (config->warn_ticket_addresses) {\n            _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n        }\n    }\n\n    /* check local and per-principal anonymous ticket issuance policy */\n    if (is_anon_tgs_request_p(b, tgt)) {\n\tret = _kdc_check_anon_policy(priv);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * If this is an referral, add server referral data to the\n     * auth_data reply .\n     */\n    if (ref_realm) {\n\tPA_DATA pa;\n\tkrb5_crypto crypto;\n\n\tkdc_log(context, config, 3,\n\t\t\"Adding server referral to %s\", ref_realm);\n\n\tret = krb5_crypto_init(context, &sessionkey, 0, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = build_server_referral(context, config, crypto, ref_realm,\n\t\t\t\t    NULL, s, &pa.padata_value);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv, \"Referral build failed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Failed building server referral\");\n\t    goto out;\n\t}\n\tpa.padata_type = KRB5_PADATA_SERVER_REFERRAL;\n\n\tret = add_METHOD_DATA(&enc_pa_data, &pa);\n\tkrb5_data_free(&pa.padata_value);\n\tif (ret) {\n\t    kdc_log(context, config, 4,\n\t\t    \"Add server referral METHOD-DATA failed\");\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = tgs_make_reply(priv,\n\t\t\t tp,\n\t\t\t tgt,\n\t\t\t replykey,\n\t\t\t rk_is_subkey,\n\t\t\t ekey,\n\t\t\t &sessionkey,\n\t\t\t kvno,\n\t\t\t *auth_data,\n\t\t\t server,\n\t\t\t rsp,\n\t\t\t client,\n\t\t\t cp,\n                         tgt_realm,\n\t\t\t krbtgt_out,\n\t\t\t tkey_sign->key.keytype,\n\t\t\t spp,\n\t\t\t &rspac,\n\t\t\t &enc_pa_data);\n\nout:\n    if (tpn != cpn)\n\t    free(tpn);\n    free(dpn);\n    free(krbtgt_out_n);\n    _krb5_free_capath(context, capath);\n\n    krb5_data_free(&rspac);\n    krb5_free_keyblock_contents(context, &sessionkey);\n    if(krbtgt_out)\n\t_kdc_free_ent(context, krbtgt_out);\n    if(server)\n\t_kdc_free_ent(context, server);\n    if(client)\n\t_kdc_free_ent(context, client);\n    if(s4u2self_impersonated_client)\n\t_kdc_free_ent(context, s4u2self_impersonated_client);\n\n    if (tp && tp != cp)\n\tkrb5_free_principal(context, tp);\n    krb5_free_principal(context, cp);\n    krb5_free_principal(context, dp);\n    krb5_free_principal(context, sp);\n    krb5_free_principal(context, krbtgt_out_principal);\n    free(ref_realm);\n    free_METHOD_DATA(&enc_pa_data);\n\n    free_EncTicketPart(&adtkt);\n\n    return ret;\n}", "func_hash": 180711409541748394655723306760719102268, "file_name": "None", "file_hash": null, "cwe": ["CWE-476"], "cve": "CVE-2021-3671", "cve_desc": "A null pointer de-reference was found in the way samba kerberos server handled missing sname in TGS-REQ (Ticket Granting Server - Request). An authenticated user could use this flaw to crash the samba server.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3671"}
{"idx": 217561, "project": "ImageMagick6", "commit_id": "dc070da861a015d3c97488fdcca6063b44d47a7b", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/dc070da861a015d3c97488fdcca6063b44d47a7b", "commit_message": "https://github.com/ImageMagick/ImageMagick/pull/5034", "target": 0, "func": "static MagickBooleanType GetIPTCProperty(const Image *image,const char *key)\n{\n  char\n    *attribute,\n    *message;\n\n  const StringInfo\n    *profile;\n\n  long\n    count,\n    dataset,\n    record;\n\n  ssize_t\n    i;\n\n  size_t\n    length;\n\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile == (StringInfo *) NULL)\n    profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=sscanf(key,\"IPTC:%ld:%ld\",&dataset,&record);\n  if (count != 2)\n    return(MagickFalse);\n  attribute=(char *) NULL;\n  for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=(ssize_t) length)\n  {\n    length=1;\n    if ((ssize_t) GetStringInfoDatum(profile)[i] != 0x1c)\n      continue;\n    length=(size_t) (GetStringInfoDatum(profile)[i+3] << 8);\n    length|=GetStringInfoDatum(profile)[i+4];\n    if (((long) GetStringInfoDatum(profile)[i+1] == dataset) &&\n        ((long) GetStringInfoDatum(profile)[i+2] == record))\n      {\n        message=(char *) NULL;\n        if (~length >= 1)\n          message=(char *) AcquireQuantumMemory(length+1UL,sizeof(*message));\n        if (message != (char *) NULL)\n          {\n            (void) CopyMagickString(message,(char *) GetStringInfoDatum(\n              profile)+i+5,length+1);\n            (void) ConcatenateString(&attribute,message);\n            (void) ConcatenateString(&attribute,\";\");\n            message=DestroyString(message);\n          }\n      }\n    i+=5;\n  }\n  if ((attribute == (char *) NULL) || (*attribute == ';'))\n    {\n      if (attribute != (char *) NULL)\n        attribute=DestroyString(attribute);\n      return(MagickFalse);\n    }\n  attribute[strlen(attribute)-1]='\\0';\n  (void) SetImageProperty((Image *) image,key,(const char *) attribute);\n  attribute=DestroyString(attribute);\n  return(MagickTrue);\n}", "func_hash": 169391903442291166637719290665003382596, "file_name": "property.c", "file_hash": 320426917520707901134127411021604962567, "cwe": ["CWE-704"], "cve": "CVE-2022-32547", "cve_desc": "In ImageMagick, there is load of misaligned address for type 'double', which requires 8 byte alignment and for type 'float', which requires 4 byte alignment at MagickCore/property.c. Whenever crafted or untrusted input is processed by ImageMagick, this causes a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32547"}
{"idx": 175700, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual bool ethernet_available() const {\n    return available_devices_ & (1 << TYPE_ETHERNET);\n  }\n", "func_hash": 277781391952026651694213737398716981494, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90800, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "void QuotaManagerProxy::NotifyStorageModified(\n    QuotaClient::ID client_id,\n    const GURL& origin,\n    StorageType type,\n    int64 delta) {\n  if (!io_thread_->BelongsToCurrentThread()) {\n    io_thread_->PostTask(FROM_HERE, NewRunnableMethod(\n        this, &QuotaManagerProxy::NotifyStorageModified,\n        client_id, origin, type, delta));\n    return;\n  }\n  if (manager_)\n    manager_->NotifyStorageModified(client_id, origin, type, delta);\n}\n", "func_hash": 335249459186985506926645896426831351769, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90192, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  void UpdateSystemInfo() {\n    if (EnsureCrosLoaded()) {\n      UpdateNetworkManagerStatus();\n    }\n  }\n", "func_hash": 296030291345733783356589835512482813346, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90165, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "static ActivationState ParseActivationState(\n    const std::string& activation_state) {\n  if (activation_state == kActivationStateActivated)\n    return ACTIVATION_STATE_ACTIVATED;\n  if (activation_state == kActivationStateActivating)\n    return ACTIVATION_STATE_ACTIVATING;\n  if (activation_state == kActivationStateNotActivated)\n    return ACTIVATION_STATE_NOT_ACTIVATED;\n  if (activation_state == kActivationStateUnknown)\n    return ACTIVATION_STATE_UNKNOWN;\n  if (activation_state == kActivationStatePartiallyActivated)\n    return ACTIVATION_STATE_PARTIALLY_ACTIVATED;\n  return ACTIVATION_STATE_UNKNOWN;\n}\n", "func_hash": 2263283871812024506837222820762880493, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 198439, "project": "mruby", "commit_id": "3cf291f72224715942beaf8553e42ba8891ab3c6", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/3cf291f72224715942beaf8553e42ba8891ab3c6", "commit_message": "vm.c: create break object before clearing GC arena.\n\nOtherwise it possibly cause use-after-free.", "target": 1, "func": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n        goto L_INT_OVERFLOW;\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        va = mrb_hash_get(mrb, va, vb);\n        regs[a] = va;\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          regs[a] = va;\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict, v;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      v = mrb_hash_get(mrb, kdict, k);\n      regs[a] = v;\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      mrb_int len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_ensure_hash_type(mrb, hash);\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}", "func_hash": 109885974444796302561569813029771831944, "file_name": "vm.c", "file_hash": 83886473477345826235413068203214397377, "cwe": ["CWE-288"], "cve": "CVE-2022-1212", "cve_desc": "Use-After-Free in str_escape in mruby/mruby in GitHub repository mruby/mruby prior to 3.2. Possible arbitrary code execution if being exploited.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1212"}
{"idx": 220002, "project": "glewlwyd", "commit_id": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "project_url": "https://github.com/babelouest/glewlwyd", "commit_url": "https://github.com/babelouest/glewlwyd/commit/125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "commit_message": "Fix update session when auth fail", "target": 0, "func": "int callback_glewlwyd_get_user_auth_scheme_module_list (const struct _u_request * request, struct _u_response * response, void * user_auth_scheme_data) {\n  UNUSED(request);\n  struct config_elements * config = (struct config_elements *)user_auth_scheme_data;\n  json_t * j_module;\n  \n  j_module = get_user_auth_scheme_module_list(config);\n  if (check_result_value(j_module, G_OK)) {\n    ulfius_set_json_body_response(response, 200, json_object_get(j_module, \"module\"));\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_get_user_auth_scheme_module_list - Error get_user_auth_scheme_module_list\");\n    response->status = 500;\n  }\n  json_decref(j_module);\n  return U_CALLBACK_CONTINUE;\n}", "func_hash": 107346189894505857560796495983736469106, "file_name": "webservice.c", "file_hash": 287798817606377336444620654835011177393, "cwe": ["CWE-287"], "cve": "CVE-2021-45379", "cve_desc": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-45379"}
{"idx": 209927, "project": "spice-vd_agent", "commit_id": "812ca777469a377c84b9861d7d326bfc72563304", "project_url": "https://github.com/freedesktop/spice-vd_agent", "commit_url": "https://github.com/freedesktop/spice-vd_agent/commit/812ca777469a377c84b9861d7d326bfc72563304", "commit_message": "vdagentd: Limit number of agents per session to 1\n\nSigned-off-by: Frediano Ziglio <freddy77@gmail.com>\nAcked-by: Uri Lublin <uril@redhat.com>", "target": 1, "func": "static void agent_connect(UdscsConnection *conn)\n{\n    struct agent_data *agent_data;\n    agent_data = g_new0(struct agent_data, 1);\n    GError *err = NULL;\n\n    if (session_info) {\n        PidUid pid_uid = vdagent_connection_get_peer_pid_uid(VDAGENT_CONNECTION(conn), &err);\n        if (err || pid_uid.pid <= 0) {\n            static const char msg[] = \"Could not get peer PID, disconnecting new client\";\n            if (err) {\n                syslog(LOG_ERR, \"%s: %s\", msg, err->message);\n                g_error_free(err);\n            } else {\n                syslog(LOG_ERR, \"%s\", msg);\n            }\n            agent_data_destroy(agent_data);\n            udscs_server_destroy_connection(server, conn);\n            return;\n        }\n\n        agent_data->session = session_info_session_for_pid(session_info, pid_uid.pid);\n\n        uid_t session_uid = session_info_uid_for_session(session_info, agent_data->session);\n\n        /* Check that the UID of the PID did not change, this should be done after\n         * computing the session to avoid race conditions.\n         * This can happen as vdagent_connection_get_peer_pid_uid get information\n         * from the time of creating the socket, but the process in the meantime\n         * have been replaced */\n        if (!check_uid_of_pid(pid_uid.pid, pid_uid.uid) ||\n            /* Check that the user launching the Agent is the same as session one\n             * or root user.\n             * This prevents session hijacks from other users. */\n            (pid_uid.uid != 0 && pid_uid.uid != session_uid)) {\n            syslog(LOG_ERR, \"UID mismatch: UID=%u PID=%u suid=%u\", pid_uid.uid,\n                   pid_uid.pid, session_uid);\n            agent_data_destroy(agent_data);\n            udscs_server_destroy_connection(server, conn);\n            return;\n        }\n    }\n\n    g_object_set_data_full(G_OBJECT(conn), \"agent_data\", agent_data,\n                           (GDestroyNotify) agent_data_destroy);\n    udscs_write(conn, VDAGENTD_VERSION, 0, 0,\n                (uint8_t *)VERSION, strlen(VERSION) + 1);\n    update_active_session_connection(conn);\n\n    if (device_info) {\n        forward_data_to_session_agent(VDAGENTD_GRAPHICS_DEVICE_INFO,\n                                      (uint8_t *) device_info, device_info_size);\n    }\n}", "func_hash": 90973797653152620575021442606199853396, "file_name": "vdagentd.c", "file_hash": 321316558871652100183104309515139531685, "cwe": ["CWE-770"], "cve": "CVE-2020-25652", "cve_desc": "A flaw was found in the spice-vdagentd daemon, where it did not properly handle client connections that can be established via the UNIX domain socket in `/run/spice-vdagentd/spice-vdagent-sock`. Any unprivileged local guest user could use this flaw to prevent legitimate agents from connecting to the spice-vdagentd daemon, resulting in a denial of service. The highest threat from this vulnerability is to system availability. This flaw affects spice-vdagent versions 0.20 and prior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-25652"}
{"idx": 96947, "project": "Chrome", "commit_id": "3c1864079c441ea2e08f882acaaf441f78a6de3d", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/3c1864079c441ea2e08f882acaaf441f78a6de3d", "commit_message": "None", "target": 0, "func": "bool decode(ArgumentDecoder* decoder, RetainPtr<CFNumberRef>& result)\n{\n    CFNumberType numberType;\n    if (!decoder->decodeEnum(numberType))\n        return false;\n\n    CoreIPC::DataReference dataReference;\n    if (!decoder->decode(dataReference))\n        return false;\n\n    size_t neededBufferSize = sizeForNumberType(numberType);\n    if (!neededBufferSize || dataReference.size() != neededBufferSize)\n        return false;\n\n    ASSERT(dataReference.data());\n    CFNumberRef number = CFNumberCreate(0, numberType, dataReference.data());\n    result.adoptCF(number);\n\n    return true;\n}\n", "func_hash": 19895660395290471297813488445728147255, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 215391, "project": "linux-2.6", "commit_id": "ba0166708ef4da7eeb61dd92bbba4d5a749d6561", "project_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6", "commit_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=ba0166708ef4da7eeb61dd92bbba4d5a749d6561", "commit_message": "sctp: Fix kernel panic while process protocol violation parameter\n\nSince call to function sctp_sf_abort_violation() need paramter 'arg' with\n'struct sctp_chunk' type, it will read the chunk type and chunk length from\nthe chunk_hdr member of chunk. But call to sctp_sf_violation_paramlen()\nalways with 'struct sctp_paramhdr' type's parameter, it will be passed to\nsctp_sf_abort_violation(). This may cause kernel panic.\n\n   sctp_sf_violation_paramlen()\n     |-- sctp_sf_abort_violation()\n        |-- sctp_make_abort_violation()\n\nThis patch fixed this problem. This patch also fix two place which called\nsctp_sf_violation_paramlen() with wrong paramter type.\n\nSigned-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "static sctp_disposition_t sctp_sf_violation_paramlen(\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands) {\n\tstatic const char err_str[] = \"The following parameter had invalid length:\";\n\n\treturn sctp_sf_abort_violation(ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}", "func_hash": 31315788610604386259282762063646605709, "file_name": "None", "file_hash": null, "cwe": ["CWE-20"], "cve": "CVE-2008-4618", "cve_desc": "The Stream Control Transmission Protocol (sctp) implementation in the Linux kernel before 2.6.27 does not properly handle a protocol violation in which a parameter has an invalid length, which allows attackers to cause a denial of service (panic) via unspecified vectors, related to sctp_sf_violation_paramlen, sctp_sf_abort_violation, sctp_make_abort_violation, and incorrect data types in function calls.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2008-4618"}
{"idx": 219037, "project": "tensorflow", "commit_id": "240655511cd3e701155f944a972db71b6c0b1bb6", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/240655511cd3e701155f944a972db71b6c0b1bb6", "commit_message": "Eliminate `CHECK`-fails from `IsSimplifiableReshape` via `MakeShape(<invalid shape>)`\n\nPiperOrigin-RevId: 409166738\nChange-Id: I7f0a3590b8acae3f3e3e2fe636e1f5ef285693cf", "target": 0, "func": "void ConstantFolding::ReplaceOperationWithSnapshot(\n    int input_to_forward, const GraphProperties& properties, NodeDef* node,\n    GraphDef* graph) {\n  // If the graph contains no ops that mutate their inputs, we can\n  // use Identity instead of Snapshot.\n  if (!graph_contains_assign_or_inplace_op_) {\n    ReplaceOperationWithIdentity(input_to_forward, properties, node, graph);\n    return;\n  }\n\n  const DataType dtype = GetDataTypeFromNodeOrProps(*node, properties);\n  if (dtype == DT_INVALID) return;\n\n  node->set_op(\"Snapshot\");\n  EraseRegularNodeAttributes(node);\n  (*node->mutable_attr())[\"T\"].set_type(dtype);\n  // Propagate the designated input through the Snapshot.\n  node->mutable_input()->SwapElements(0, input_to_forward);\n  // Add all other inputs as control dependencies.\n  for (int i = 1; i < node->input_size(); ++i) {\n    if (IsControlInput(node->input(i))) {\n      break;\n    }\n    const string ctrl_dep =\n        AddControlDependency(node->input(i), graph, node_map_.get());\n    node_map_->UpdateInput(node->name(), node->input(i), ctrl_dep);\n    node->set_input(i, ctrl_dep);\n  }\n  graph_modified_ = true;\n}", "func_hash": 81096528513535812499033780415144835130, "file_name": "constant_folding.cc", "file_hash": 221573695858123615640237954647315751120, "cwe": ["CWE-617"], "cve": "CVE-2022-23581", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The Grappler optimizer in TensorFlow can be used to cause a denial of service by altering a `SavedModel` such that `IsSimplifiableReshape` would trigger `CHECK` failures. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23581"}
{"idx": 221630, "project": "tensorflow", "commit_id": "35f0fabb4c178253a964d7aabdbb15c6a398b69a", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/35f0fabb4c178253a964d7aabdbb15c6a398b69a", "commit_message": "Avoid Segfault for scalar shapes.\n\nCalling tensor::FromElementsOp with an empty vector of elements and no type\ncauses a segfault. We need to let the FromElementsOp know which scalar type it\nshould have.\nAlso add back the DynamicBroadcastInDimOp canonicalization patterns, which\npreviously prevented this bug from happening.\nAdd a regression test that demonstrates the bug.\n\nPiperOrigin-RevId: 417561444\nChange-Id: I6d1d6cfb71aabbad6102422625a00bbe253ac95a", "target": 0, "func": "DynamicBroadcastInDimOpLowering::DynamicBroadcastInDimOpLowering(\n    MLIRContext* ctx)\n    : Base(ctx) {}", "func_hash": 280279696923561040610367602422968409197, "file_name": "tf_cpurt_symbolic_shape_optimization.cc", "file_hash": 61127670286277963749447708912499557476, "cwe": ["CWE-754"], "cve": "CVE-2022-23593", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The `simplifyBroadcast` function in the MLIR-TFRT infrastructure in TensorFlow is vulnerable to a segfault (hence, denial of service), if called with scalar shapes. If all shapes are scalar, then `maxRank` is 0, so we build an empty `SmallVector`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23593"}
{"idx": 96950, "project": "Chrome", "commit_id": "3c1864079c441ea2e08f882acaaf441f78a6de3d", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/3c1864079c441ea2e08f882acaaf441f78a6de3d", "commit_message": "None", "target": 0, "func": "bool decode(ArgumentDecoder* decoder, RetainPtr<SecKeychainItemRef>& result)\n{\n    RetainPtr<CFDataRef> data;\n    if (!CoreIPC::decode(decoder, data))\n        return false;\n\n    SecKeychainItemRef item;\n    if (SecKeychainItemCopyFromPersistentReference(data.get(), &item) != errSecSuccess || !item)\n        return false;\n    \n    result.adoptCF(item);\n    return true;\n}\n", "func_hash": 139901913355719619922410167476069304050, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 210206, "project": "squid", "commit_id": "780c4ea1b4c9d2fb41f6962aa6ed73ae57f74b2b", "project_url": "https://github.com/squid-cache/squid", "commit_url": "https://github.com/squid-cache/squid/commit/780c4ea1b4c9d2fb41f6962aa6ed73ae57f74b2b", "commit_message": "Improve handling of Gopher responses (#1022)", "target": 1, "func": "gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)\n{\n    char *pos = inbuf;\n    char *lpos = NULL;\n    char *tline = NULL;\n    LOCAL_ARRAY(char, line, TEMP_BUF_SIZE);\n    LOCAL_ARRAY(char, tmpbuf, TEMP_BUF_SIZE);\n    char *name = NULL;\n    char *selector = NULL;\n    char *host = NULL;\n    char *port = NULL;\n    char *escaped_selector = NULL;\n    const char *icon_url = NULL;\n    char gtype;\n    StoreEntry *entry = NULL;\n\n    memset(tmpbuf, '\\0', TEMP_BUF_SIZE);\n    memset(line, '\\0', TEMP_BUF_SIZE);\n\n    entry = gopherState->entry;\n\n    if (gopherState->conversion == GopherStateData::HTML_INDEX_PAGE) {\n        char *html_url = html_quote(entry->url());\n        gopherHTMLHeader(entry, \"Gopher Index %s\", html_url);\n        storeAppendPrintf(entry,\n                          \"<p>This is a searchable Gopher index. Use the search\\n\"\n                          \"function of your browser to enter search terms.\\n\"\n                          \"<ISINDEX>\\n\");\n        gopherHTMLFooter(entry);\n        /* now let start sending stuff to client */\n        entry->flush();\n        gopherState->HTML_header_added = 1;\n\n        return;\n    }\n\n    if (gopherState->conversion == GopherStateData::HTML_CSO_PAGE) {\n        char *html_url = html_quote(entry->url());\n        gopherHTMLHeader(entry, \"CSO Search of %s\", html_url);\n        storeAppendPrintf(entry,\n                          \"<P>A CSO database usually contains a phonebook or\\n\"\n                          \"directory.  Use the search function of your browser to enter\\n\"\n                          \"search terms.</P><ISINDEX>\\n\");\n        gopherHTMLFooter(entry);\n        /* now let start sending stuff to client */\n        entry->flush();\n        gopherState->HTML_header_added = 1;\n\n        return;\n    }\n\n    String outbuf;\n\n    if (!gopherState->HTML_header_added) {\n        if (gopherState->conversion == GopherStateData::HTML_CSO_RESULT)\n            gopherHTMLHeader(entry, \"CSO Search Result\", NULL);\n        else\n            gopherHTMLHeader(entry, \"Gopher Menu\", NULL);\n\n        outbuf.append (\"<PRE>\");\n\n        gopherState->HTML_header_added = 1;\n\n        gopherState->HTML_pre = 1;\n    }\n\n    while (pos < inbuf + len) {\n        int llen;\n        int left = len - (pos - inbuf);\n        lpos = (char *)memchr(pos, '\\n', left);\n        if (lpos) {\n            ++lpos;             /* Next line is after \\n */\n            llen = lpos - pos;\n        } else {\n            llen = left;\n        }\n        if (gopherState->len + llen >= TEMP_BUF_SIZE) {\n            debugs(10, DBG_IMPORTANT, \"GopherHTML: Buffer overflow. Lost some data on URL: \" << entry->url()  );\n            llen = TEMP_BUF_SIZE - gopherState->len - 1;\n        }\n        if (!lpos) {\n            /* there is no complete line in inbuf */\n            /* copy it to temp buffer */\n            /* note: llen is adjusted above */\n            memcpy(gopherState->buf + gopherState->len, pos, llen);\n            gopherState->len += llen;\n            break;\n        }\n        if (gopherState->len != 0) {\n            /* there is something left from last tx. */\n            memcpy(line, gopherState->buf, gopherState->len);\n            memcpy(line + gopherState->len, pos, llen);\n            llen += gopherState->len;\n            gopherState->len = 0;\n        } else {\n            memcpy(line, pos, llen);\n        }\n        line[llen + 1] = '\\0';\n        /* move input to next line */\n        pos = lpos;\n\n        /* at this point. We should have one line in buffer to process */\n\n        if (*line == '.') {\n            /* skip it */\n            memset(line, '\\0', TEMP_BUF_SIZE);\n            continue;\n        }\n\n        switch (gopherState->conversion) {\n\n        case GopherStateData::HTML_INDEX_RESULT:\n\n        case GopherStateData::HTML_DIR: {\n            tline = line;\n            gtype = *tline;\n            ++tline;\n            name = tline;\n            selector = strchr(tline, TAB);\n\n            if (selector) {\n                *selector = '\\0';\n                ++selector;\n                host = strchr(selector, TAB);\n\n                if (host) {\n                    *host = '\\0';\n                    ++host;\n                    port = strchr(host, TAB);\n\n                    if (port) {\n                        char *junk;\n                        port[0] = ':';\n                        junk = strchr(host, TAB);\n\n                        if (junk)\n                            *junk++ = 0;    /* Chop port */\n                        else {\n                            junk = strchr(host, '\\r');\n\n                            if (junk)\n                                *junk++ = 0;    /* Chop port */\n                            else {\n                                junk = strchr(host, '\\n');\n\n                                if (junk)\n                                    *junk++ = 0;    /* Chop port */\n                            }\n                        }\n\n                        if ((port[1] == '0') && (!port[2]))\n                            port[0] = 0;    /* 0 means none */\n                    }\n\n                    /* escape a selector here */\n                    escaped_selector = xstrdup(rfc1738_escape_part(selector));\n\n                    switch (gtype) {\n\n                    case GOPHER_DIRECTORY:\n                        icon_url = mimeGetIconURL(\"internal-menu\");\n                        break;\n\n                    case GOPHER_HTML:\n\n                    case GOPHER_FILE:\n                        icon_url = mimeGetIconURL(\"internal-text\");\n                        break;\n\n                    case GOPHER_INDEX:\n\n                    case GOPHER_CSO:\n                        icon_url = mimeGetIconURL(\"internal-index\");\n                        break;\n\n                    case GOPHER_IMAGE:\n\n                    case GOPHER_GIF:\n\n                    case GOPHER_PLUS_IMAGE:\n                        icon_url = mimeGetIconURL(\"internal-image\");\n                        break;\n\n                    case GOPHER_SOUND:\n\n                    case GOPHER_PLUS_SOUND:\n                        icon_url = mimeGetIconURL(\"internal-sound\");\n                        break;\n\n                    case GOPHER_PLUS_MOVIE:\n                        icon_url = mimeGetIconURL(\"internal-movie\");\n                        break;\n\n                    case GOPHER_TELNET:\n\n                    case GOPHER_3270:\n                        icon_url = mimeGetIconURL(\"internal-telnet\");\n                        break;\n\n                    case GOPHER_BIN:\n\n                    case GOPHER_MACBINHEX:\n\n                    case GOPHER_DOSBIN:\n\n                    case GOPHER_UUENCODED:\n                        icon_url = mimeGetIconURL(\"internal-binary\");\n                        break;\n\n                    case GOPHER_INFO:\n                        icon_url = NULL;\n                        break;\n\n                    default:\n                        icon_url = mimeGetIconURL(\"internal-unknown\");\n                        break;\n                    }\n\n                    memset(tmpbuf, '\\0', TEMP_BUF_SIZE);\n\n                    if ((gtype == GOPHER_TELNET) || (gtype == GOPHER_3270)) {\n                        if (strlen(escaped_selector) != 0)\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s@%s%s%s/\\\">%s</A>\\n\",\n                                     icon_url, escaped_selector, rfc1738_escape_part(host),\n                                     *port ? \":\" : \"\", port, html_quote(name));\n                        else\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s%s%s/\\\">%s</A>\\n\",\n                                     icon_url, rfc1738_escape_part(host), *port ? \":\" : \"\",\n                                     port, html_quote(name));\n\n                    } else if (gtype == GOPHER_INFO) {\n                        snprintf(tmpbuf, TEMP_BUF_SIZE, \"\\t%s\\n\", html_quote(name));\n                    } else {\n                        if (strncmp(selector, \"GET /\", 5) == 0) {\n                            /* WWW link */\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"http://%s/%s\\\">%s</A>\\n\",\n                                     icon_url, host, rfc1738_escape_unescaped(selector + 5), html_quote(name));\n                        } else {\n                            /* Standard link */\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"gopher://%s/%c%s\\\">%s</A>\\n\",\n                                     icon_url, host, gtype, escaped_selector, html_quote(name));\n                        }\n                    }\n\n                    safe_free(escaped_selector);\n                    outbuf.append(tmpbuf);\n                } else {\n                    memset(line, '\\0', TEMP_BUF_SIZE);\n                    continue;\n                }\n            } else {\n                memset(line, '\\0', TEMP_BUF_SIZE);\n                continue;\n            }\n\n            break;\n            }           /* HTML_DIR, HTML_INDEX_RESULT */\n\n        case GopherStateData::HTML_CSO_RESULT: {\n            if (line[0] == '-') {\n                int code, recno;\n                char *s_code, *s_recno, *result;\n\n                s_code = strtok(line + 1, \":\\n\");\n                s_recno = strtok(NULL, \":\\n\");\n                result = strtok(NULL, \"\\n\");\n\n                if (!result)\n                    break;\n\n                code = atoi(s_code);\n\n                recno = atoi(s_recno);\n\n                if (code != 200)\n                    break;\n\n                if (gopherState->cso_recno != recno) {\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"</PRE><HR noshade size=\\\"1px\\\"><H2>Record# %d<br><i>%s</i></H2>\\n<PRE>\", recno, html_quote(result));\n                    gopherState->cso_recno = recno;\n                } else {\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"%s\\n\", html_quote(result));\n                }\n\n                outbuf.append(tmpbuf);\n                break;\n            } else {\n                int code;\n                char *s_code, *result;\n\n                s_code = strtok(line, \":\");\n                result = strtok(NULL, \"\\n\");\n\n                if (!result)\n                    break;\n\n                code = atoi(s_code);\n\n                switch (code) {\n\n                case 200: {\n                    /* OK */\n                    /* Do nothing here */\n                    break;\n                }\n\n                case 102:   /* Number of matches */\n\n                case 501:   /* No Match */\n\n                case 502: { /* Too Many Matches */\n                    /* Print the message the server returns */\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"</PRE><HR noshade size=\\\"1px\\\"><H2>%s</H2>\\n<PRE>\", html_quote(result));\n                    outbuf.append(tmpbuf);\n                    break;\n                }\n\n                }\n            }\n\n            }           /* HTML_CSO_RESULT */\n\n        default:\n            break;      /* do nothing */\n\n        }           /* switch */\n\n    }               /* while loop */\n\n    if (outbuf.size() > 0) {\n        entry->append(outbuf.rawBuf(), outbuf.size());\n        /* now let start sending stuff to client */\n        entry->flush();\n    }\n\n    outbuf.clean();\n    return;\n}", "func_hash": 69907744519047196773632287126924030666, "file_name": "gopher.cc", "file_hash": 274206304991379198598012995880144954128, "cwe": ["CWE-400"], "cve": "CVE-2021-46784", "cve_desc": "In Squid 3.x through 3.5.28, 4.x through 4.17, and 5.x before 5.6, due to improper buffer management, a Denial of Service can occur when processing long Gopher server responses.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-46784"}
{"idx": 198449, "project": "pjproject", "commit_id": "450baca94f475345542c6953832650c390889202", "project_url": "https://github.com/pjsip/pjproject", "commit_url": "https://github.com/pjsip/pjproject/commit/450baca94f475345542c6953832650c390889202", "commit_message": "Merge pull request from GHSA-26j7-ww69-c4qj", "target": 1, "func": "PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len, \n\t\t\t\t      pjstun_msg *msg)\n{\n    pj_uint16_t msg_type, msg_len;\n    char *p_attr;\n\n    PJ_CHECK_STACK();\n\n    msg->hdr = (pjstun_msg_hdr*)buf;\n    msg_type = pj_ntohs(msg->hdr->type);\n\n    switch (msg_type) {\n    case PJSTUN_BINDING_REQUEST:\n    case PJSTUN_BINDING_RESPONSE:\n    case PJSTUN_BINDING_ERROR_RESPONSE:\n    case PJSTUN_SHARED_SECRET_REQUEST:\n    case PJSTUN_SHARED_SECRET_RESPONSE:\n    case PJSTUN_SHARED_SECRET_ERROR_RESPONSE:\n\tbreak;\n    default:\n\tPJ_LOG(4,(THIS_FILE, \"Error: unknown msg type %d\", msg_type));\n\treturn PJLIB_UTIL_ESTUNINMSGTYPE;\n    }\n\n    msg_len = pj_ntohs(msg->hdr->length);\n    if (msg_len != buf_len - sizeof(pjstun_msg_hdr)) {\n\tPJ_LOG(4,(THIS_FILE, \"Error: invalid msg_len %d (expecting %d)\", \n\t\t\t     msg_len, buf_len - sizeof(pjstun_msg_hdr)));\n\treturn PJLIB_UTIL_ESTUNINMSGLEN;\n    }\n\n    msg->attr_count = 0;\n    p_attr = (char*)buf + sizeof(pjstun_msg_hdr);\n\n    while (msg_len > 0) {\n\tpjstun_attr_hdr **attr = &msg->attr[msg->attr_count];\n\tpj_uint32_t len;\n\tpj_uint16_t attr_type;\n\n\t*attr = (pjstun_attr_hdr*)p_attr;\n\tlen = pj_ntohs((pj_uint16_t) ((*attr)->length)) + sizeof(pjstun_attr_hdr);\n\tlen = (len + 3) & ~3;\n\n\tif (msg_len < len) {\n\t    PJ_LOG(4,(THIS_FILE, \"Error: length mismatch in attr %d\", \n\t\t\t\t msg->attr_count));\n\t    return PJLIB_UTIL_ESTUNINATTRLEN;\n\t}\n\n\tattr_type = pj_ntohs((*attr)->type);\n\tif (attr_type > PJSTUN_ATTR_REFLECTED_FROM &&\n\t    attr_type != PJSTUN_ATTR_XOR_MAPPED_ADDR)\n\t{\n\t    PJ_LOG(5,(THIS_FILE, \"Warning: unknown attr type %x in attr %d. \"\n\t\t\t\t \"Attribute was ignored.\",\n\t\t\t\t attr_type, msg->attr_count));\n\t}\n\n\tmsg_len = (pj_uint16_t)(msg_len - len);\n\tp_attr += len;\n\t++msg->attr_count;\n    }\n\n    return PJ_SUCCESS;\n}", "func_hash": 324794898254091416853424941566787120064, "file_name": "stun_simple.c", "file_hash": 304268271857931505815837287097781884670, "cwe": ["CWE-787"], "cve": "CVE-2022-31031", "cve_desc": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In versions prior to and including 2.12.1 a stack buffer overflow vulnerability affects PJSIP users that use STUN in their applications, either by: setting a STUN server in their account/media config in PJSUA/PJSUA2 level, or directly using `pjlib-util/stun_simple` API. A patch is available in commit 450baca which should be included in the next release. There are no known workarounds for this issue.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-31031"}
{"idx": 221414, "project": "linux", "commit_id": "c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc", "commit_message": "KVM: nSVM: always intercept VMLOAD/VMSAVE when nested (CVE-2021-3656)\n\nIf L1 disables VMLOAD/VMSAVE intercepts, and doesn't enable\nVirtual VMLOAD/VMSAVE (currently not supported for the nested hypervisor),\nthen VMLOAD/VMSAVE must operate on the L1 physical memory, which is only\npossible by making L0 intercept these instructions.\n\nFailure to do so allowed the nested guest to run VMLOAD/VMSAVE unintercepted,\nand thus read/write portions of the host physical memory.\n\nFixes: 89c8a4984fc9 (\"KVM: SVM: Enable Virtual VMLOAD VMSAVE feature\")\n\nSuggested-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Maxim Levitsky <mlevitsk@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "target": 0, "func": "void svm_free_nested(struct vcpu_svm *svm)\n{\n\tif (!svm->nested.initialized)\n\t\treturn;\n\n\tsvm_vcpu_free_msrpm(svm->nested.msrpm);\n\tsvm->nested.msrpm = NULL;\n\n\t__free_page(virt_to_page(svm->nested.vmcb02.ptr));\n\tsvm->nested.vmcb02.ptr = NULL;\n\n\t/*\n\t * When last_vmcb12_gpa matches the current vmcb12 gpa,\n\t * some vmcb12 fields are not loaded if they are marked clean\n\t * in the vmcb12, since in this case they are up to date already.\n\t *\n\t * When the vmcb02 is freed, this optimization becomes invalid.\n\t */\n\tsvm->nested.last_vmcb12_gpa = INVALID_GPA;\n\n\tsvm->nested.initialized = false;\n}", "func_hash": 53390816335069312753704865303174529501, "file_name": "None", "file_hash": null, "cwe": ["CWE-862"], "cve": "CVE-2021-3656", "cve_desc": "A flaw was found in the KVM's AMD code for supporting SVM nested virtualization. The flaw occurs when processing the VMCB (virtual machine control block) provided by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation of the \"virt_ext\" field, this issue could allow a malicious L1 to disable both VMLOAD/VMSAVE intercepts and VLS (Virtual VMLOAD/VMSAVE) for the L2 guest. As a result, the L2 guest would be allowed to read/write physical pages of the host, resulting in a crash of the entire system, leak of sensitive data or potential guest-to-host escape.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3656"}
{"idx": 210961, "project": "linux", "commit_id": "fecf31ee395b0295f2d7260aa29946b7605f7c85", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/netfilter/nf_tables_api.c?id=fecf31ee395b0295f2d7260aa29946b7605f7c85", "commit_message": "netfilter: nf_tables: sanitize nft_set_desc_concat_parse()\n\nAdd several sanity checks for nft_set_desc_concat_parse():\n\n- validate desc->field_count not larger than desc->field_len array.\n- field length cannot be larger than desc->field_len (ie. U8_MAX)\n- total length of the concatenation cannot be larger than register array.\n\nJoint work with Florian Westphal.\n\nFixes: f3a2181e16f1 (\"netfilter: nf_tables: Support for sets with multiple ranged fields\")\nReported-by: <zhangziming.zzm@antgroup.com>\nReviewed-by: Stefano Brivio <sbrivio@redhat.com>\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>", "target": 1, "func": "static int nft_set_desc_concat_parse(const struct nlattr *attr,\n\t\t\t\t     struct nft_set_desc *desc)\n{\n\tstruct nlattr *tb[NFTA_SET_FIELD_MAX + 1];\n\tu32 len;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr,\n\t\t\t\t\t  nft_concat_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_SET_FIELD_LEN])\n\t\treturn -EINVAL;\n\n\tlen = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));\n\n\tif (len * BITS_PER_BYTE / 32 > NFT_REG32_COUNT)\n\t\treturn -E2BIG;\n\n\tdesc->field_len[desc->field_count++] = len;\n\n\treturn 0;\n}", "func_hash": 78008534316897646472365698707410678350, "file_name": "nf_tables_api.c", "file_hash": 240934795933474880133223486110809737536, "cwe": ["CWE-121"], "cve": "CVE-2022-2078", "cve_desc": "A vulnerability was found in the Linux kernel's nft_set_desc_concat_parse() function .This flaw allows an attacker to trigger a buffer overflow via nft_set_desc_concat_parse() , causing a denial of service and possibly to run code.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2078"}
{"idx": 216906, "project": "server", "commit_id": "9e39d0ae44595dbd1570805d97c9c874778a6be8", "project_url": "https://github.com/MariaDB/server", "commit_url": "https://github.com/MariaDB/server/commit/9e39d0ae44595dbd1570805d97c9c874778a6be8", "commit_message": "MDEV-25787 Bug report: crash on SELECT DISTINCT thousands_blob_fields\n\nfix a debug assert to account for not opened temp tables", "target": 1, "func": "void ha_maria::drop_table(const char *name)\n{\n  DBUG_ASSERT(file->s->temporary);\n  (void) ha_close();\n  (void) maria_delete_table_files(name, 1, MY_WME);\n}", "func_hash": 85612271673629964630565572694774133988, "file_name": "None", "file_hash": null, "cwe": ["CWE-400"], "cve": "CVE-2021-46668", "cve_desc": "MariaDB through 10.5.9 allows an application crash via certain long SELECT DISTINCT statements that improperly interact with storage-engine resource limitations for temporary data structures.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-46668"}
{"idx": 221676, "project": "e2guardian", "commit_id": "eae46a7e2a57103aadca903c4a24cca94dc502a2", "project_url": "https://github.com/e2guardian/e2guardian", "commit_url": "https://github.com/e2guardian/e2guardian/commit/eae46a7e2a57103aadca903c4a24cca94dc502a2", "commit_message": "Fix bug #707 cert hostnames not being checked\n- only happened when openssl v1.1 is used", "target": 0, "func": "void Socket::close()\n{\n    if (isssl) {\n        stopSsl();\n    }\n    BaseSocket::close();\n}", "func_hash": 159904369968594743091011695118972248491, "file_name": "Socket.cpp", "file_hash": 316707147744091371767800459911917453562, "cwe": ["CWE-295"], "cve": "CVE-2021-44273", "cve_desc": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-44273"}
{"idx": 221509, "project": "flatpak", "commit_id": "89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "commit_message": "run: Add cross-references for some other seccomp syscall filters\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "target": 0, "func": "apply_exports (char            **envp,\n               const ExportData *exports,\n               gsize             n_exports)\n{\n  int i;\n\n  for (i = 0; i < n_exports; i++)\n    {\n      const char *value = exports[i].val;\n\n      if (value)\n        envp = g_environ_setenv (envp, exports[i].env, value, TRUE);\n      else\n        envp = g_environ_unsetenv (envp, exports[i].env);\n    }\n\n  return envp;\n}", "func_hash": 104750829307739800412693661991787982384, "file_name": "flatpak-run.c", "file_hash": 32398709380082441128978861691951488575, "cwe": ["CWE-20"], "cve": "CVE-2021-41133", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41133"}
{"idx": 90234, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  ~NetworkLibraryImpl() {\n    network_manager_observers_.Clear();\n    if (network_manager_monitor_)\n      DisconnectPropertyChangeMonitor(network_manager_monitor_);\n    data_plan_observers_.Clear();\n    if (data_plan_monitor_)\n      DisconnectDataPlanUpdateMonitor(data_plan_monitor_);\n    STLDeleteValues(&network_observers_);\n    ClearNetworks();\n  }\n", "func_hash": 312935633555380726391402607011658090892, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 195063, "project": "gpac", "commit_id": "5f2c2a16d30229b6241f02fa28e3d6b810d64858", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/5f2c2a16d30229b6241f02fa28e3d6b810d64858", "commit_message": "fixed #1905", "target": 1, "func": "GF_Err mpgviddmx_process(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu64 byte_offset;\n\ts64 vosh_start = -1;\n\ts64 vosh_end = -1;\n\tGF_Err e;\n\tchar *data;\n\tu8 *start;\n\tu32 pck_size;\n\ts32 remain;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmpgviddmx_check_dur(filter, ctx);\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tstart = data;\n\tremain = pck_size;\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (!ctx->resume_from && ctx->timescale) {\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->cts || !ctx->recompute_cts)\n\t\t\t\tctx->cts = ts;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->dts || !ctx->recompute_cts)\n\t\t\t\tctx->dts = ts;\n\n\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\tu64 diff = ts;\n\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\tif (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;\n\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t}\n\t\t}\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);\n\t\t//this will force CTS recomput of each frame\n\t\tif (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t}\n\n\t//we stored some data to find the complete vosh, aggregate this packet with current one\n\tif (!ctx->resume_from && ctx->hdr_store_size) {\n\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {\n\t\t\tctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;\n\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t}\n\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);\n\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\tif (byte_offset >= ctx->hdr_store_size)\n\t\t\t\tbyte_offset -= ctx->hdr_store_size;\n\t\t\telse\n\t\t\t\tbyte_offset = GF_FILTER_NO_BO;\n\t\t}\n\t\tctx->hdr_store_size += pck_size;\n\t\tstart = data = ctx->hdr_store;\n\t\tremain = pck_size = ctx->hdr_store_size;\n\t}\n\n\tif (ctx->resume_from) {\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\n\t\t//resume from data copied internally\n\t\tif (ctx->hdr_store_size) {\n\t\t\tassert(ctx->resume_from <= ctx->hdr_store_size);\n\t\t\tstart = data = ctx->hdr_store + ctx->resume_from;\n\t\t\tremain = pck_size = ctx->hdr_store_size - ctx->resume_from;\n\t\t} else {\n\t\t\tassert(remain >= (s32) ctx->resume_from);\n\t\t\tstart += ctx->resume_from;\n\t\t\tremain -= ctx->resume_from;\n\t\t}\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (!ctx->bs) {\n\t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t}\n\tif (!ctx->vparser) {\n\t\tctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);\n\t}\n\n\n\twhile (remain) {\n\t\tBool full_frame;\n\t\tu8 *pck_data;\n\t\ts32 current;\n\t\tu8 sc_type, forced_sc_type=0;\n\t\tBool sc_type_forced = GF_FALSE;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 size=0;\n\t\tu64 fstart;\n\t\tBool is_coded;\n\t\tu32 bytes_from_store = 0;\n\t\tu32 hdr_offset = 0;\n\t\tBool copy_last_bytes = GF_FALSE;\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = -1;\n\n\t\t//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code.\n\t\t//if not, dispatch these bytes as continuation of the data\n\t\tif (ctx->bytes_in_header) {\n\n\t\t\tmemcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);\n\t\t\tcurrent = mpgviddmx_next_start_code(ctx->hdr_store, 8);\n\n\t\t\t//no start code in stored buffer\n\t\t\tif ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {\n\t\t\t\tif (ctx->opid) {\n\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);\n\t\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tmemcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);\n\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);\n\t\t\t\t\t}\n\n\t\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\t}\n\n\t\t\t\tif (current<0) current = -1;\n\t\t\t\telse current -= ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t} else {\n\t\t\t\t//we have a valid start code, check which byte in our store or in the packet payload is the start code type\n\t\t\t\t//and remember its location to reinit the parser from there\n\t\t\t\thdr_offset = 4 - ctx->bytes_in_header + current;\n\t\t\t\t//bytes still to dispatch\n\t\t\t\tbytes_from_store = ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t\tif (!hdr_offset) {\n\t\t\t\t\tforced_sc_type = ctx->hdr_store[current+3];\n\t\t\t\t} else {\n\t\t\t\t\tforced_sc_type = start[hdr_offset-1];\n\t\t\t\t}\n\t\t\t\tsc_type_forced = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\t//no starcode in store, look for startcode in packet\n\t\tif (current == -1) {\n\t\t\t//locate next start code\n\t\t\tcurrent = mpgviddmx_next_start_code(start, remain);\n\t\t\t//no start code, dispatch the block\n\t\t\tif (current<0) {\n\t\t\t\tu8 b3, b2, b1;\n\t\t\t\tif (! ctx->frame_started) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MPGVid] no start code in block and no frame started, discarding data\\n\" ));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = remain;\n\t\t\t\tb3 = start[remain-3];\n\t\t\t\tb2 = start[remain-2];\n\t\t\t\tb1 = start[remain-1];\n\t\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\t\tassert(size >= 3);\n\t\t\t\t\tsize -= 3;\n\t\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t\t}\n\n\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\n\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tif (copy_last_bytes) {\n\t\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tassert(current>=0);\n\n\t\t//if we are in the middle of parsing the vosh, skip over bytes remaining from previous obj not parsed\n\t\tif ((vosh_start>=0) && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//also skip if no output pid\n\t\tif (!ctx->opid && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//dispatch remaining bytes\n\t\tif (current>0) {\n\t\t\t//flush remaining\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);\n\t\t\t//bytes were partly in store, partly in packet\n\t\t\tif (bytes_from_store) {\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t\t}\n\t\t\t\tassert(bytes_from_store>=(u32) current);\n\t\t\t\tbytes_from_store -= current;\n\t\t\t\tmemcpy(pck_data, ctx->hdr_store, current);\n\t\t\t} else {\n\t\t\t\t//bytes were only in packet\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\t\t\t\tmemcpy(pck_data, start, current);\n\t\t\t\tassert(remain>=current);\n\t\t\t\tstart += current;\n\t\t\t\tremain -= current;\n\t\t\t\tcurrent = 0;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t}\n\n\t\t//parse headers\n\n\t\t//we have a start code loaded, eg the data packet does not have a full start code at the beginning\n\t\tif (sc_type_forced) {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);\n\t\t\tsc_type = forced_sc_type;\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\tgf_bs_read_int(ctx->bs, 24);\n\t\t\tsc_type = gf_bs_read_int(ctx->bs, 8);\n\t\t}\n\n\t\tif (ctx->is_mpg12) {\n\t\t\tswitch (sc_type) {\n\t\t\tcase M2V_SEQ_START_CODE:\n\t\t\tcase M2V_EXT_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx, 0, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M2V_PIC_START_CODE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tu8 PL;\n\t\t\tswitch (sc_type) {\n\t\t\tcase M4V_VOS_START_CODE:\n\t\t\t\tctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);\n\t\t\t\tvosh_start = start - (u8 *)data;\n\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\tassert(remain>=5);\n\t\t\t\tstart += 5;\n\t\t\t\tremain -= 5;\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOL_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\tPL = ctx->dsi.VideoPL;\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\tctx->dsi.VideoPL = PL;\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=(s32) obj_size);\n\t\t\t\t\tstart += obj_size;\n\t\t\t\t\tremain -= obj_size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOP_START_CODE:\n\t\t\tcase M4V_GOV_START_CODE:\n\t\t\t\tbreak;\n\n\t\t\tcase M4V_VO_START_CODE:\n\t\t\tcase M4V_VISOBJ_START_CODE:\n\t\t\tdefault:\n\t\t\t\tif (vosh_start>=0) {\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=4);\n\t\t\t\t\tstart += 4;\n\t\t\t\t\tremain -= 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_pck) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->opid) {\n\t\t\tassert(remain>=4);\n\t\t\tstart += 4;\n\t\t\tremain -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) ((char *)start -  (char *)data);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//at this point, we no longer reaggregate packets\n\t\tctx->hdr_store_size = 0;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);\n\t\t\tif (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\t//may happen that after all our checks, only 4 bytes are left, continue to store these 4 bytes\n\t\tif (remain<5)\n\t\t\tcontinue;\n\n\t\t//good to go\n\t\tgf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);\n\t\tsize = 0;\n\t\te = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);\n\t\t//true if we strip VO and VISOBJ assert(!fstart);\n\n\t\t//we skipped bytes already in store + end of start code present in packet, so the size of the first object\n\t\t//needs adjustement\n\t\tif (bytes_from_store) {\n\t\t\tsize += bytes_from_store + hdr_offset;\n\t\t}\n\n\t\tif ((e == GF_EOS) && !ctx->input_is_au_end) {\n\t\t\tu8 b3 = start[remain-3];\n\t\t\tu8 b2 = start[remain-2];\n\t\t\tu8 b1 = start[remain-1];\n\n\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\tassert(size >= 3);\n\t\t\t\tsize -= 3;\n\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t}\n\t\t\tfull_frame = GF_FALSE;\n\t\t} else {\n\t\t\tfull_frame = GF_TRUE;\n\t\t}\n\n\t\tif (!is_coded) {\n\t\t\t/*if prev is B and we're parsing a packed bitstream discard n-vop*/\n\t\t\tif (ctx->forced_packed && ctx->b_frames) {\n\t\t\t\tctx->is_packed = GF_TRUE;\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to import at variable frame rate, skip*/\n\t\t\tif (ctx->vfr) {\n\t\t\t\tctx->is_vfr = GF_TRUE;\n\t\t\t\tmpgviddmx_update_time(ctx);\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to keep non coded frame (constant frame rate), add*/\n\t\t}\n\n\t\tif (ftype==2) {\n\t\t\t//count number of B-frames since last ref\n\t\t\tctx->b_frames++;\n\t\t\tctx->nb_b++;\n\t\t} else {\n\t\t\t//flush all pending packets\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\t\t\t//remeber the CTS of the last ref\n\t\t\tctx->last_ref_cts = ctx->cts;\n\t\t\tif (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;\n\t\t\t\n\t\t\tctx->b_frames = 0;\n\t\t\tif (ftype)\n\t\t\t\tctx->nb_p++;\n\t\t\telse\n\t\t\t\tctx->nb_i++;\n\t\t}\n\t\tctx->nb_frames++;\n\n\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t//bytes come from both our store and the data packet\n\t\tif (bytes_from_store) {\n\t\t\tmemcpy(pck_data, ctx->hdr_store+current, bytes_from_store);\n\t\t\tassert(size >= bytes_from_store);\n\t\t\tsize -= bytes_from_store;\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t}\n\t\t\tmemcpy(pck_data + bytes_from_store, start, (size_t) size);\n\t\t} else {\n\t\t\t//bytes only come the data packet\n\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);\n\t\t\t}\n\t\t}\n\t\tassert(pck_data[0] == 0);\n\t\tassert(pck_data[1] == 0);\n\t\tassert(pck_data[2] == 0x01);\n\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);\n\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\t\tif (ctx->input_is_au_start) {\n\t\t\tctx->input_is_au_start = GF_FALSE;\n\t\t} else {\n\t\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\t\t}\n\t\tgf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);\n\t\tgf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);\n\t\tif (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);\n\t\tctx->frame_started = GF_TRUE;\n\n\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\n\t\tmpgviddmx_update_time(ctx);\n\n\t\tif (!full_frame) {\n\t\t\tif (copy_last_bytes) {\n\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tassert(remain>=size);\n\t\tstart += size;\n\t\tremain -= (s32) size;\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\treturn GF_OK;\n}", "func_hash": 49630978088913986571244550780083545600, "file_name": "reframe_mpgvid.c", "file_hash": 148306570807841160156662867455353144265, "cwe": ["CWE-476"], "cve": "CVE-2021-40575", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability in the mpgviddmx_process function in reframe_mpgvid.c, which allows attackers to cause a denial of service. This vulnerability is possibly due to an incomplete fix for CVE-2021-40566.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40575"}
{"idx": 212152, "project": "bash", "commit_id": "951bdaad7a18cc0dc1036bba86b18b90874d39ff", "project_url": "https://github.com/bminor/bash", "commit_url": "https://github.com/bminor/bash/commit/951bdaad7a18cc0dc1036bba86b18b90874d39ff", "commit_message": "commit bash-20190628 snapshot", "target": 1, "func": "disable_priv_mode ()\n{\n  int e;\n\n  if (setuid (current_user.uid) < 0)\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n  if (setgid (current_user.gid) < 0)\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}", "func_hash": 247622822404411128670815043239926864688, "file_name": "shell.c", "file_hash": 63031401309370215256197051387367703039, "cwe": ["CWE-787"], "cve": "CVE-2019-18276", "cve_desc": "An issue was discovered in disable_priv_mode in shell.c in GNU Bash through 5.0 patch 11. By default, if Bash is run with its effective UID not equal to its real UID, it will drop privileges by setting its effective UID to its real UID. However, it does so incorrectly. On Linux and other systems that support \"saved UID\" functionality, the saved UID is not dropped. An attacker with command execution in the shell can use \"enable -f\" for runtime loading of a new builtin, which can be a shared object that calls setuid() and therefore regains privileges. However, binaries running with an effective UID of 0 are unaffected.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-18276"}
{"idx": 90110, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "CellularNetwork::CellularNetwork()\n    : WirelessNetwork(),\n      activation_state_(ACTIVATION_STATE_UNKNOWN),\n      network_technology_(NETWORK_TECHNOLOGY_UNKNOWN),\n      roaming_state_(ROAMING_STATE_UNKNOWN),\n      restricted_pool_(false),\n      prl_version_(0) {\n  type_ = TYPE_CELLULAR;\n}\n", "func_hash": 252380351537756827079597733078591804638, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90200, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual const Network* active_network() const { return NULL; }\n", "func_hash": 145850559596126707232896900541221207763, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 221468, "project": "flatpak", "commit_id": "89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "commit_message": "run: Add cross-references for some other seccomp syscall filters\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "target": 0, "func": "flatpak_run_get_minimal_env (gboolean devel, gboolean use_ld_so_cache)\n{\n  GPtrArray *env_array;\n  static const char * const copy[] = {\n    \"PWD\",\n    \"GDMSESSION\",\n    \"XDG_CURRENT_DESKTOP\",\n    \"XDG_SESSION_DESKTOP\",\n    \"DESKTOP_SESSION\",\n    \"EMAIL_ADDRESS\",\n    \"HOME\",\n    \"HOSTNAME\",\n    \"LOGNAME\",\n    \"REAL_NAME\",\n    \"TERM\",\n    \"USER\",\n    \"USERNAME\",\n  };\n  static const char * const copy_nodevel[] = {\n    \"LANG\",\n    \"LANGUAGE\",\n    \"LC_ALL\",\n    \"LC_ADDRESS\",\n    \"LC_COLLATE\",\n    \"LC_CTYPE\",\n    \"LC_IDENTIFICATION\",\n    \"LC_MEASUREMENT\",\n    \"LC_MESSAGES\",\n    \"LC_MONETARY\",\n    \"LC_NAME\",\n    \"LC_NUMERIC\",\n    \"LC_PAPER\",\n    \"LC_TELEPHONE\",\n    \"LC_TIME\",\n  };\n  int i;\n\n  env_array = g_ptr_array_new_with_free_func (g_free);\n\n  add_exports (env_array, default_exports, G_N_ELEMENTS (default_exports));\n\n  if (!use_ld_so_cache)\n    add_exports (env_array, no_ld_so_cache_exports, G_N_ELEMENTS (no_ld_so_cache_exports));\n\n  if (devel)\n    add_exports (env_array, devel_exports, G_N_ELEMENTS (devel_exports));\n\n  for (i = 0; i < G_N_ELEMENTS (copy); i++)\n    {\n      const char *current = g_getenv (copy[i]);\n      if (current)\n        g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", copy[i], current));\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (copy_nodevel); i++)\n        {\n          const char *current = g_getenv (copy_nodevel[i]);\n          if (current)\n            g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", copy_nodevel[i], current));\n        }\n    }\n\n  g_ptr_array_add (env_array, NULL);\n  return (char **) g_ptr_array_free (env_array, FALSE);\n}", "func_hash": 323134362028628306833172012276594957633, "file_name": "flatpak-run.c", "file_hash": 32398709380082441128978861691951488575, "cwe": ["CWE-20"], "cve": "CVE-2021-41133", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41133"}
{"idx": 221471, "project": "flatpak", "commit_id": "89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "commit_message": "run: Add cross-references for some other seccomp syscall filters\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "target": 0, "func": "flatpak_run_in_transient_unit (const char *appid, GError **error)\n{\n  g_autoptr(GDBusConnection) conn = NULL;\n  g_autofree char *path = NULL;\n  g_autofree char *address = NULL;\n  g_autofree char *name = NULL;\n  g_autofree char *appid_escaped = NULL;\n  g_autofree char *job = NULL;\n  SystemdManager *manager = NULL;\n  GVariantBuilder builder;\n  GVariant *properties = NULL;\n  GVariant *aux = NULL;\n  guint32 pid;\n  GMainLoop *main_loop = NULL;\n  struct JobData data;\n  gboolean res = FALSE;\n  g_autoptr(GMainContextPopDefault) main_context = NULL;\n\n  path = g_strdup_printf (\"/run/user/%d/systemd/private\", getuid ());\n\n  if (!g_file_test (path, G_FILE_TEST_EXISTS))\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED,\n                               _(\"No systemd user session available, cgroups not available\"));\n\n  main_context = flatpak_main_context_new_default ();\n  main_loop = g_main_loop_new (main_context, FALSE);\n\n  address = g_strconcat (\"unix:path=\", path, NULL);\n\n  conn = g_dbus_connection_new_for_address_sync (address,\n                                                 G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT,\n                                                 NULL,\n                                                 NULL, error);\n  if (!conn)\n    goto out;\n\n  manager = systemd_manager_proxy_new_sync (conn,\n                                            G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES,\n                                            NULL,\n                                            \"/org/freedesktop/systemd1\",\n                                            NULL, error);\n  if (!manager)\n    goto out;\n\n  appid_escaped = systemd_unit_name_escape (appid);\n  name = g_strdup_printf (\"app-flatpak-%s-%d.scope\", appid_escaped, getpid ());\n\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a(sv)\"));\n\n  pid = getpid ();\n  g_variant_builder_add (&builder, \"(sv)\",\n                         \"PIDs\",\n                         g_variant_new_fixed_array (G_VARIANT_TYPE (\"u\"),\n                                                    &pid, 1, sizeof (guint32))\n                        );\n\n  properties = g_variant_builder_end (&builder);\n\n  aux = g_variant_new_array (G_VARIANT_TYPE (\"(sa(sv))\"), NULL, 0);\n\n  if (!systemd_manager_call_start_transient_unit_sync (manager,\n                                                       name,\n                                                       \"fail\",\n                                                       properties,\n                                                       aux,\n                                                       &job,\n                                                       NULL,\n                                                       error))\n    goto out;\n\n  data.job = job;\n  data.main_loop = main_loop;\n  g_signal_connect (manager, \"job-removed\", G_CALLBACK (job_removed_cb), &data);\n\n  g_main_loop_run (main_loop);\n\n  res = TRUE;\n\nout:\n  if (main_loop)\n    g_main_loop_unref (main_loop);\n  if (manager)\n    g_object_unref (manager);\n\n  return res;\n}", "func_hash": 82727852513332878611802924283403340180, "file_name": "flatpak-run.c", "file_hash": 32398709380082441128978861691951488575, "cwe": ["CWE-20"], "cve": "CVE-2021-41133", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41133"}
{"idx": 221129, "project": "gpac", "commit_id": "a69b567b8c95c72f9560c873c5ab348be058f340", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340", "commit_message": "fixed #1895", "target": 0, "func": "GF_VPConfig *gf_odf_vp_cfg_read(u8 *dsi, u32 dsi_size)\n{\n\tGF_BitStream *bs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tGF_VPConfig *cfg = gf_odf_vp_cfg_read_bs(bs, GF_FALSE);\n\tgf_bs_del(bs);\n\treturn cfg;\n}", "func_hash": 68927801473247288988377294960002948965, "file_name": "descriptors.c", "file_hash": 86476492964393375980272696403064975409, "cwe": ["CWE-415"], "cve": "CVE-2021-40571", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40571"}
{"idx": 221644, "project": "hermes", "commit_id": "55e1b2343f4deb1a1b5726cfe1e23b2068217ff2", "project_url": "https://github.com/facebook/hermes", "commit_url": "https://github.com/facebook/hermes/commit/55e1b2343f4deb1a1b5726cfe1e23b2068217ff2", "commit_message": "Handle typeof applied to empty in InstSimplify\n\nSummary:\nDo not simplify `typeof` if it is applied to an invalid type. This\nhandles a case like the one in the added test, where `typeof` is called\non a literal empty in unreachable code.\n\nReviewed By: kodafb\n\nDifferential Revision: D31000173\n\nfbshipit-source-id: 2d7f69cbcc9c1bb0a916585c07171089444c85dc", "target": 0, "func": "bool hermes::evalIsTrue(IRBuilder &builder, Literal *operand) {\n  if (auto *lit = evalToBoolean(builder, operand))\n    return lit->getValue();\n  return false;\n}", "func_hash": 98153917199842898373603808618995317497, "file_name": "IREval.cpp", "file_hash": 42961914778696217563735135747458181955, "cwe": ["CWE-843"], "cve": "CVE-2021-24045", "cve_desc": "A type confusion vulnerability could be triggered when resolving the \"typeof\" unary operator in Facebook Hermes prior to v0.10.0. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-24045"}
{"idx": 90774, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "int64 GetInitialTemporaryStorageQuotaSize(const FilePath& path,\n                                          bool is_incognito) {\n  int64 free_space = base::SysInfo::AmountOfFreeDiskSpace(path);\n  UMA_HISTOGRAM_MBYTES(\"Quota.FreeDiskSpaceForProfile\", free_space);\n\n  if (free_space < QuotaManager::kTemporaryStorageQuotaDefaultSize * 2)\n    return 0;\n\n  if (is_incognito)\n    return QuotaManager::kIncognitoDefaultTemporaryQuota;\n\n  if (free_space < QuotaManager::kTemporaryStorageQuotaDefaultSize * 20)\n    return QuotaManager::kTemporaryStorageQuotaDefaultSize;\n\n  if (free_space < QuotaManager::kTemporaryStorageQuotaMaxSize * 20)\n    return free_space / 20;\n\n  return QuotaManager::kTemporaryStorageQuotaMaxSize;\n}\n", "func_hash": 242328016993890528781162060067419095694, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 221649, "project": "hermes", "commit_id": "55e1b2343f4deb1a1b5726cfe1e23b2068217ff2", "project_url": "https://github.com/facebook/hermes", "commit_url": "https://github.com/facebook/hermes/commit/55e1b2343f4deb1a1b5726cfe1e23b2068217ff2", "commit_message": "Handle typeof applied to empty in InstSimplify\n\nSummary:\nDo not simplify `typeof` if it is applied to an invalid type. This\nhandles a case like the one in the added test, where `typeof` is called\non a literal empty in unreachable code.\n\nReviewed By: kodafb\n\nDifferential Revision: D31000173\n\nfbshipit-source-id: 2d7f69cbcc9c1bb0a916585c07171089444c85dc", "target": 0, "func": "LiteralNumber *hermes::evalToNumber(IRBuilder &builder, Literal *operand) {\n  if (auto *numLiteral = llvh::dyn_cast<LiteralNumber>(operand)) {\n    return numLiteral;\n  }\n  if (auto *boolLiteral = llvh::dyn_cast<LiteralBool>(operand)) {\n    return builder.getLiteralNumber(boolLiteral->getValue());\n  }\n  if (operand->getType().isUndefinedType()) {\n    return builder.getLiteralNaN();\n  }\n  if (operand->getType().isNullType()) {\n    return builder.getLiteralPositiveZero();\n  }\n  return nullptr;\n}", "func_hash": 9325140578910978613803377013875964493, "file_name": "IREval.cpp", "file_hash": 42961914778696217563735135747458181955, "cwe": ["CWE-843"], "cve": "CVE-2021-24045", "cve_desc": "A type confusion vulnerability could be triggered when resolving the \"typeof\" unary operator in Facebook Hermes prior to v0.10.0. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-24045"}
{"idx": 213589, "project": "w3m", "commit_id": "67be73b03a5ad581e331ec97cb275cd8a52719ed", "project_url": "https://github.com/tats/w3m", "commit_url": "https://github.com/tats/w3m/commit/67be73b03a5ad581e331ec97cb275cd8a52719ed", "commit_message": "Prevent segfault with incorrect button type\n\nBug-Debian: https://github.com/tats/w3m/issues/17", "target": 1, "func": "process_button(struct parsed_tag *tag)\n{\n    Str tmp = NULL;\n    char *p, *q, *r, *qq = \"\";\n    int qlen, v;\n\n    if (cur_form_id < 0) {\n       char *s = \"<form_int method=internal action=none>\";\n       tmp = process_form(parse_tag(&s, TRUE));\n    }\n    if (tmp == NULL)\n       tmp = Strnew();\n\n    p = \"submit\";\n    parsedtag_get_value(tag, ATTR_TYPE, &p);\n    q = NULL;\n    parsedtag_get_value(tag, ATTR_VALUE, &q);\n    r = \"\";\n    parsedtag_get_value(tag, ATTR_NAME, &r);\n\n    v = formtype(p);\n    if (v == FORM_UNKNOWN)\n       return NULL;\n\n    if (!q) {\n       switch (v) {\n       case FORM_INPUT_SUBMIT:\n       case FORM_INPUT_BUTTON:\n           q = \"SUBMIT\";\n           break;\n       case FORM_INPUT_RESET:\n           q = \"RESET\";\n           break;\n       }\n    }\n    if (q) {\n       qq = html_quote(q);\n       qlen = strlen(q);\n    }\n\n    /*    Strcat_charp(tmp, \"<pre_int>\"); */\n    Strcat(tmp, Sprintf(\"<input_alt hseq=\\\"%d\\\" fid=\\\"%d\\\" type=\\\"%s\\\" \"\n                       \"name=\\\"%s\\\" value=\\\"%s\\\">\",\n                       cur_hseq++, cur_form_id, html_quote(p),\n                       html_quote(r), qq));\n    return tmp;\n}", "func_hash": 259898695462701572741943838710568391577, "file_name": "file.c", "file_hash": 127514684749705340248688161018325961143, "cwe": ["CWE-119"], "cve": "CVE-2016-9437", "cve_desc": "An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) and possibly memory corruption via a crafted HTML page.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9437"}
{"idx": 90746, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  void CallCallbacksAndClear(\n      CallbackList* callbacks, QuotaStatusCode status,\n      int64 usage, int64 quota) {\n    for (CallbackList::iterator iter = callbacks->begin();\n         iter != callbacks->end(); ++iter) {\n      (*iter)->Run(status, usage, quota);\n      delete *iter;\n    }\n    callbacks->clear();\n  }\n", "func_hash": 327582708117730851529206974492433349378, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90820, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  int64 global_usage() const { return global_usage_; }\n", "func_hash": 238374986974547946279041141065005596413, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 208140, "project": "util-linux", "commit_id": "5ebbc3865d1e53ef42e5f121c41faab23dd59075", "project_url": "https://github.com/karelzak/util-linux", "commit_url": "http://git.kernel.org/?p=utils/util-linux/util-linux.git;a=commit;h=5ebbc3865d1e53ef42e5f121c41faab23dd59075", "commit_message": "mount: sanitize paths from non-root users\n\n $ mount /root/.ssh/../../dev/sda2\n mount: only root can mount UUID=17bc65ec-4125-4e7c-8a7d-e2795064c736 on /boot\n\nthis is too promiscuous. It seems better to ignore on command line\nspecified paths which are not resolve-able for non-root users.\n\nFixed version:\n\n  $ mount /root/.ssh/../../dev/sda2\n  mount: /root/.ssh/../../dev/sda2: Permission denied\n\n  $ mount /dev/sda2\n  mount: only root can mount UUID=17bc65ec-4125-4e7c-8a7d-e2795064c736 on /boot\n\nNote that this bug has no relation to mount(2) permissions evaluation\nin suid mode. The way how non-root user specifies paths on command\nline is completely irrelevant for comparison with fstab entries.\n\nSigned-off-by: Karel Zak <kzak@redhat.com>", "target": 1, "func": "int main(int argc, char **argv)\n{\n\tint c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0;\n\tstruct libmnt_context *cxt;\n\tstruct libmnt_table *fstab = NULL;\n\tchar *srcbuf = NULL;\n\tchar *types = NULL;\n\tunsigned long oper = 0;\n\n\tenum {\n\t\tMOUNT_OPT_SHARED = CHAR_MAX + 1,\n\t\tMOUNT_OPT_SLAVE,\n\t\tMOUNT_OPT_PRIVATE,\n\t\tMOUNT_OPT_UNBINDABLE,\n\t\tMOUNT_OPT_RSHARED,\n\t\tMOUNT_OPT_RSLAVE,\n\t\tMOUNT_OPT_RPRIVATE,\n\t\tMOUNT_OPT_RUNBINDABLE,\n\t\tMOUNT_OPT_TARGET,\n\t\tMOUNT_OPT_SOURCE\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"fake\", 0, 0, 'f' },\n\t\t{ \"fstab\", 1, 0, 'T' },\n\t\t{ \"fork\", 0, 0, 'F' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"ro\", 0, 0, 'r' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ \"read-write\", 0, 0, 'w' },\n\t\t{ \"rw\", 0, 0, 'w' },\n\t\t{ \"options\", 1, 0, 'o' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"pass-fd\", 1, 0, 'p' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"uuid\", 1, 0, 'U' },\n\t\t{ \"label\", 1, 0, 'L'},\n\t\t{ \"bind\", 0, 0, 'B' },\n\t\t{ \"move\", 0, 0, 'M' },\n\t\t{ \"rbind\", 0, 0, 'R' },\n\t\t{ \"make-shared\", 0, 0, MOUNT_OPT_SHARED },\n\t\t{ \"make-slave\", 0, 0, MOUNT_OPT_SLAVE },\n\t\t{ \"make-private\", 0, 0, MOUNT_OPT_PRIVATE },\n\t\t{ \"make-unbindable\", 0, 0, MOUNT_OPT_UNBINDABLE },\n\t\t{ \"make-rshared\", 0, 0, MOUNT_OPT_RSHARED },\n\t\t{ \"make-rslave\", 0, 0, MOUNT_OPT_RSLAVE },\n\t\t{ \"make-rprivate\", 0, 0, MOUNT_OPT_RPRIVATE },\n\t\t{ \"make-runbindable\", 0, 0, MOUNT_OPT_RUNBINDABLE },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"show-labels\", 0, 0, 'l' },\n\t\t{ \"target\", 1, 0, MOUNT_OPT_TARGET },\n\t\t{ \"source\", 1, 0, MOUNT_OPT_SOURCE },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {       /* rows and cols in in ASCII order */\n\t\t{ 'B','M','R',\t\t\t/* bind,move,rbind */\n\t\t   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,\n\t\t   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,\n\t\t   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,\n\t\t   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },\n\n\t\t{ 'L','U', MOUNT_OPT_SOURCE },\t/* label,uuid,source */\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\n\twhile ((c = getopt_long(argc, argv, \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\n\t\t/* only few options are allowed for non-root users */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    !strchr(\"hlLUVvpris\", c) &&\n\t\t    c != MOUNT_OPT_TARGET &&\n\t\t    c != MOUNT_OPT_SOURCE)\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tmnt_context_enable_fork(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (mnt_context_append_options(cxt, \"ro\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (mnt_context_append_options(cxt, \"rw\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (mnt_context_append_options(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 'p':\n                        warnx(_(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\txasprintf(&srcbuf, \"LABEL=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\txasprintf(&srcbuf, \"UUID=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tshow_labels = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tfstab = append_fstab(cxt, fstab, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmnt_context_enable_sloppy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toper |= MS_BIND;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\toper |= MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\toper |= (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SHARED:\n\t\t\toper |= MS_SHARED;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SLAVE:\n\t\t\toper |= MS_SLAVE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_PRIVATE:\n\t\t\toper |= MS_PRIVATE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_UNBINDABLE:\n\t\t\toper |= MS_UNBINDABLE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSHARED:\n\t\t\toper |= (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSLAVE:\n\t\t\toper |= (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RPRIVATE:\n\t\t\toper |= (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RUNBINDABLE:\n\t\t\toper |= (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_TARGET:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_target(cxt, optarg);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SOURCE:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (fstab && !mnt_context_is_nocanonicalize(cxt)) {\n\t\t/*\n\t\t * We have external (context independent) fstab instance, let's\n\t\t * make a connection between the fstab and the canonicalization\n\t\t * cache.\n\t\t */\n\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\tmnt_table_set_cache(fstab, cache);\n\t}\n\n\tif (!mnt_context_get_source(cxt) &&\n\t    !mnt_context_get_target(cxt) &&\n\t    !argc &&\n\t    !all) {\n\t\tif (oper)\n\t\t\tusage(stderr);\n\t\tprint_all(cxt, types, show_labels);\n\t\tgoto done;\n\t}\n\n\tif (oper && (types || all || mnt_context_get_source(cxt)))\n\t\tusage(stderr);\n\n\tif (types && (all || strchr(types, ',') ||\n\t\t\t     strncmp(types, \"no\", 2) == 0))\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\telse if (types)\n\t\tmnt_context_set_fstype(cxt, types);\n\n\tif (all) {\n\t\t/*\n\t\t * A) Mount all\n\t\t */\n\t\trc = mount_all(cxt);\n\t\tgoto done;\n\n\t} else if (argc == 0 && (mnt_context_get_source(cxt) ||\n\t\t\t\t mnt_context_get_target(cxt))) {\n\t\t/*\n\t\t * B) mount -L|-U|--source|--target\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt) &&\n\t\t    mnt_context_get_target(cxt))\n\t\t\texit_non_root(NULL);\n\n\t} else if (argc == 1) {\n\t\t/*\n\t\t * C) mount [-L|-U|--source] <target>\n\t\t *    mount <source|target>\n\t\t *\n\t\t * non-root may specify source *or* target, but not both\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt))\n\t\t\texit_non_root(NULL);\n\n\t\tmnt_context_set_target(cxt, argv[0]);\n\n\t} else if (argc == 2 && !mnt_context_get_source(cxt)\n\t\t\t     && !mnt_context_get_target(cxt)) {\n\t\t/*\n\t\t * D) mount <source> <target>\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_source(cxt, argv[0]);\n\t\tmnt_context_set_target(cxt, argv[1]);\n\n\t} else\n\t\tusage(stderr);\n\n\tif (oper) {\n\t\t/* MS_PROPAGATION operations, let's set the mount flags */\n\t\tmnt_context_set_mflags(cxt, oper);\n\n\t\t/* For -make* or --bind is fstab unnecessary */\n\t\tmnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB);\n\t}\n\n\trc = mnt_context_mount(cxt);\n\trc = mk_exit_code(cxt, rc);\n\n\tif (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt))\n\t\tsuccess_message(cxt);\ndone:\n\tmnt_free_context(cxt);\n\tmnt_free_table(fstab);\n\treturn rc;\n}", "func_hash": 219498005792940261578066564094421095366, "file_name": "mount.c", "file_hash": 324534442685972817552003935079520935664, "cwe": ["CWE-200"], "cve": "CVE-2013-0157", "cve_desc": "(a) mount and (b) umount in util-linux 2.14.1, 2.17.2, and probably other versions allow local users to determine the existence of restricted directories by (1) using the --guess-fstype command-line option or (2) attempting to mount a non-existent device, which generates different error messages depending on whether the directory exists.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-0157"}
{"idx": 90117, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  void ClearNetworks() {\n    if (ethernet_)\n      delete ethernet_;\n    ethernet_ = NULL;\n    wifi_ = NULL;\n    cellular_ = NULL;\n    STLDeleteElements(&wifi_networks_);\n    wifi_networks_.clear();\n    STLDeleteElements(&cellular_networks_);\n    cellular_networks_.clear();\n    STLDeleteElements(&remembered_wifi_networks_);\n    remembered_wifi_networks_.clear();\n  }\n", "func_hash": 100738864938815938949255162727268172419, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90797, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "void QuotaManagerProxy::NotifyStorageAccessed(\n    QuotaClient::ID client_id,\n    const GURL& origin,\n    StorageType type) {\n  if (!io_thread_->BelongsToCurrentThread()) {\n    io_thread_->PostTask(FROM_HERE, NewRunnableMethod(\n        this, &QuotaManagerProxy::NotifyStorageAccessed,\n        client_id, origin, type));\n    return;\n  }\n  if (manager_)\n    manager_->NotifyStorageAccessed(client_id, origin, type);\n}\n", "func_hash": 2415655322353766858093454752961201494, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 219955, "project": "glewlwyd", "commit_id": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "project_url": "https://github.com/babelouest/glewlwyd", "commit_url": "https://github.com/babelouest/glewlwyd/commit/125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "commit_message": "Fix update session when auth fail", "target": 0, "func": "int callback_glewlwyd_get_client_module (const struct _u_request * request, struct _u_response * response, void * client_data) {\n  struct config_elements * config = (struct config_elements *)client_data;\n  json_t * j_module;\n  \n  j_module = get_client_module(config, u_map_get(request->map_url, \"name\"));\n  if (check_result_value(j_module, G_OK)) {\n    ulfius_set_json_body_response(response, 200, json_object_get(j_module, \"module\"));\n  } else if (check_result_value(j_module, G_ERROR_NOT_FOUND)) {\n    response->status = 404;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_get_client_module - Error get_client_module\");\n    response->status = 500;\n  }\n  json_decref(j_module);\n  return U_CALLBACK_CONTINUE;\n}", "func_hash": 213080039774229792350639046107958605727, "file_name": "webservice.c", "file_hash": 287798817606377336444620654835011177393, "cwe": ["CWE-287"], "cve": "CVE-2021-45379", "cve_desc": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-45379"}
{"idx": 221171, "project": "gpac", "commit_id": "a69b567b8c95c72f9560c873c5ab348be058f340", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340", "commit_message": "fixed #1895", "target": 0, "func": "GF_AV1Config *gf_odf_av1_cfg_new()\n{\n\tGF_AV1Config *cfg;\n\tGF_SAFEALLOC(cfg, GF_AV1Config);\n\tif (!cfg) return NULL;\n\tcfg->marker = 1;\n\tcfg->version = 1;\n\tcfg->initial_presentation_delay_minus_one = 0;\n\tcfg->obu_array = gf_list_new();\n\treturn cfg;\n}", "func_hash": 164966713825404820787007752781795194256, "file_name": "descriptors.c", "file_hash": 86476492964393375980272696403064975409, "cwe": ["CWE-415"], "cve": "CVE-2021-40571", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40571"}
{"idx": 219012, "project": "tensorflow", "commit_id": "240655511cd3e701155f944a972db71b6c0b1bb6", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/240655511cd3e701155f944a972db71b6c0b1bb6", "commit_message": "Eliminate `CHECK`-fails from `IsSimplifiableReshape` via `MakeShape(<invalid shape>)`\n\nPiperOrigin-RevId: 409166738\nChange-Id: I7f0a3590b8acae3f3e3e2fe636e1f5ef285693cf", "target": 0, "func": "Status ConstantFolding::EvaluateNode(const NodeDef& node,\n                                     const TensorVector& inputs,\n                                     TensorVector* output) const {\n  return ::tensorflow::grappler::EvaluateNode(node, inputs, cpu_device_,\n                                              resource_mgr_.get(), output);\n}", "func_hash": 267096748835257907180931680118803292934, "file_name": "constant_folding.cc", "file_hash": 221573695858123615640237954647315751120, "cwe": ["CWE-617"], "cve": "CVE-2022-23581", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The Grappler optimizer in TensorFlow can be used to cause a denial of service by altering a `SavedModel` such that `IsSimplifiableReshape` would trigger `CHECK` failures. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23581"}
{"idx": 221651, "project": "hermes", "commit_id": "55e1b2343f4deb1a1b5726cfe1e23b2068217ff2", "project_url": "https://github.com/facebook/hermes", "commit_url": "https://github.com/facebook/hermes/commit/55e1b2343f4deb1a1b5726cfe1e23b2068217ff2", "commit_message": "Handle typeof applied to empty in InstSimplify\n\nSummary:\nDo not simplify `typeof` if it is applied to an invalid type. This\nhandles a case like the one in the added test, where `typeof` is called\non a literal empty in unreachable code.\n\nReviewed By: kodafb\n\nDifferential Revision: D31000173\n\nfbshipit-source-id: 2d7f69cbcc9c1bb0a916585c07171089444c85dc", "target": 0, "func": "Literal *hermes::evalUnaryOperator(\n    UnaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *operand) {\n  switch (kind) {\n    case UnaryOperatorInst::OpKind::MinusKind:\n      // Negate constant integers.\n      switch (operand->getKind()) {\n        case ValueKind::LiteralNumberKind:\n          if (auto *literalNum = llvh::dyn_cast<LiteralNumber>(operand)) {\n            auto V = -literalNum->getValue();\n            return builder.getLiteralNumber(V);\n          }\n          break;\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralNaN();\n        case ValueKind::LiteralBoolKind:\n          if (evalIsTrue(builder, operand)) {\n            return builder.getLiteralNumber(-1);\n          } else { // evalIsFalse(operand)\n            return builder.getLiteralNegativeZero();\n          }\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralNegativeZero();\n        default:\n          break;\n      }\n      break;\n    case UnaryOperatorInst::OpKind::TypeofKind:\n      switch (operand->getKind()) {\n        case ValueKind::GlobalObjectKind:\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralString(\"object\");\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralString(\"undefined\");\n        case ValueKind::LiteralBoolKind:\n          return builder.getLiteralString(\"boolean\");\n        case ValueKind::LiteralNumberKind:\n          return builder.getLiteralString(\"number\");\n        case ValueKind::LiteralStringKind:\n          return builder.getLiteralString(\"string\");\n        default:\n          break;\n      }\n      break;\n\n    case UnaryOperatorInst::OpKind::BangKind:\n      if (evalIsTrue(builder, operand)) {\n        return builder.getLiteralBool(false);\n      }\n      if (evalIsFalse(builder, operand)) {\n        return builder.getLiteralBool(true);\n      }\n      break;\n\n    case UnaryOperatorInst::OpKind::VoidKind:\n      return builder.getLiteralUndefined();\n\n    default:\n      break;\n  }\n\n  return nullptr;\n}", "func_hash": 123137692006195986808828639392289766950, "file_name": "IREval.cpp", "file_hash": 42961914778696217563735135747458181955, "cwe": ["CWE-843"], "cve": "CVE-2021-24045", "cve_desc": "A type confusion vulnerability could be triggered when resolving the \"typeof\" unary operator in Facebook Hermes prior to v0.10.0. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-24045"}
{"idx": 218753, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    has_merged_image,\n    skip_layers;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  ssize_t\n    i;\n\n  size_t\n    image_list_length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read image header.\n  */\n  image->endian=MSBEndian;\n  count=ReadBlob(image,4,(unsigned char *) psd_info.signature);\n  psd_info.version=ReadBlobMSBShort(image);\n  if ((count != 4) || (LocaleNCompare(psd_info.signature,\"8BPS\",4) != 0) ||\n      ((psd_info.version != 1) && (psd_info.version != 2)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ReadBlob(image,6,psd_info.reserved);\n  psd_info.channels=ReadBlobMSBShort(image);\n  if (psd_info.channels < 1)\n    ThrowReaderException(CorruptImageError,\"MissingImageChannel\");\n  if (psd_info.channels > MaxPSDChannels)\n    ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n  psd_info.rows=ReadBlobMSBLong(image);\n  psd_info.columns=ReadBlobMSBLong(image);\n  if ((psd_info.version == 1) && ((psd_info.rows > 30000) ||\n      (psd_info.columns > 30000)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.depth=ReadBlobMSBShort(image);\n  if ((psd_info.depth != 1) && (psd_info.depth != 8) &&\n      (psd_info.depth != 16) && (psd_info.depth != 32))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.mode=ReadBlobMSBShort(image);\n  if ((psd_info.mode == IndexedMode) && (psd_info.channels > 3))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s\",\n      (double) psd_info.columns,(double) psd_info.rows,(double)\n      psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType)\n      psd_info.mode));\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image.\n  */\n  image->depth=psd_info.depth;\n  image->columns=psd_info.columns;\n  image->rows=psd_info.rows;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  status=ResetImagePixels(image,exception);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  psd_info.min_channels=3;\n  switch (psd_info.mode)\n  {\n    case LabMode:\n    {\n      (void) SetImageColorspace(image,LabColorspace);\n      break;\n    }\n    case CMYKMode:\n    {\n      psd_info.min_channels=4;\n      (void) SetImageColorspace(image,CMYKColorspace);\n      break;\n    }\n    case BitmapMode:\n    case GrayscaleMode:\n    case DuotoneMode:\n    {\n      if (psd_info.depth != 32)\n        {\n          status=AcquireImageColormap(image,MagickMin((size_t)\n            (psd_info.depth < 16 ? 256 : 65536), MaxColormapSize));\n          if (status == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Image colormap allocated\");\n        }\n      psd_info.min_channels=1;\n      (void) SetImageColorspace(image,GRAYColorspace);\n      break;\n    }\n    case IndexedMode:\n    {\n      psd_info.min_channels=1;\n      break;\n    }\n    case MultichannelMode:\n    {\n      if ((psd_info.channels > 0) && (psd_info.channels < 3))\n        {\n          psd_info.min_channels=psd_info.channels;\n          (void) SetImageColorspace(image,GRAYColorspace);\n        }\n      break;\n    }\n  }\n  if (psd_info.channels < psd_info.min_channels)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Read PSD raster colormap only present for indexed and duotone images.\n  */\n  length=ReadBlobMSBLong(image);\n  if ((psd_info.mode == IndexedMode) && (length < 3))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (length != 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading colormap\");\n      if ((psd_info.mode == DuotoneMode) || (psd_info.depth == 32))\n        {\n          /*\n            Duotone image data;  the format of this data is undocumented.\n          */\n          (void) SeekBlob(image,(const MagickOffsetType) length,SEEK_CUR);\n        }\n      else\n        {\n          size_t\n            number_colors;\n\n          /*\n            Read PSD raster colormap.\n          */\n          number_colors=(size_t) length/3;\n          if (number_colors > 65536)\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if (AcquireImageColormap(image,number_colors) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          image->matte=MagickFalse;\n        }\n    }\n  if ((image->depth == 1) && (image->storage_class != PseudoClass))\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n  has_merged_image=MagickTrue;\n  profile=(StringInfo *) NULL;\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      unsigned char\n        *blocks;\n\n      /*\n        Image resources block.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading image resource blocks - %.20g bytes\",(double)\n          ((MagickOffsetType) length));\n      if (length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      blocks=(unsigned char *) AcquireQuantumMemory((size_t) length,\n        sizeof(*blocks));\n      if (blocks == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,(size_t) length,blocks);\n      if ((count != (ssize_t) length) || (length < 4) ||\n          (LocaleNCompare((char *) blocks,\"8BIM\",4) != 0))\n        {\n          blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      profile=ParseImageResourceBlocks(image,blocks,(size_t) length,\n        &has_merged_image);\n      blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n    }\n  /*\n    Layer and mask block.\n  */\n  length=GetPSDSize(&psd_info,image);\n  if (length == 8)\n    {\n      length=ReadBlobMSBLong(image);\n      length=ReadBlobMSBLong(image);\n    }\n  offset=TellBlob(image);\n  skip_layers=MagickFalse;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0) &&\n      (has_merged_image != MagickFalse))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  read composite only\");\n      skip_layers=MagickTrue;\n    }\n  if (length == 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image has no layers\");\n    }\n  else\n    {\n      if (ReadPSDLayersInternal(image,image_info,&psd_info,skip_layers,\n            exception) != MagickTrue)\n        {\n          if (profile != (StringInfo *) NULL)\n            profile=DestroyStringInfo(profile);\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      /*\n         Skip the rest of the layer and mask information.\n      */\n      (void) SeekBlob(image,offset+length,SEEK_SET);\n    }\n  /*\n    If we are only \"pinging\" the image, then we're done - so return.\n  */\n  if (EOFBlob(image) != MagickFalse)\n    {\n      if (profile != (StringInfo *) NULL)\n        profile=DestroyStringInfo(profile);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  if (image_info->ping != MagickFalse)\n    {\n      if (profile != (StringInfo *) NULL)\n        profile=DestroyStringInfo(profile);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  /*\n    Read the precombined layer, present for PSD < 4 compatibility.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  reading the precombined layer\");\n  image_list_length=GetImageListLength(image);\n  if (has_merged_image != MagickFalse || image_list_length == 1)\n    has_merged_image=(MagickBooleanType) ReadPSDMergedImage(image_info,image,\n      &psd_info,exception);\n  if ((has_merged_image == MagickFalse) && (image_list_length == 1) &&\n      (length != 0))\n    {\n      (void) SeekBlob(image,offset,SEEK_SET);\n      status=ReadPSDLayersInternal(image,image_info,&psd_info,MagickFalse,\n        exception);\n      if (status != MagickTrue)\n        {\n          if (profile != (StringInfo *) NULL)\n            profile=DestroyStringInfo(profile);\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      image_list_length=GetImageListLength(image);\n    }\n  if (has_merged_image == MagickFalse)\n    {\n      Image\n        *merged;\n\n      if (image_list_length == 1)\n        {\n          if (profile != (StringInfo *) NULL)\n            profile=DestroyStringInfo(profile);\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        }\n      image->background_color.opacity=TransparentOpacity;\n      (void) SetImageBackgroundColor(image);\n      merged=MergeImageLayers(image,FlattenLayer,exception);\n      if (merged == (Image *) NULL) \n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      ReplaceImageInList(&image,merged);\n    }\n  if (profile != (StringInfo *) NULL)\n    {\n      Image\n        *next;\n\n      next=image;\n      while (next != (Image *) NULL)\n      {\n        (void) SetImageProfile(next,GetStringInfoName(profile),profile);\n        next=next->next;\n      }\n      profile=DestroyStringInfo(profile);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "func_hash": 102419221267203253934283408326696278935, "file_name": "psd.c", "file_hash": 226732625250511916284298083592366716300, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 221664, "project": "e2guardian", "commit_id": "eae46a7e2a57103aadca903c4a24cca94dc502a2", "project_url": "https://github.com/e2guardian/e2guardian", "commit_url": "https://github.com/e2guardian/e2guardian/commit/eae46a7e2a57103aadca903c4a24cca94dc502a2", "commit_message": "Fix bug #707 cert hostnames not being checked\n- only happened when openssl v1.1 is used", "target": 0, "func": "bool Socket::isSsl()\n{\n    return isssl;\n}", "func_hash": 173359593514091613629809414245835944816, "file_name": "Socket.cpp", "file_hash": 316707147744091371767800459911917453562, "cwe": ["CWE-295"], "cve": "CVE-2021-44273", "cve_desc": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-44273"}
{"idx": 175776, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "bool QuotaManager::ResetUsageTracker(StorageType type) {\n  switch (type) {\n    case kStorageTypeTemporary:\n      if (temporary_usage_tracker_->IsWorking())\n        return false;\n      temporary_usage_tracker_.reset(\n          new UsageTracker(clients_, kStorageTypeTemporary,\n                           special_storage_policy_));\n      return true;\n    case kStorageTypePersistent:\n      if (persistent_usage_tracker_->IsWorking())\n        return false;\n      persistent_usage_tracker_.reset(\n          new UsageTracker(clients_, kStorageTypePersistent,\n                           special_storage_policy_));\n      return true;\n    default:\n      NOTREACHED();\n  }\n  return true;\n}\n", "func_hash": 75369376878479949719838004021014322961, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 161841, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "int64 ClientUsageTracker::GetCachedHostUsage(const std::string& host) {\nint64 ClientUsageTracker::GetCachedHostUsage(const std::string& host) const {\n   HostUsageMap::const_iterator found = cached_usage_.find(host);\n   if (found == cached_usage_.end())\n     return 0;\n\n  int64 usage = 0;\n  const UsageMap& map = found->second;\n  for (UsageMap::const_iterator iter = map.begin();\n       iter != map.end(); ++iter) {\n    usage += iter->second;\n  }\n  return usage;\n}\n", "func_hash": 24354693861516917416012794700730845981, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 220409, "project": "mruby", "commit_id": "27d1e0132a0804581dca28df042e7047fd27eaa8", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8", "commit_message": "array.c: fix `mrb_ary_shift_m` initialization bug.\n\nThe `ARY_PTR` and `ARY_LEN` may be modified in `mrb_get_args`.", "target": 0, "func": "mrb_ary_last(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int n, size, alen;\n\n  n = mrb_get_args(mrb, \"|i\", &size);\n  alen = ARY_LEN(a);\n  if (n == 0) {\n    return (alen > 0) ? ARY_PTR(a)[alen - 1]: mrb_nil_value();\n  }\n\n  if (size < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array size\");\n  }\n  if (size > alen) size = alen;\n  if (ARY_SHARED_P(a) || size > ARY_DEFAULT_LEN) {\n    return ary_subseq(mrb, a, alen - size, size);\n  }\n  return mrb_ary_new_from_values(mrb, size, ARY_PTR(a) + alen - size);\n}", "func_hash": 209459313249347007871337441442184245426, "file_name": "array.c", "file_hash": 295526445825727607536544634773604768998, "cwe": ["CWE-476"], "cve": "CVE-2021-4188", "cve_desc": "mruby is vulnerable to NULL Pointer Dereference", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4188"}
{"idx": 139245, "project": "Chrome", "commit_id": "fb83de09f2c986ee91741f3a2776feea0e18e3f6", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/fb83de09f2c986ee91741f3a2776feea0e18e3f6", "commit_message": "None", "target": 0, "func": "void OverlayWindowViews::Show() {\n  views::Widget::Show();\n\n  has_been_shown_ = true;\n}\n", "func_hash": 83032280430612891971786830694025285817, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90866, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  void RegisterClient(MockStorageClient* client) {\n     quota_manager_->proxy()->RegisterClient(client);\n   }\n", "func_hash": 125178269310216615078052591110271826036, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 208505, "project": "tor", "commit_id": "57e35ad3d91724882c345ac709666a551a977f0f", "project_url": "https://github.com/torproject/tor", "commit_url": "https://gitweb.torproject.org/tor.git/commitdiff/57e35ad3d91724882c345ac709666a551a977f0f", "commit_message": "Avoid possible segfault when handling networkstatus vote with bad flavor\n\nFix for 6530; fix on 0.2.2.6-alpha.", "target": 1, "func": "networkstatus_parse_vote_from_string(const char *s, const char **eos_out,\n                                     networkstatus_type_t ns_type)\n{\n  smartlist_t *tokens = smartlist_create();\n  smartlist_t *rs_tokens = NULL, *footer_tokens = NULL;\n  networkstatus_voter_info_t *voter = NULL;\n  networkstatus_t *ns = NULL;\n  digests_t ns_digests;\n  const char *cert, *end_of_header, *end_of_footer, *s_dup = s;\n  directory_token_t *tok;\n  int ok;\n  struct in_addr in;\n  int i, inorder, n_signatures = 0;\n  memarea_t *area = NULL, *rs_area = NULL;\n  consensus_flavor_t flav = FLAV_NS;\n\n  tor_assert(s);\n\n  if (eos_out)\n    *eos_out = NULL;\n\n  if (router_get_networkstatus_v3_hashes(s, &ns_digests)) {\n    log_warn(LD_DIR, \"Unable to compute digest of network-status\");\n    goto err;\n  }\n\n  area = memarea_new();\n  end_of_header = find_start_of_next_routerstatus(s);\n  if (tokenize_string(area, s, end_of_header, tokens,\n                      (ns_type == NS_TYPE_CONSENSUS) ?\n                      networkstatus_consensus_token_table :\n                      networkstatus_token_table, 0)) {\n    log_warn(LD_DIR, \"Error tokenizing network-status vote header\");\n    goto err;\n  }\n\n  ns = tor_malloc_zero(sizeof(networkstatus_t));\n  memcpy(&ns->digests, &ns_digests, sizeof(ns_digests));\n\n  tok = find_by_keyword(tokens, K_NETWORK_STATUS_VERSION);\n  tor_assert(tok);\n  if (tok->n_args > 1) {\n    int flavor = networkstatus_parse_flavor_name(tok->args[1]);\n    if (flavor < 0) {\n      log_warn(LD_DIR, \"Can't parse document with unknown flavor %s\",\n               escaped(tok->args[2]));\n      goto err;\n    }\n    ns->flavor = flav = flavor;\n  }\n  if (flav != FLAV_NS && ns_type != NS_TYPE_CONSENSUS) {\n    log_warn(LD_DIR, \"Flavor found on non-consensus networkstatus.\");\n    goto err;\n  }\n\n  if (ns_type != NS_TYPE_CONSENSUS) {\n    const char *end_of_cert = NULL;\n    if (!(cert = strstr(s, \"\\ndir-key-certificate-version\")))\n      goto err;\n    ++cert;\n    ns->cert = authority_cert_parse_from_string(cert, &end_of_cert);\n    if (!ns->cert || !end_of_cert || end_of_cert > end_of_header)\n      goto err;\n  }\n\n  tok = find_by_keyword(tokens, K_VOTE_STATUS);\n  tor_assert(tok->n_args);\n  if (!strcmp(tok->args[0], \"vote\")) {\n    ns->type = NS_TYPE_VOTE;\n  } else if (!strcmp(tok->args[0], \"consensus\")) {\n    ns->type = NS_TYPE_CONSENSUS;\n  } else if (!strcmp(tok->args[0], \"opinion\")) {\n    ns->type = NS_TYPE_OPINION;\n  } else {\n    log_warn(LD_DIR, \"Unrecognized vote status %s in network-status\",\n             escaped(tok->args[0]));\n    goto err;\n  }\n  if (ns_type != ns->type) {\n    log_warn(LD_DIR, \"Got the wrong kind of v3 networkstatus.\");\n    goto err;\n  }\n\n  if (ns->type == NS_TYPE_VOTE || ns->type == NS_TYPE_OPINION) {\n    tok = find_by_keyword(tokens, K_PUBLISHED);\n    if (parse_iso_time(tok->args[0], &ns->published))\n      goto err;\n\n    ns->supported_methods = smartlist_create();\n    tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHODS);\n    if (tok) {\n      for (i=0; i < tok->n_args; ++i)\n        smartlist_add(ns->supported_methods, tor_strdup(tok->args[i]));\n    } else {\n      smartlist_add(ns->supported_methods, tor_strdup(\"1\"));\n    }\n  } else {\n    tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHOD);\n    if (tok) {\n      ns->consensus_method = (int)tor_parse_long(tok->args[0], 10, 1, INT_MAX,\n                                                 &ok, NULL);\n      if (!ok)\n        goto err;\n    } else {\n      ns->consensus_method = 1;\n    }\n  }\n\n  tok = find_by_keyword(tokens, K_VALID_AFTER);\n  if (parse_iso_time(tok->args[0], &ns->valid_after))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_FRESH_UNTIL);\n  if (parse_iso_time(tok->args[0], &ns->fresh_until))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_VALID_UNTIL);\n  if (parse_iso_time(tok->args[0], &ns->valid_until))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_VOTING_DELAY);\n  tor_assert(tok->n_args >= 2);\n  ns->vote_seconds =\n    (int) tor_parse_long(tok->args[0], 10, 0, INT_MAX, &ok, NULL);\n  if (!ok)\n    goto err;\n  ns->dist_seconds =\n    (int) tor_parse_long(tok->args[1], 10, 0, INT_MAX, &ok, NULL);\n  if (!ok)\n    goto err;\n  if (ns->valid_after + MIN_VOTE_INTERVAL > ns->fresh_until) {\n    log_warn(LD_DIR, \"Vote/consensus freshness interval is too short\");\n    goto err;\n  }\n  if (ns->valid_after + MIN_VOTE_INTERVAL*2 > ns->valid_until) {\n    log_warn(LD_DIR, \"Vote/consensus liveness interval is too short\");\n    goto err;\n  }\n  if (ns->vote_seconds < MIN_VOTE_SECONDS) {\n    log_warn(LD_DIR, \"Vote seconds is too short\");\n    goto err;\n  }\n  if (ns->dist_seconds < MIN_DIST_SECONDS) {\n    log_warn(LD_DIR, \"Dist seconds is too short\");\n    goto err;\n  }\n\n  if ((tok = find_opt_by_keyword(tokens, K_CLIENT_VERSIONS))) {\n    ns->client_versions = tor_strdup(tok->args[0]);\n  }\n  if ((tok = find_opt_by_keyword(tokens, K_SERVER_VERSIONS))) {\n    ns->server_versions = tor_strdup(tok->args[0]);\n  }\n\n  tok = find_by_keyword(tokens, K_KNOWN_FLAGS);\n  ns->known_flags = smartlist_create();\n  inorder = 1;\n  for (i = 0; i < tok->n_args; ++i) {\n    smartlist_add(ns->known_flags, tor_strdup(tok->args[i]));\n    if (i>0 && strcmp(tok->args[i-1], tok->args[i])>= 0) {\n      log_warn(LD_DIR, \"%s >= %s\", tok->args[i-1], tok->args[i]);\n      inorder = 0;\n    }\n  }\n  if (!inorder) {\n    log_warn(LD_DIR, \"known-flags not in order\");\n    goto err;\n  }\n\n  tok = find_opt_by_keyword(tokens, K_PARAMS);\n  if (tok) {\n    inorder = 1;\n    ns->net_params = smartlist_create();\n    for (i = 0; i < tok->n_args; ++i) {\n      int ok=0;\n      char *eq = strchr(tok->args[i], '=');\n      if (!eq) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n      if (!ok) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      if (i > 0 && strcmp(tok->args[i-1], tok->args[i]) >= 0) {\n        log_warn(LD_DIR, \"%s >= %s\", tok->args[i-1], tok->args[i]);\n        inorder = 0;\n      }\n      smartlist_add(ns->net_params, tor_strdup(tok->args[i]));\n    }\n    if (!inorder) {\n      log_warn(LD_DIR, \"params not in order\");\n      goto err;\n    }\n  }\n\n  ns->voters = smartlist_create();\n\n  SMARTLIST_FOREACH_BEGIN(tokens, directory_token_t *, _tok) {\n    tok = _tok;\n    if (tok->tp == K_DIR_SOURCE) {\n      tor_assert(tok->n_args >= 6);\n\n      if (voter)\n        smartlist_add(ns->voters, voter);\n      voter = tor_malloc_zero(sizeof(networkstatus_voter_info_t));\n      voter->sigs = smartlist_create();\n      if (ns->type != NS_TYPE_CONSENSUS)\n        memcpy(voter->vote_digest, ns_digests.d[DIGEST_SHA1], DIGEST_LEN);\n\n      voter->nickname = tor_strdup(tok->args[0]);\n      if (strlen(tok->args[1]) != HEX_DIGEST_LEN ||\n          base16_decode(voter->identity_digest, sizeof(voter->identity_digest),\n                        tok->args[1], HEX_DIGEST_LEN) < 0) {\n        log_warn(LD_DIR, \"Error decoding identity digest %s in \"\n                 \"network-status vote.\", escaped(tok->args[1]));\n        goto err;\n      }\n      if (ns->type != NS_TYPE_CONSENSUS &&\n          tor_memneq(ns->cert->cache_info.identity_digest,\n                 voter->identity_digest, DIGEST_LEN)) {\n        log_warn(LD_DIR,\"Mismatch between identities in certificate and vote\");\n        goto err;\n      }\n      voter->address = tor_strdup(tok->args[2]);\n      if (!tor_inet_aton(tok->args[3], &in)) {\n        log_warn(LD_DIR, \"Error decoding IP address %s in network-status.\",\n                 escaped(tok->args[3]));\n        goto err;\n      }\n      voter->addr = ntohl(in.s_addr);\n      voter->dir_port = (uint16_t)\n        tor_parse_long(tok->args[4], 10, 0, 65535, &ok, NULL);\n      if (!ok)\n        goto err;\n      voter->or_port = (uint16_t)\n        tor_parse_long(tok->args[5], 10, 0, 65535, &ok, NULL);\n      if (!ok)\n        goto err;\n    } else if (tok->tp == K_CONTACT) {\n      if (!voter || voter->contact) {\n        log_warn(LD_DIR, \"contact element is out of place.\");\n        goto err;\n      }\n      voter->contact = tor_strdup(tok->args[0]);\n    } else if (tok->tp == K_VOTE_DIGEST) {\n      tor_assert(ns->type == NS_TYPE_CONSENSUS);\n      tor_assert(tok->n_args >= 1);\n      if (!voter || ! tor_digest_is_zero(voter->vote_digest)) {\n        log_warn(LD_DIR, \"vote-digest element is out of place.\");\n        goto err;\n      }\n      if (strlen(tok->args[0]) != HEX_DIGEST_LEN ||\n        base16_decode(voter->vote_digest, sizeof(voter->vote_digest),\n                      tok->args[0], HEX_DIGEST_LEN) < 0) {\n        log_warn(LD_DIR, \"Error decoding vote digest %s in \"\n                 \"network-status consensus.\", escaped(tok->args[0]));\n        goto err;\n      }\n    }\n  } SMARTLIST_FOREACH_END(_tok);\n  if (voter) {\n    smartlist_add(ns->voters, voter);\n    voter = NULL;\n  }\n  if (smartlist_len(ns->voters) == 0) {\n    log_warn(LD_DIR, \"Missing dir-source elements in a vote networkstatus.\");\n    goto err;\n  } else if (ns->type != NS_TYPE_CONSENSUS && smartlist_len(ns->voters) != 1) {\n    log_warn(LD_DIR, \"Too many dir-source elements in a vote networkstatus.\");\n    goto err;\n  }\n\n  if (ns->type != NS_TYPE_CONSENSUS &&\n      (tok = find_opt_by_keyword(tokens, K_LEGACY_DIR_KEY))) {\n    int bad = 1;\n    if (strlen(tok->args[0]) == HEX_DIGEST_LEN) {\n      networkstatus_voter_info_t *voter = smartlist_get(ns->voters, 0);\n      if (base16_decode(voter->legacy_id_digest, DIGEST_LEN,\n                        tok->args[0], HEX_DIGEST_LEN)<0)\n        bad = 1;\n      else\n        bad = 0;\n    }\n    if (bad) {\n      log_warn(LD_DIR, \"Invalid legacy key digest %s on vote.\",\n               escaped(tok->args[0]));\n    }\n  }\n\n  /* Parse routerstatus lines. */\n  rs_tokens = smartlist_create();\n  rs_area = memarea_new();\n  s = end_of_header;\n  ns->routerstatus_list = smartlist_create();\n\n  while (!strcmpstart(s, \"r \")) {\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      vote_routerstatus_t *rs = tor_malloc_zero(sizeof(vote_routerstatus_t));\n      if (routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens, ns,\n                                               rs, 0, 0))\n        smartlist_add(ns->routerstatus_list, rs);\n      else {\n        tor_free(rs->version);\n        tor_free(rs);\n      }\n    } else {\n      routerstatus_t *rs;\n      if ((rs = routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens,\n                                                     NULL, NULL,\n                                                     ns->consensus_method,\n                                                     flav)))\n        smartlist_add(ns->routerstatus_list, rs);\n    }\n  }\n  for (i = 1; i < smartlist_len(ns->routerstatus_list); ++i) {\n    routerstatus_t *rs1, *rs2;\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      vote_routerstatus_t *a = smartlist_get(ns->routerstatus_list, i-1);\n      vote_routerstatus_t *b = smartlist_get(ns->routerstatus_list, i);\n      rs1 = &a->status; rs2 = &b->status;\n    } else {\n      rs1 = smartlist_get(ns->routerstatus_list, i-1);\n      rs2 = smartlist_get(ns->routerstatus_list, i);\n    }\n    if (fast_memcmp(rs1->identity_digest, rs2->identity_digest, DIGEST_LEN)\n        >= 0) {\n      log_warn(LD_DIR, \"Vote networkstatus entries not sorted by identity \"\n               \"digest\");\n      goto err;\n    }\n  }\n\n  /* Parse footer; check signature. */\n  footer_tokens = smartlist_create();\n  if ((end_of_footer = strstr(s, \"\\nnetwork-status-version \")))\n    ++end_of_footer;\n  else\n    end_of_footer = s + strlen(s);\n  if (tokenize_string(area,s, end_of_footer, footer_tokens,\n                      networkstatus_vote_footer_token_table, 0)) {\n    log_warn(LD_DIR, \"Error tokenizing network-status vote footer.\");\n    goto err;\n  }\n\n  {\n    int found_sig = 0;\n    SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {\n      tok = _tok;\n      if (tok->tp == K_DIRECTORY_SIGNATURE)\n        found_sig = 1;\n      else if (found_sig) {\n        log_warn(LD_DIR, \"Extraneous token after first directory-signature\");\n        goto err;\n      }\n    } SMARTLIST_FOREACH_END(_tok);\n  }\n\n  if ((tok = find_opt_by_keyword(footer_tokens, K_DIRECTORY_FOOTER))) {\n    if (tok != smartlist_get(footer_tokens, 0)) {\n      log_warn(LD_DIR, \"Misplaced directory-footer token\");\n      goto err;\n    }\n  }\n\n  tok = find_opt_by_keyword(footer_tokens, K_BW_WEIGHTS);\n  if (tok) {\n    ns->weight_params = smartlist_create();\n    for (i = 0; i < tok->n_args; ++i) {\n      int ok=0;\n      char *eq = strchr(tok->args[i], '=');\n      if (!eq) {\n        log_warn(LD_DIR, \"Bad element '%s' in weight params\",\n                 escaped(tok->args[i]));\n        goto err;\n      }\n      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n      if (!ok) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      smartlist_add(ns->weight_params, tor_strdup(tok->args[i]));\n    }\n  }\n\n  SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {\n    char declared_identity[DIGEST_LEN];\n    networkstatus_voter_info_t *v;\n    document_signature_t *sig;\n    const char *id_hexdigest = NULL;\n    const char *sk_hexdigest = NULL;\n    digest_algorithm_t alg = DIGEST_SHA1;\n    tok = _tok;\n    if (tok->tp != K_DIRECTORY_SIGNATURE)\n      continue;\n    tor_assert(tok->n_args >= 2);\n    if (tok->n_args == 2) {\n      id_hexdigest = tok->args[0];\n      sk_hexdigest = tok->args[1];\n    } else {\n      const char *algname = tok->args[0];\n      int a;\n      id_hexdigest = tok->args[1];\n      sk_hexdigest = tok->args[2];\n      a = crypto_digest_algorithm_parse_name(algname);\n      if (a<0) {\n        log_warn(LD_DIR, \"Unknown digest algorithm %s; skipping\",\n                 escaped(algname));\n        continue;\n      }\n      alg = a;\n    }\n\n    if (!tok->object_type ||\n        strcmp(tok->object_type, \"SIGNATURE\") ||\n        tok->object_size < 128 || tok->object_size > 512) {\n      log_warn(LD_DIR, \"Bad object type or length on directory-signature\");\n      goto err;\n    }\n\n    if (strlen(id_hexdigest) != HEX_DIGEST_LEN ||\n        base16_decode(declared_identity, sizeof(declared_identity),\n                      id_hexdigest, HEX_DIGEST_LEN) < 0) {\n      log_warn(LD_DIR, \"Error decoding declared identity %s in \"\n               \"network-status vote.\", escaped(id_hexdigest));\n      goto err;\n    }\n    if (!(v = networkstatus_get_voter_by_id(ns, declared_identity))) {\n      log_warn(LD_DIR, \"ID on signature on network-status vote does not match \"\n               \"any declared directory source.\");\n      goto err;\n    }\n    sig = tor_malloc_zero(sizeof(document_signature_t));\n    memcpy(sig->identity_digest, v->identity_digest, DIGEST_LEN);\n    sig->alg = alg;\n    if (strlen(sk_hexdigest) != HEX_DIGEST_LEN ||\n        base16_decode(sig->signing_key_digest, sizeof(sig->signing_key_digest),\n                      sk_hexdigest, HEX_DIGEST_LEN) < 0) {\n      log_warn(LD_DIR, \"Error decoding declared signing key digest %s in \"\n               \"network-status vote.\", escaped(sk_hexdigest));\n      tor_free(sig);\n      goto err;\n    }\n\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      if (tor_memneq(declared_identity, ns->cert->cache_info.identity_digest,\n                 DIGEST_LEN)) {\n        log_warn(LD_DIR, \"Digest mismatch between declared and actual on \"\n                 \"network-status vote.\");\n        tor_free(sig);\n        goto err;\n      }\n    }\n\n    if (voter_get_sig_by_algorithm(v, sig->alg)) {\n      /* We already parsed a vote with this algorithm from this voter. Use the\n         first one. */\n      log_fn(LOG_PROTOCOL_WARN, LD_DIR, \"We received a networkstatus \"\n             \"that contains two votes from the same voter with the same \"\n             \"algorithm. Ignoring the second vote.\");\n      tor_free(sig);\n      continue;\n    }\n\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      if (check_signature_token(ns_digests.d[DIGEST_SHA1], DIGEST_LEN,\n                                tok, ns->cert->signing_key, 0,\n                                \"network-status vote\")) {\n        tor_free(sig);\n        goto err;\n      }\n      sig->good_signature = 1;\n    } else {\n      if (tok->object_size >= INT_MAX || tok->object_size >= SIZE_T_CEILING) {\n        tor_free(sig);\n        goto err;\n      }\n      sig->signature = tor_memdup(tok->object_body, tok->object_size);\n      sig->signature_len = (int) tok->object_size;\n    }\n    smartlist_add(v->sigs, sig);\n\n    ++n_signatures;\n  } SMARTLIST_FOREACH_END(_tok);\n\n  if (! n_signatures) {\n    log_warn(LD_DIR, \"No signatures on networkstatus vote.\");\n    goto err;\n  } else if (ns->type == NS_TYPE_VOTE && n_signatures != 1) {\n    log_warn(LD_DIR, \"Received more than one signature on a \"\n             \"network-status vote.\");\n    goto err;\n  }\n\n  if (eos_out)\n    *eos_out = end_of_footer;\n\n  goto done;\n err:\n  dump_desc(s_dup, \"v3 networkstatus\");\n  networkstatus_vote_free(ns);\n  ns = NULL;\n done:\n  if (tokens) {\n    SMARTLIST_FOREACH(tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(tokens);\n  }\n  if (voter) {\n    if (voter->sigs) {\n      SMARTLIST_FOREACH(voter->sigs, document_signature_t *, sig,\n                        document_signature_free(sig));\n      smartlist_free(voter->sigs);\n    }\n    tor_free(voter->nickname);\n    tor_free(voter->address);\n    tor_free(voter->contact);\n    tor_free(voter);\n  }\n  if (rs_tokens) {\n    SMARTLIST_FOREACH(rs_tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(rs_tokens);\n  }\n  if (footer_tokens) {\n    SMARTLIST_FOREACH(footer_tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(footer_tokens);\n  }\n  if (area) {\n    DUMP_AREA(area, \"v3 networkstatus\");\n    memarea_drop_all(area);\n  }\n  if (rs_area)\n    memarea_drop_all(rs_area);\n\n  return ns;\n}", "func_hash": 297795787979009632344281497591388902899, "file_name": "routerparse.c", "file_hash": 22420103474128049345359193080521452725, "cwe": ["CWE-399"], "cve": "CVE-2012-3517", "cve_desc": "Use-after-free vulnerability in dns.c in Tor before 0.2.2.38 might allow remote attackers to cause a denial of service (daemon crash) via vectors related to failed DNS requests.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-3517"}
{"idx": 221494, "project": "flatpak", "commit_id": "89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "commit_message": "run: Add cross-references for some other seccomp syscall filters\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "target": 0, "func": "flatpak_run_add_cups_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char * sandbox_server_name = g_strdup (\"/var/run/cups/cups.sock\");\n  g_autofree char * cups_server_name = flatpak_run_get_cups_server_name ();\n\n  if (!g_file_test (cups_server_name, G_FILE_TEST_EXISTS))\n    {\n      g_debug (\"Could not find CUPS server\");\n      return;\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", cups_server_name, sandbox_server_name,\n                          NULL);\n}", "func_hash": 210000859972225443790418000862057663701, "file_name": "flatpak-run.c", "file_hash": 32398709380082441128978861691951488575, "cwe": ["CWE-20"], "cve": "CVE-2021-41133", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41133"}
{"idx": 221124, "project": "gpac", "commit_id": "a69b567b8c95c72f9560c873c5ab348be058f340", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340", "commit_message": "fixed #1895", "target": 0, "func": "GF_Err gf_odf_av1_cfg_write(GF_AV1Config *cfg, u8 **outData, u32 *outSize) {\n\tGF_Err e;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t*outSize = 0;\n\t*outData = NULL;\n\te = gf_odf_av1_cfg_write_bs(cfg, bs);\n\tif (e == GF_OK)\n\t\tgf_bs_get_content(bs, outData, outSize);\n\n\tgf_bs_del(bs);\n\treturn e;\n}", "func_hash": 70637996745522019393060021113607252962, "file_name": "descriptors.c", "file_hash": 86476492964393375980272696403064975409, "cwe": ["CWE-415"], "cve": "CVE-2021-40571", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40571"}
{"idx": 90757, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "void QuotaManager::DidGetGlobalQuotaForEviction(\n    QuotaStatusCode status,\n    StorageType type,\n    int64 quota) {\n  DCHECK_EQ(type, kStorageTypeTemporary);\n  if (status != kQuotaStatusOk) {\n    eviction_context_.get_usage_and_quota_callback->Run(\n        status, 0, 0, 0, 0);\n    eviction_context_.get_usage_and_quota_callback.reset();\n    return;\n  }\n\n  eviction_context_.quota = quota;\n  GetAvailableSpace(callback_factory_.\n      NewCallback(&QuotaManager::DidGetAvailableSpaceForEviction));\n}\n", "func_hash": 73902260731127566473681993102179495566, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 208987, "project": "MilkyTracker", "commit_id": "7afd55c42ad80d01a339197a2d8b5461d214edaf", "project_url": "https://github.com/milkytracker/MilkyTracker", "commit_url": "https://github.com/milkytracker/MilkyTracker/commit/7afd55c42ad80d01a339197a2d8b5461d214edaf", "commit_message": "Fix use-after-free in PlayerGeneric destructor", "target": 1, "func": "PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\n\tdelete[] audioDriverName;\n\t\n\tdelete listener;\n}", "func_hash": 259737108889128783455987997759442352236, "file_name": "PlayerGeneric.cpp", "file_hash": 257439638235883999405270646373445692221, "cwe": ["CWE-416"], "cve": "CVE-2020-15569", "cve_desc": "PlayerGeneric.cpp in MilkyTracker through 1.02.00 has a use-after-free in the PlayerGeneric destructor.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-15569"}
{"idx": 220934, "project": "gpac", "commit_id": "5f2c2a16d30229b6241f02fa28e3d6b810d64858", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/5f2c2a16d30229b6241f02fa28e3d6b810d64858", "commit_message": "fixed #1905", "target": 0, "func": "static void mpgviddmx_check_dur(GF_Filter *filter, GF_MPGVidDmxCtx *ctx)\n{\n\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tGF_M4VParser *vparser;\n\tGF_M4VDecSpecInfo dsi;\n\tGF_Err e;\n\tu64 duration, cur_dur, rate;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<=0) {\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen(p->value.string, \"rb\");\n\tif (!stream) return;\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\n\tvparser = gf_m4v_parser_bs_new(bs, ctx->is_mpg12);\n\te = gf_m4v_parse_config(vparser, &dsi);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Could not parse video header - duration  not estimated\\n\"));\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tduration = 0;\n\tcur_dur = 0;\n\twhile (gf_bs_available(bs)) {\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 fsize, start;\n\t\tBool is_coded;\n\t\tu64 pos;\n\t\tpos = gf_m4v_get_object_start(vparser);\n\t\te = gf_m4v_parse_frame(vparser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);\n\t\tif (e<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Could not parse video frame\\n\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\tduration += ctx->cur_fps.den;\n\t\tcur_dur += ctx->cur_fps.den;\n\t\t//only index at I-frame start\n\t\tif (pos && (ftype==0) && (cur_dur >= ctx->index * ctx->cur_fps.num) ) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(MPGVidIdx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = pos;\n\t\t\tctx->indexes[ctx->index_size].start_time = (Double) (duration-ctx->cur_fps.den);\n\t\t\tctx->indexes[ctx->index_size].start_time /= ctx->cur_fps.num;\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\t}\n\trate = gf_bs_get_position(bs);\n\tgf_m4v_parser_del(vparser);\n\tgf_fclose(stream);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * ctx->cur_fps.num != duration * ctx->duration.den)) {\n\t\tctx->duration.num = (s32) duration;\n\t\tctx->duration.den = ctx->cur_fps.num;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\tif (duration && !gf_sys_is_test_mode() ) {\n\t\t\trate *= 8 * ctx->duration.den;\n\t\t\trate /= ctx->duration.num;\n\t\t\tctx->bitrate = (u32) rate;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_TRUE ) );\n}", "func_hash": 165788298546200357688215805813438396826, "file_name": "reframe_mpgvid.c", "file_hash": 148306570807841160156662867455353144265, "cwe": ["CWE-476"], "cve": "CVE-2021-40575", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability in the mpgviddmx_process function in reframe_mpgvid.c, which allows attackers to cause a denial of service. This vulnerability is possibly due to an incomplete fix for CVE-2021-40566.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40575"}
{"idx": 90802, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  OriginDataDeleter(QuotaManager* manager,\n                    const GURL& origin,\n                    StorageType type,\n                    StatusCallback* callback)\n      : QuotaTask(manager),\n        origin_(origin),\n        type_(type),\n        error_count_(0),\n        remaining_clients_(-1),\n        callback_(callback),\n        callback_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)) {}\n", "func_hash": 226575916387463698453899571733608421320, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 218825, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static void XDrawTriangleSouth(Display *display,const XWindowInfo *window_info,\n  const XWidgetInfo *triangle_info)\n{\n  int\n    x1,\n    x2,\n    x3,\n    y1,\n    y2,\n    y3;\n\n  unsigned int\n    bevel_width;\n\n  XPoint\n    points[4];\n\n  /*\n    Draw triangle matte.\n  */\n  x1=triangle_info->x;\n  y1=triangle_info->y;\n  x2=triangle_info->x+(triangle_info->width >> 1);\n  y2=triangle_info->y+triangle_info->height;\n  x3=triangle_info->x+triangle_info->width;\n  y3=triangle_info->y;\n  bevel_width=triangle_info->bevel_width;\n  points[0].x=x1;\n  points[0].y=y1;\n  points[1].x=x2;\n  points[1].y=y2;\n  points[2].x=x3;\n  points[2].y=y3;\n  XSetMatteColor(display,window_info,triangle_info->raised);\n  (void) XFillPolygon(display,window_info->id,window_info->widget_context,\n    points,3,Complex,CoordModeOrigin);\n  /*\n    Draw top bevel.\n  */\n  points[0].x=x3;\n  points[0].y=y3;\n  points[1].x=x1;\n  points[1].y=y1;\n  points[2].x=x1-bevel_width;\n  points[2].y=y1-bevel_width;\n  points[3].x=x3+bevel_width;\n  points[3].y=y3-bevel_width;\n  XSetBevelColor(display,window_info,triangle_info->raised);\n  (void) XFillPolygon(display,window_info->id,window_info->widget_context,\n    points,4,Complex,CoordModeOrigin);\n  /*\n    Draw right bevel.\n  */\n  points[0].x=x2;\n  points[0].y=y2;\n  points[1].x=x3+1;\n  points[1].y=y3-bevel_width;\n  points[2].x=x3+bevel_width;\n  points[2].y=y3-bevel_width;\n  points[3].x=x2;\n  points[3].y=y2+bevel_width;\n  XSetBevelColor(display,window_info,!triangle_info->raised);\n  (void) XFillPolygon(display,window_info->id,window_info->widget_context,\n    points,4,Complex,CoordModeOrigin);\n  /*\n    Draw left bevel.\n  */\n  points[0].x=x1;\n  points[0].y=y1;\n  points[1].x=x2;\n  points[1].y=y2;\n  points[2].x=x2;\n  points[2].y=y2+bevel_width;\n  points[3].x=x1-bevel_width;\n  points[3].y=y1-bevel_width;\n  XSetBevelColor(display,window_info,triangle_info->raised);\n  (void) XFillPolygon(display,window_info->id,window_info->widget_context,\n    points,4,Complex,CoordModeOrigin);\n  (void) XSetFillStyle(display,window_info->widget_context,FillSolid);\n}", "func_hash": 49266695975732476901694412230383888353, "file_name": "widget.c", "file_hash": 31318598747823313517201273606802259325, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 212347, "project": "vim", "commit_id": "44a3f3353e0407e9fffee138125a6927d1c9e7e5", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/44a3f3353e0407e9fffee138125a6927d1c9e7e5", "commit_message": "patch 8.2.5063: error for a command may go over the end of IObuff\n\nProblem:    Error for a command may go over the end of IObuff.\nSolution:   Truncate the message.", "target": 1, "func": "append_command(char_u *cmd)\n{\n    char_u *s = cmd;\n    char_u *d;\n\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff + 5 < IOSIZE)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)\n\t    break;\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}", "func_hash": 112905205713691558979209510582932346751, "file_name": "ex_docmd.c", "file_hash": 241657277919881351521474646472905576609, "cwe": ["CWE-787"], "cve": "CVE-2022-2000", "cve_desc": "Out-of-bounds Write in GitHub repository vim/vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2000"}
{"idx": 218760, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "MagickExport void XFontBrowserWidget(Display *display,XWindows *windows,\n  const char *action,char *reply)\n{\n#define BackButtonText  \"Back\"\n#define CancelButtonText  \"Cancel\"\n#define FontnameText  \"Name:\"\n#define FontPatternText  \"Pattern:\"\n#define ResetButtonText  \"Reset\"\n\n  char\n    back_pattern[MaxTextExtent],\n    **fontlist,\n    **listhead,\n    primary_selection[MaxTextExtent],\n    reset_pattern[MaxTextExtent],\n    text[MaxTextExtent];\n\n  int\n    fonts,\n    x,\n    y;\n\n  int\n    i;\n\n  static char\n    glob_pattern[MaxTextExtent] = \"*\";\n\n  static MagickStatusType\n    mask = (MagickStatusType) (CWWidth | CWHeight | CWX | CWY);\n\n  Status\n    status;\n\n  unsigned int\n    height,\n    text_width,\n    visible_fonts,\n    width;\n\n  size_t\n    delay,\n    state;\n\n  XEvent\n    event;\n\n  XFontStruct\n    *font_info;\n\n  XTextProperty\n    window_name;\n\n  XWidgetInfo\n    action_info,\n    back_info,\n    cancel_info,\n    expose_info,\n    list_info,\n    mode_info,\n    north_info,\n    reply_info,\n    reset_info,\n    scroll_info,\n    selection_info,\n    slider_info,\n    south_info,\n    text_info;\n\n  XWindowChanges\n    window_changes;\n\n  /*\n    Get font list and sort in ascending order.\n  */\n  assert(display != (Display *) NULL);\n  assert(windows != (XWindows *) NULL);\n  assert(action != (char *) NULL);\n  assert(reply != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",action);\n  XSetCursorState(display,windows,MagickTrue);\n  XCheckRefreshWindows(display,windows);\n  (void) CopyMagickString(back_pattern,glob_pattern,MaxTextExtent);\n  (void) CopyMagickString(reset_pattern,\"*\",MaxTextExtent);\n  fontlist=XListFonts(display,glob_pattern,32767,&fonts);\n  if (fonts == 0)\n    {\n      /*\n        Pattern failed, obtain all the fonts.\n      */\n      XNoticeWidget(display,windows,\"Unable to obtain fonts names:\",\n        glob_pattern);\n      (void) CopyMagickString(glob_pattern,\"*\",MaxTextExtent);\n      fontlist=XListFonts(display,glob_pattern,32767,&fonts);\n      if (fontlist == (char **) NULL)\n        {\n          XNoticeWidget(display,windows,\"Unable to obtain fonts names:\",\n            glob_pattern);\n          return;\n        }\n    }\n  /*\n    Sort font list in ascending order.\n  */\n  listhead=fontlist;\n  fontlist=(char **) AcquireQuantumMemory((size_t) fonts,sizeof(*fontlist));\n  if (fontlist == (char **) NULL)\n    {\n      XNoticeWidget(display,windows,\"MemoryAllocationFailed\",\n        \"UnableToViewFonts\");\n      return;\n    }\n  for (i=0; i < fonts; i++)\n    fontlist[i]=listhead[i];\n  qsort((void *) fontlist,(size_t) fonts,sizeof(*fontlist),FontCompare);\n  /*\n    Determine Font Browser widget attributes.\n  */\n  font_info=windows->widget.font_info;\n  text_width=0;\n  for (i=0; i < fonts; i++)\n    if (WidgetTextWidth(font_info,fontlist[i]) > text_width)\n      text_width=WidgetTextWidth(font_info,fontlist[i]);\n  width=WidgetTextWidth(font_info,(char *) action);\n  if (WidgetTextWidth(font_info,CancelButtonText) > width)\n    width=WidgetTextWidth(font_info,CancelButtonText);\n  if (WidgetTextWidth(font_info,ResetButtonText) > width)\n    width=WidgetTextWidth(font_info,ResetButtonText);\n  if (WidgetTextWidth(font_info,BackButtonText) > width)\n    width=WidgetTextWidth(font_info,BackButtonText);\n  width+=QuantumMargin;\n  if (WidgetTextWidth(font_info,FontPatternText) > width)\n    width=WidgetTextWidth(font_info,FontPatternText);\n  if (WidgetTextWidth(font_info,FontnameText) > width)\n    width=WidgetTextWidth(font_info,FontnameText);\n  height=(unsigned int) (font_info->ascent+font_info->descent);\n  /*\n    Position Font Browser widget.\n  */\n  windows->widget.width=width+MagickMin((int) text_width,(int) MaxTextWidth)+\n    6*QuantumMargin;\n  windows->widget.min_width=width+MinTextWidth+4*QuantumMargin;\n  if (windows->widget.width < windows->widget.min_width)\n    windows->widget.width=windows->widget.min_width;\n  windows->widget.height=(unsigned int)\n    (((85*height) >> 2)+((13*QuantumMargin) >> 1)+4);\n  windows->widget.min_height=(unsigned int)\n    (((27*height) >> 1)+((13*QuantumMargin) >> 1)+4);\n  if (windows->widget.height < windows->widget.min_height)\n    windows->widget.height=windows->widget.min_height;\n  XConstrainWindowPosition(display,&windows->widget);\n  /*\n    Map Font Browser widget.\n  */\n  (void) CopyMagickString(windows->widget.name,\"Browse and Select a Font\",\n    MaxTextExtent);\n  status=XStringListToTextProperty(&windows->widget.name,1,&window_name);\n  if (status != False)\n    {\n      XSetWMName(display,windows->widget.id,&window_name);\n      XSetWMIconName(display,windows->widget.id,&window_name);\n      (void) XFree((void *) window_name.value);\n    }\n  window_changes.width=(int) windows->widget.width;\n  window_changes.height=(int) windows->widget.height;\n  window_changes.x=windows->widget.x;\n  window_changes.y=windows->widget.y;\n  (void) XReconfigureWMWindow(display,windows->widget.id,\n    windows->widget.screen,mask,&window_changes);\n  (void) XMapRaised(display,windows->widget.id);\n  windows->widget.mapped=MagickFalse;\n  /*\n    Respond to X events.\n  */\n  XGetWidgetInfo((char *) NULL,&slider_info);\n  XGetWidgetInfo((char *) NULL,&north_info);\n  XGetWidgetInfo((char *) NULL,&south_info);\n  XGetWidgetInfo((char *) NULL,&expose_info);\n  XGetWidgetInfo((char *) NULL,&selection_info);\n  visible_fonts=0;\n  delay=SuspendTime << 2;\n  state=UpdateConfigurationState;\n  do\n  {\n    if (state & UpdateConfigurationState)\n      {\n        int\n          id;\n\n        /*\n          Initialize button information.\n        */\n        XGetWidgetInfo(CancelButtonText,&cancel_info);\n        cancel_info.width=width;\n        cancel_info.height=(unsigned int) ((3*height) >> 1);\n        cancel_info.x=(int)\n          (windows->widget.width-cancel_info.width-QuantumMargin-2);\n        cancel_info.y=(int)\n          (windows->widget.height-cancel_info.height-QuantumMargin);\n        XGetWidgetInfo(action,&action_info);\n        action_info.width=width;\n        action_info.height=(unsigned int) ((3*height) >> 1);\n        action_info.x=cancel_info.x-(cancel_info.width+(QuantumMargin >> 1)+\n          (action_info.bevel_width << 1));\n        action_info.y=cancel_info.y;\n        XGetWidgetInfo(BackButtonText,&back_info);\n        back_info.width=width;\n        back_info.height=(unsigned int) ((3*height) >> 1);\n        back_info.x=QuantumMargin;\n        back_info.y=((5*QuantumMargin) >> 1)+height;\n        XGetWidgetInfo(ResetButtonText,&reset_info);\n        reset_info.width=width;\n        reset_info.height=(unsigned int) ((3*height) >> 1);\n        reset_info.x=QuantumMargin;\n        reset_info.y=back_info.y+back_info.height+QuantumMargin;\n        /*\n          Initialize reply information.\n        */\n        XGetWidgetInfo(reply,&reply_info);\n        reply_info.raised=MagickFalse;\n        reply_info.bevel_width--;\n        reply_info.width=windows->widget.width-width-((6*QuantumMargin) >> 1);\n        reply_info.height=height << 1;\n        reply_info.x=(int) (width+(QuantumMargin << 1));\n        reply_info.y=action_info.y-(action_info.height << 1)-QuantumMargin;\n        /*\n          Initialize mode information.\n        */\n        XGetWidgetInfo(reply,&mode_info);\n        mode_info.bevel_width=0;\n        mode_info.width=(unsigned int)\n          (action_info.x-reply_info.x-QuantumMargin);\n        mode_info.height=action_info.height << 1;\n        mode_info.x=reply_info.x;\n        mode_info.y=action_info.y-action_info.height+action_info.bevel_width;\n        /*\n          Initialize scroll information.\n        */\n        XGetWidgetInfo((char *) NULL,&scroll_info);\n        scroll_info.bevel_width--;\n        scroll_info.width=height;\n        scroll_info.height=(unsigned int)\n          (reply_info.y-back_info.y-(QuantumMargin >> 1));\n        scroll_info.x=reply_info.x+(reply_info.width-scroll_info.width);\n        scroll_info.y=back_info.y-reply_info.bevel_width;\n        scroll_info.raised=MagickFalse;\n        scroll_info.trough=MagickTrue;\n        north_info=scroll_info;\n        north_info.raised=MagickTrue;\n        north_info.width-=(north_info.bevel_width << 1);\n        north_info.height=north_info.width-1;\n        north_info.x+=north_info.bevel_width;\n        north_info.y+=north_info.bevel_width;\n        south_info=north_info;\n        south_info.y=scroll_info.y+scroll_info.height-scroll_info.bevel_width-\n          south_info.height;\n        id=slider_info.id;\n        slider_info=north_info;\n        slider_info.id=id;\n        slider_info.width-=2;\n        slider_info.min_y=north_info.y+north_info.height+north_info.bevel_width+\n          slider_info.bevel_width+2;\n        slider_info.height=scroll_info.height-((slider_info.min_y-\n          scroll_info.y+1) << 1)+4;\n        visible_fonts=(unsigned int) (scroll_info.height*\n          PerceptibleReciprocal((double) height+(height >> 3)));\n        if (fonts > (int) visible_fonts)\n          slider_info.height=(visible_fonts*slider_info.height)/fonts;\n        slider_info.max_y=south_info.y-south_info.bevel_width-\n          slider_info.bevel_width-2;\n        slider_info.x=scroll_info.x+slider_info.bevel_width+1;\n        slider_info.y=slider_info.min_y;\n        expose_info=scroll_info;\n        expose_info.y=slider_info.y;\n        /*\n          Initialize list information.\n        */\n        XGetWidgetInfo((char *) NULL,&list_info);\n        list_info.raised=MagickFalse;\n        list_info.bevel_width--;\n        list_info.width=(unsigned int)\n          (scroll_info.x-reply_info.x-(QuantumMargin >> 1));\n        list_info.height=scroll_info.height;\n        list_info.x=reply_info.x;\n        list_info.y=scroll_info.y;\n        if (windows->widget.mapped == MagickFalse)\n          state|=JumpListState;\n        /*\n          Initialize text information.\n        */\n        *text='\\0';\n        XGetWidgetInfo(text,&text_info);\n        text_info.center=MagickFalse;\n        text_info.width=reply_info.width;\n        text_info.height=height;\n        text_info.x=list_info.x-(QuantumMargin >> 1);\n        text_info.y=QuantumMargin;\n        /*\n          Initialize selection information.\n        */\n        XGetWidgetInfo((char *) NULL,&selection_info);\n        selection_info.center=MagickFalse;\n        selection_info.width=list_info.width;\n        selection_info.height=(unsigned int) ((9*height) >> 3);\n        selection_info.x=list_info.x;\n        state&=(~UpdateConfigurationState);\n      }\n    if (state & RedrawWidgetState)\n      {\n        /*\n          Redraw Font Browser window.\n        */\n        x=QuantumMargin;\n        y=text_info.y+((text_info.height-height) >> 1)+font_info->ascent;\n        (void) XDrawString(display,windows->widget.id,\n          windows->widget.annotate_context,x,y,FontPatternText,\n          Extent(FontPatternText));\n        (void) CopyMagickString(text_info.text,glob_pattern,MaxTextExtent);\n        XDrawWidgetText(display,&windows->widget,&text_info);\n        XDrawBeveledButton(display,&windows->widget,&back_info);\n        XDrawBeveledButton(display,&windows->widget,&reset_info);\n        XDrawBeveledMatte(display,&windows->widget,&list_info);\n        XDrawBeveledMatte(display,&windows->widget,&scroll_info);\n        XDrawTriangleNorth(display,&windows->widget,&north_info);\n        XDrawBeveledButton(display,&windows->widget,&slider_info);\n        XDrawTriangleSouth(display,&windows->widget,&south_info);\n        x=QuantumMargin;\n        y=reply_info.y+((reply_info.height-height) >> 1)+font_info->ascent;\n        (void) XDrawString(display,windows->widget.id,\n          windows->widget.annotate_context,x,y,FontnameText,\n          Extent(FontnameText));\n        XDrawBeveledMatte(display,&windows->widget,&reply_info);\n        XDrawMatteText(display,&windows->widget,&reply_info);\n        XDrawBeveledButton(display,&windows->widget,&action_info);\n        XDrawBeveledButton(display,&windows->widget,&cancel_info);\n        XHighlightWidget(display,&windows->widget,BorderOffset,BorderOffset);\n        selection_info.id=(~0);\n        state|=RedrawActionState;\n        state|=RedrawListState;\n        state&=(~RedrawWidgetState);\n      }\n    if (state & UpdateListState)\n      {\n        char\n          **checklist;\n\n        int\n          number_fonts;\n\n        /*\n          Update font list.\n        */\n        checklist=XListFonts(display,glob_pattern,32767,&number_fonts);\n        if (checklist == (char **) NULL)\n          {\n            if ((strchr(glob_pattern,'*') == (char *) NULL) &&\n                (strchr(glob_pattern,'?') == (char *) NULL))\n              {\n                /*\n                  Might be a scaleable font-- exit.\n                */\n                (void) CopyMagickString(reply,glob_pattern,MaxTextExtent);\n                (void) CopyMagickString(glob_pattern,back_pattern,MaxTextExtent);\n                action_info.raised=MagickFalse;\n                XDrawBeveledButton(display,&windows->widget,&action_info);\n                break;\n              }\n            (void) CopyMagickString(glob_pattern,back_pattern,MaxTextExtent);\n            (void) XBell(display,0);\n          }\n        else\n          if (number_fonts == 1)\n            {\n              /*\n                Reply is a single font name-- exit.\n              */\n              (void) CopyMagickString(reply,checklist[0],MaxTextExtent);\n              (void) CopyMagickString(glob_pattern,back_pattern,MaxTextExtent);\n              (void) XFreeFontNames(checklist);\n              action_info.raised=MagickFalse;\n              XDrawBeveledButton(display,&windows->widget,&action_info);\n              break;\n            }\n          else\n            {\n              (void) XFreeFontNames(listhead);\n              fontlist=(char **) RelinquishMagickMemory(fontlist);\n              fontlist=checklist;\n              fonts=number_fonts;\n            }\n        /*\n          Sort font list in ascending order.\n        */\n        listhead=fontlist;\n        fontlist=(char **) AcquireQuantumMemory((size_t) fonts,\n          sizeof(*fontlist));\n        if (fontlist == (char **) NULL)\n          {\n            XNoticeWidget(display,windows,\"MemoryAllocationFailed\",\n              \"UnableToViewFonts\");\n            return;\n          }\n        for (i=0; i < fonts; i++)\n          fontlist[i]=listhead[i];\n        qsort((void *) fontlist,(size_t) fonts,sizeof(*fontlist),FontCompare);\n        slider_info.height=\n          scroll_info.height-((slider_info.min_y-scroll_info.y+1) << 1)+1;\n        if (fonts > (int) visible_fonts)\n          slider_info.height=(visible_fonts*slider_info.height)/fonts;\n        slider_info.max_y=south_info.y-south_info.bevel_width-\n          slider_info.bevel_width-2;\n        slider_info.id=0;\n        slider_info.y=slider_info.min_y;\n        expose_info.y=slider_info.y;\n        selection_info.id=(~0);\n        list_info.id=(~0);\n        state|=RedrawListState;\n        /*\n          Redraw font name & reply.\n        */\n        *reply_info.text='\\0';\n        reply_info.cursor=reply_info.text;\n        (void) CopyMagickString(text_info.text,glob_pattern,MaxTextExtent);\n        XDrawWidgetText(display,&windows->widget,&text_info);\n        XDrawMatteText(display,&windows->widget,&reply_info);\n        XDrawBeveledMatte(display,&windows->widget,&scroll_info);\n        XDrawTriangleNorth(display,&windows->widget,&north_info);\n        XDrawBeveledButton(display,&windows->widget,&slider_info);\n        XDrawTriangleSouth(display,&windows->widget,&south_info);\n        XHighlightWidget(display,&windows->widget,BorderOffset,BorderOffset);\n        state&=(~UpdateListState);\n      }\n    if (state & JumpListState)\n      {\n        /*\n          Jump scroll to match user font.\n        */\n        list_info.id=(~0);\n        for (i=0; i < fonts; i++)\n          if (LocaleCompare(fontlist[i],reply) >= 0)\n            {\n              list_info.id=LocaleCompare(fontlist[i],reply) == 0 ? i : ~0;\n              break;\n            }\n        if ((i < slider_info.id) || (i >= (int) (slider_info.id+visible_fonts)))\n          slider_info.id=i-(visible_fonts >> 1);\n        selection_info.id=(~0);\n        state|=RedrawListState;\n        state&=(~JumpListState);\n      }\n    if (state & RedrawListState)\n      {\n        /*\n          Determine slider id and position.\n        */\n        if (slider_info.id >= (int) (fonts-visible_fonts))\n          slider_info.id=fonts-visible_fonts;\n        if ((slider_info.id < 0) || (fonts <= (int) visible_fonts))\n          slider_info.id=0;\n        slider_info.y=slider_info.min_y;\n        if (fonts > 0)\n          slider_info.y+=\n            slider_info.id*(slider_info.max_y-slider_info.min_y+1)/fonts;\n        if (slider_info.id != selection_info.id)\n          {\n            /*\n              Redraw scroll bar and file names.\n            */\n            selection_info.id=slider_info.id;\n            selection_info.y=list_info.y+(height >> 3)+2;\n            for (i=0; i < (int) visible_fonts; i++)\n            {\n              selection_info.raised=(slider_info.id+i) != list_info.id ?\n                MagickTrue : MagickFalse;\n              selection_info.text=(char *) NULL;\n              if ((slider_info.id+i) < fonts)\n                selection_info.text=fontlist[slider_info.id+i];\n              XDrawWidgetText(display,&windows->widget,&selection_info);\n              selection_info.y+=(int) selection_info.height;\n            }\n            /*\n              Update slider.\n            */\n            if (slider_info.y > expose_info.y)\n              {\n                expose_info.height=(unsigned int) slider_info.y-expose_info.y;\n                expose_info.y=slider_info.y-expose_info.height-\n                  slider_info.bevel_width-1;\n              }\n            else\n              {\n                expose_info.height=(unsigned int) expose_info.y-slider_info.y;\n                expose_info.y=slider_info.y+slider_info.height+\n                  slider_info.bevel_width+1;\n              }\n            XDrawTriangleNorth(display,&windows->widget,&north_info);\n            XDrawMatte(display,&windows->widget,&expose_info);\n            XDrawBeveledButton(display,&windows->widget,&slider_info);\n            XDrawTriangleSouth(display,&windows->widget,&south_info);\n            expose_info.y=slider_info.y;\n          }\n        state&=(~RedrawListState);\n      }\n    if (state & RedrawActionState)\n      {\n        XFontStruct\n          *save_info;\n\n        /*\n          Display the selected font in a drawing area.\n        */\n        save_info=windows->widget.font_info;\n        font_info=XLoadQueryFont(display,reply_info.text);\n        if (font_info != (XFontStruct *) NULL)\n          {\n            windows->widget.font_info=font_info;\n            (void) XSetFont(display,windows->widget.widget_context,\n              font_info->fid);\n          }\n        XDrawBeveledButton(display,&windows->widget,&mode_info);\n        windows->widget.font_info=save_info;\n        if (font_info != (XFontStruct *) NULL)\n          {\n            (void) XSetFont(display,windows->widget.widget_context,\n              windows->widget.font_info->fid);\n            (void) XFreeFont(display,font_info);\n          }\n        XHighlightWidget(display,&windows->widget,BorderOffset,BorderOffset);\n        XDrawMatteText(display,&windows->widget,&reply_info);\n        state&=(~RedrawActionState);\n      }\n    /*\n      Wait for next event.\n    */\n    if (north_info.raised && south_info.raised)\n      (void) XIfEvent(display,&event,XScreenEvent,(char *) windows);\n    else\n      {\n        /*\n          Brief delay before advancing scroll bar.\n        */\n        XDelay(display,delay);\n        delay=SuspendTime;\n        (void) XCheckIfEvent(display,&event,XScreenEvent,(char *) windows);\n        if (north_info.raised == MagickFalse)\n          if (slider_info.id > 0)\n            {\n              /*\n                Move slider up.\n              */\n              slider_info.id--;\n              state|=RedrawListState;\n            }\n        if (south_info.raised == MagickFalse)\n          if (slider_info.id < fonts)\n            {\n              /*\n                Move slider down.\n              */\n              slider_info.id++;\n              state|=RedrawListState;\n            }\n        if (event.type != ButtonRelease)\n          continue;\n      }\n    switch (event.type)\n    {\n      case ButtonPress:\n      {\n        if (MatteIsActive(slider_info,event.xbutton))\n          {\n            /*\n              Track slider.\n            */\n            slider_info.active=MagickTrue;\n            break;\n          }\n        if (MatteIsActive(north_info,event.xbutton))\n          if (slider_info.id > 0)\n            {\n              /*\n                Move slider up.\n              */\n              north_info.raised=MagickFalse;\n              slider_info.id--;\n              state|=RedrawListState;\n              break;\n            }\n        if (MatteIsActive(south_info,event.xbutton))\n          if (slider_info.id < fonts)\n            {\n              /*\n                Move slider down.\n              */\n              south_info.raised=MagickFalse;\n              slider_info.id++;\n              state|=RedrawListState;\n              break;\n            }\n        if (MatteIsActive(scroll_info,event.xbutton))\n          {\n            /*\n              Move slider.\n            */\n            if (event.xbutton.y < slider_info.y)\n              slider_info.id-=(visible_fonts-1);\n            else\n              slider_info.id+=(visible_fonts-1);\n            state|=RedrawListState;\n            break;\n          }\n        if (MatteIsActive(list_info,event.xbutton))\n          {\n            int\n              id;\n\n            /*\n              User pressed list matte.\n            */\n            id=slider_info.id+(event.xbutton.y-(list_info.y+(height >> 1))+1)/\n              selection_info.height;\n            if (id >= (int) fonts)\n              break;\n            (void) CopyMagickString(reply_info.text,fontlist[id],MaxTextExtent);\n            reply_info.highlight=MagickFalse;\n            reply_info.marker=reply_info.text;\n            reply_info.cursor=reply_info.text+Extent(reply_info.text);\n            XDrawMatteText(display,&windows->widget,&reply_info);\n            state|=RedrawActionState;\n            if (id == list_info.id)\n              {\n                (void) CopyMagickString(glob_pattern,reply_info.text,\n                  MaxTextExtent);\n                state|=UpdateListState;\n              }\n            selection_info.id=(~0);\n            list_info.id=id;\n            state|=RedrawListState;\n            break;\n          }\n        if (MatteIsActive(back_info,event.xbutton))\n          {\n            /*\n              User pressed Back button.\n            */\n            back_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&back_info);\n            break;\n          }\n        if (MatteIsActive(reset_info,event.xbutton))\n          {\n            /*\n              User pressed Reset button.\n            */\n            reset_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&reset_info);\n            break;\n          }\n        if (MatteIsActive(action_info,event.xbutton))\n          {\n            /*\n              User pressed action button.\n            */\n            action_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&action_info);\n            break;\n          }\n        if (MatteIsActive(cancel_info,event.xbutton))\n          {\n            /*\n              User pressed Cancel button.\n            */\n            cancel_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&cancel_info);\n            break;\n          }\n        if (MatteIsActive(reply_info,event.xbutton) == MagickFalse)\n          break;\n        if (event.xbutton.button != Button2)\n          {\n            static Time\n              click_time;\n\n            /*\n              Move text cursor to position of button press.\n            */\n            x=event.xbutton.x-reply_info.x-(QuantumMargin >> 2);\n            for (i=1; i <= Extent(reply_info.marker); i++)\n              if (XTextWidth(font_info,reply_info.marker,i) > x)\n                break;\n            reply_info.cursor=reply_info.marker+i-1;\n            if (event.xbutton.time > (click_time+DoubleClick))\n              reply_info.highlight=MagickFalse;\n            else\n              {\n                /*\n                  Become the XA_PRIMARY selection owner.\n                */\n                (void) CopyMagickString(primary_selection,reply_info.text,\n                  MaxTextExtent);\n                (void) XSetSelectionOwner(display,XA_PRIMARY,windows->widget.id,\n                  event.xbutton.time);\n                reply_info.highlight=XGetSelectionOwner(display,XA_PRIMARY) ==\n                  windows->widget.id ? MagickTrue : MagickFalse;\n              }\n            XDrawMatteText(display,&windows->widget,&reply_info);\n            click_time=event.xbutton.time;\n            break;\n          }\n        /*\n          Request primary selection.\n        */\n        (void) XConvertSelection(display,XA_PRIMARY,XA_STRING,XA_STRING,\n          windows->widget.id,event.xbutton.time);\n        break;\n      }\n      case ButtonRelease:\n      {\n        if (windows->widget.mapped == MagickFalse)\n          break;\n        if (north_info.raised == MagickFalse)\n          {\n            /*\n              User released up button.\n            */\n            delay=SuspendTime << 2;\n            north_info.raised=MagickTrue;\n            XDrawTriangleNorth(display,&windows->widget,&north_info);\n          }\n        if (south_info.raised == MagickFalse)\n          {\n            /*\n              User released down button.\n            */\n            delay=SuspendTime << 2;\n            south_info.raised=MagickTrue;\n            XDrawTriangleSouth(display,&windows->widget,&south_info);\n          }\n        if (slider_info.active)\n          {\n            /*\n              Stop tracking slider.\n            */\n            slider_info.active=MagickFalse;\n            break;\n          }\n        if (back_info.raised == MagickFalse)\n          {\n            if (event.xbutton.window == windows->widget.id)\n              if (MatteIsActive(back_info,event.xbutton))\n                {\n                  (void) CopyMagickString(glob_pattern,back_pattern,\n                    MaxTextExtent);\n                  state|=UpdateListState;\n                }\n            back_info.raised=MagickTrue;\n            XDrawBeveledButton(display,&windows->widget,&back_info);\n          }\n        if (reset_info.raised == MagickFalse)\n          {\n            if (event.xbutton.window == windows->widget.id)\n              if (MatteIsActive(reset_info,event.xbutton))\n                {\n                  (void) CopyMagickString(back_pattern,glob_pattern,MaxTextExtent);\n                  (void) CopyMagickString(glob_pattern,reset_pattern,MaxTextExtent);\n                  state|=UpdateListState;\n                }\n            reset_info.raised=MagickTrue;\n            XDrawBeveledButton(display,&windows->widget,&reset_info);\n          }\n        if (action_info.raised == MagickFalse)\n          {\n            if (event.xbutton.window == windows->widget.id)\n              {\n                if (MatteIsActive(action_info,event.xbutton))\n                  {\n                    if (*reply_info.text == '\\0')\n                      (void) XBell(display,0);\n                    else\n                      state|=ExitState;\n                  }\n              }\n            action_info.raised=MagickTrue;\n            XDrawBeveledButton(display,&windows->widget,&action_info);\n          }\n        if (cancel_info.raised == MagickFalse)\n          {\n            if (event.xbutton.window == windows->widget.id)\n              if (MatteIsActive(cancel_info,event.xbutton))\n                {\n                  *reply_info.text='\\0';\n                  state|=ExitState;\n                }\n            cancel_info.raised=MagickTrue;\n            XDrawBeveledButton(display,&windows->widget,&cancel_info);\n          }\n        break;\n      }\n      case ClientMessage:\n      {\n        /*\n          If client window delete message, exit.\n        */\n        if (event.xclient.message_type != windows->wm_protocols)\n          break;\n        if (*event.xclient.data.l == (int) windows->wm_take_focus)\n          {\n            (void) XSetInputFocus(display,event.xclient.window,RevertToParent,\n              (Time) event.xclient.data.l[1]);\n            break;\n          }\n        if (*event.xclient.data.l != (int) windows->wm_delete_window)\n          break;\n        if (event.xclient.window == windows->widget.id)\n          {\n            *reply_info.text='\\0';\n            state|=ExitState;\n            break;\n          }\n        break;\n      }\n      case ConfigureNotify:\n      {\n        /*\n          Update widget configuration.\n        */\n        if (event.xconfigure.window != windows->widget.id)\n          break;\n        if ((event.xconfigure.width == (int) windows->widget.width) &&\n            (event.xconfigure.height == (int) windows->widget.height))\n          break;\n        windows->widget.width=(unsigned int)\n          MagickMax(event.xconfigure.width,(int) windows->widget.min_width);\n        windows->widget.height=(unsigned int)\n          MagickMax(event.xconfigure.height,(int) windows->widget.min_height);\n        state|=UpdateConfigurationState;\n        break;\n      }\n      case EnterNotify:\n      {\n        if (event.xcrossing.window != windows->widget.id)\n          break;\n        state&=(~InactiveWidgetState);\n        break;\n      }\n      case Expose:\n      {\n        if (event.xexpose.window != windows->widget.id)\n          break;\n        if (event.xexpose.count != 0)\n          break;\n        state|=RedrawWidgetState;\n        break;\n      }\n      case KeyPress:\n      {\n        static char\n          command[MaxTextExtent];\n\n        static int\n          length;\n\n        static KeySym\n          key_symbol;\n\n        /*\n          Respond to a user key press.\n        */\n        if (event.xkey.window != windows->widget.id)\n          break;\n        length=XLookupString((XKeyEvent *) &event.xkey,command,\n          (int) sizeof(command),&key_symbol,(XComposeStatus *) NULL);\n        *(command+length)='\\0';\n        if (AreaIsActive(scroll_info,event.xkey))\n          {\n            /*\n              Move slider.\n            */\n            switch ((int) key_symbol)\n            {\n              case XK_Home:\n              case XK_KP_Home:\n              {\n                slider_info.id=0;\n                break;\n              }\n              case XK_Up:\n              case XK_KP_Up:\n              {\n                slider_info.id--;\n                break;\n              }\n              case XK_Down:\n              case XK_KP_Down:\n              {\n                slider_info.id++;\n                break;\n              }\n              case XK_Prior:\n              case XK_KP_Prior:\n              {\n                slider_info.id-=visible_fonts;\n                break;\n              }\n              case XK_Next:\n              case XK_KP_Next:\n              {\n                slider_info.id+=visible_fonts;\n                break;\n              }\n              case XK_End:\n              case XK_KP_End:\n              {\n                slider_info.id=fonts;\n                break;\n              }\n            }\n            state|=RedrawListState;\n            break;\n          }\n        if ((key_symbol == XK_Return) || (key_symbol == XK_KP_Enter))\n          {\n            /*\n              Read new font or glob patterm.\n            */\n            if (*reply_info.text == '\\0')\n              break;\n            (void) CopyMagickString(back_pattern,glob_pattern,MaxTextExtent);\n            (void) CopyMagickString(glob_pattern,reply_info.text,MaxTextExtent);\n            state|=UpdateListState;\n            break;\n          }\n        if (key_symbol == XK_Control_L)\n          {\n            state|=ControlState;\n            break;\n          }\n        if (state & ControlState)\n          switch ((int) key_symbol)\n          {\n            case XK_u:\n            case XK_U:\n            {\n              /*\n                Erase the entire line of text.\n              */\n              *reply_info.text='\\0';\n              reply_info.cursor=reply_info.text;\n              reply_info.marker=reply_info.text;\n              reply_info.highlight=MagickFalse;\n              break;\n            }\n            default:\n              break;\n          }\n        XEditText(display,&reply_info,key_symbol,command,state);\n        XDrawMatteText(display,&windows->widget,&reply_info);\n        state|=JumpListState;\n        break;\n      }\n      case KeyRelease:\n      {\n        static char\n          command[MaxTextExtent];\n\n        static KeySym\n          key_symbol;\n\n        /*\n          Respond to a user key release.\n        */\n        if (event.xkey.window != windows->widget.id)\n          break;\n        (void) XLookupString((XKeyEvent *) &event.xkey,command,\n          (int) sizeof(command),&key_symbol,(XComposeStatus *) NULL);\n        if (key_symbol == XK_Control_L)\n          state&=(~ControlState);\n        break;\n      }\n      case LeaveNotify:\n      {\n        if (event.xcrossing.window != windows->widget.id)\n          break;\n        state|=InactiveWidgetState;\n        break;\n      }\n      case MapNotify:\n      {\n        mask&=(~CWX);\n        mask&=(~CWY);\n        break;\n      }\n      case MotionNotify:\n      {\n        /*\n          Discard pending button motion events.\n        */\n        while (XCheckMaskEvent(display,ButtonMotionMask,&event)) ;\n        if (slider_info.active)\n          {\n            /*\n              Move slider matte.\n            */\n            slider_info.y=event.xmotion.y-\n              ((slider_info.height+slider_info.bevel_width) >> 1)+1;\n            if (slider_info.y < slider_info.min_y)\n              slider_info.y=slider_info.min_y;\n            if (slider_info.y > slider_info.max_y)\n              slider_info.y=slider_info.max_y;\n            slider_info.id=0;\n            if (slider_info.y != slider_info.min_y)\n              slider_info.id=(fonts*(slider_info.y-slider_info.min_y+1))/\n                (slider_info.max_y-slider_info.min_y+1);\n            state|=RedrawListState;\n            break;\n          }\n        if (state & InactiveWidgetState)\n          break;\n        if (back_info.raised == MatteIsActive(back_info,event.xmotion))\n          {\n            /*\n              Back button status changed.\n            */\n            back_info.raised=!back_info.raised;\n            XDrawBeveledButton(display,&windows->widget,&back_info);\n            break;\n          }\n        if (reset_info.raised == MatteIsActive(reset_info,event.xmotion))\n          {\n            /*\n              Reset button status changed.\n            */\n            reset_info.raised=!reset_info.raised;\n            XDrawBeveledButton(display,&windows->widget,&reset_info);\n            break;\n          }\n        if (action_info.raised == MatteIsActive(action_info,event.xmotion))\n          {\n            /*\n              Action button status changed.\n            */\n            action_info.raised=action_info.raised == MagickFalse ?\n              MagickTrue : MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&action_info);\n            break;\n          }\n        if (cancel_info.raised == MatteIsActive(cancel_info,event.xmotion))\n          {\n            /*\n              Cancel button status changed.\n            */\n            cancel_info.raised=cancel_info.raised == MagickFalse ?\n              MagickTrue : MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&cancel_info);\n            break;\n          }\n        break;\n      }\n      case SelectionClear:\n      {\n        reply_info.highlight=MagickFalse;\n        XDrawMatteText(display,&windows->widget,&reply_info);\n        break;\n      }\n      case SelectionNotify:\n      {\n        Atom\n          type;\n\n        int\n          format;\n\n        unsigned char\n          *data;\n\n        unsigned long\n          after,\n          length;\n\n        /*\n          Obtain response from primary selection.\n        */\n        if (event.xselection.property == (Atom) None)\n          break;\n        status=XGetWindowProperty(display,event.xselection.requestor,\n          event.xselection.property,0L,2047L,MagickTrue,XA_STRING,&type,\n          &format,&length,&after,&data);\n        if ((status != Success) || (type != XA_STRING) || (format == 32) ||\n            (length == 0))\n          break;\n        if ((Extent(reply_info.text)+length) >= (MaxTextExtent-1))\n          (void) XBell(display,0);\n        else\n          {\n            /*\n              Insert primary selection in reply text.\n            */\n            *(data+length)='\\0';\n            XEditText(display,&reply_info,(KeySym) XK_Insert,(char *) data,\n              state);\n            XDrawMatteText(display,&windows->widget,&reply_info);\n            state|=JumpListState;\n            state|=RedrawActionState;\n          }\n        (void) XFree((void *) data);\n        break;\n      }\n      case SelectionRequest:\n      {\n        XSelectionEvent\n          notify;\n\n        XSelectionRequestEvent\n          *request;\n\n        /*\n          Set XA_PRIMARY selection.\n        */\n        request=(&(event.xselectionrequest));\n        (void) XChangeProperty(request->display,request->requestor,\n          request->property,request->target,8,PropModeReplace,\n          (unsigned char *) primary_selection,Extent(primary_selection));\n        notify.type=SelectionNotify;\n        notify.display=request->display;\n        notify.requestor=request->requestor;\n        notify.selection=request->selection;\n        notify.target=request->target;\n        notify.time=request->time;\n        if (request->property == None)\n          notify.property=request->target;\n        else\n          notify.property=request->property;\n        (void) XSendEvent(request->display,request->requestor,False,0,\n          (XEvent *) &notify);\n      }\n      default:\n        break;\n    }\n  } while ((state & ExitState) == 0);\n  XSetCursorState(display,windows,MagickFalse);\n  (void) XWithdrawWindow(display,windows->widget.id,windows->widget.screen);\n  XCheckRefreshWindows(display,windows);\n  /*\n    Free font list.\n  */\n  (void) XFreeFontNames(listhead);\n  fontlist=(char **) RelinquishMagickMemory(fontlist);\n}", "func_hash": 99334885650241582492144416268982789812, "file_name": "widget.c", "file_hash": 31318598747823313517201273606802259325, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 206417, "project": "vim", "commit_id": "0971c7a4e537ea120a6bb2195960be8d0815e97b", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/0971c7a4e537ea120a6bb2195960be8d0815e97b", "commit_message": "patch 8.2.5162: reading before the start of the line with BS in Replace mode\n\nProblem:    Reading before the start of the line with BS in Replace mode.\nSolution:   Check the cursor column is more than zero.", "target": 1, "func": "ins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n    int\t\tcall_fix_indent = FALSE;\n\n    /*\n     * can't delete anything in an empty file\n     * can't backup past first character in buffer\n     * can't backup past starting point unless 'backspace' > 1\n     * can backup to a previous line if 'backspace' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &&\n#endif\n\t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&& ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&& !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n\t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n\t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n    if (in_indent)\n\tcan_cindent = FALSE;\n    end_comment_pending = NUL;\t// After BS, don't auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin->w_cursor.coladd > 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin->w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin->w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin->w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc < 0: NL was inserted, delete it\n\t * cc >= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State & REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State & VREPLACE_FLAG)\n\t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin->w_cursor.lnum;\n\n\t\t// When \"aw\" is in 'formatoptions' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len > 0 && ptr[len - 1] == ' ')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL && gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State & REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc > 0)\n\t\t{\n\t\t    save_col = curwin->w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin->w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&& (curbuf->b_p_ai || cindent_on())\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin->w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin->w_cursor.col < save_col)\n\t    {\n\t\tmincol = curwin->w_cursor.col;\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n\t    }\n\t    curwin->w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one 'shiftwidth' or 'softtabstop'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&& ((p_sta && in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&& curwin->w_cursor.col > 0\n\t\t\t&& (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == ' '\n\t\t\t\t&& (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // 'showbreak' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta && in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf->b_p_vsts_array);\n#else\n\t    if (p_sta && in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol > want_vcol\n\t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol < want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin->w_cursor.col;\n\n\t\tif (State & VREPLACE_FLAG)\n\t\t    ins_char(' ');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)\" \");\n\t\t    if ((State & REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using 'sts' and 'linebreak'.\n\t    if (vcol >= start_vcol)\n\t\tins_bs_one(&vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State & REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State & REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 && p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and 'delcombine' is set\n\t\t     * move the cursor back.  Don't back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on && gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin->w_cursor.col > mincol\n\t\t    &&  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (curwin->w_cursor.col <= 1)\n\tdid_ai = FALSE;\n\n    if (call_fix_indent)\n\tfix_indent();\n\n    /*\n     * It's a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n\tInsstart_orig.col = curwin->w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn't.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n\tdollar_vcol = curwin->w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when 'foldmethod' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}", "func_hash": 172194519756788339453675041357999010208, "file_name": "edit.c", "file_hash": 334216402611901751671385717284214475763, "cwe": ["CWE-787"], "cve": "CVE-2022-2207", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2207"}
{"idx": 90894, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": " void UsageTracker::GetCachedOrigins(std::set<GURL>* origins) const {\n   DCHECK(origins);\n   origins->clear();\n  for (ClientTrackerMap::const_iterator iter = client_tracker_map_.begin();\n       iter != client_tracker_map_.end(); ++iter) {\n    iter->second->GetCachedOrigins(origins);\n  }\n}\n", "func_hash": 118603064518968534788231635571458169547, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 195391, "project": "tensorflow", "commit_id": "f68fdab93fb7f4ddb4eb438c8fe052753c9413e8", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/f68fdab93fb7f4ddb4eb438c8fe052753c9413e8", "commit_message": "Add a check for pad width to be a positive value.\n\nPiperOrigin-RevId: 413275853\nChange-Id: I261a8db9dabf5ce48a806a9e58129080c9fac619", "target": 1, "func": "  void Compute(tensorflow::OpKernelContext* context) override {\n    for (int ngram_width : ngram_widths_) {\n      OP_REQUIRES(\n          context, ngram_width > 0,\n          errors::InvalidArgument(\"ngram_widths must contain positive values\"));\n    }\n\n    const tensorflow::Tensor* data;\n    OP_REQUIRES_OK(context, context->input(\"data\", &data));\n    const auto& input_data = data->flat<tstring>().data();\n\n    const tensorflow::Tensor* splits;\n    OP_REQUIRES_OK(context, context->input(\"data_splits\", &splits));\n    const auto& splits_vec = splits->flat<SPLITS_TYPE>();\n\n    // Validate that the splits are valid indices into data, only if there are\n    // splits specified.\n    const int input_data_size = data->flat<tstring>().size();\n    const int splits_vec_size = splits_vec.size();\n    if (splits_vec_size > 0) {\n      int prev_split = splits_vec(0);\n      OP_REQUIRES(context, prev_split == 0,\n                  errors::InvalidArgument(\"First split value must be 0, got \",\n                                          prev_split));\n      for (int i = 1; i < splits_vec_size; ++i) {\n        bool valid_splits = splits_vec(i) >= prev_split;\n        valid_splits = valid_splits && (splits_vec(i) <= input_data_size);\n        OP_REQUIRES(context, valid_splits,\n                    errors::InvalidArgument(\n                        \"Invalid split value \", splits_vec(i), \", must be in [\",\n                        prev_split, \", \", input_data_size, \"]\"));\n        prev_split = splits_vec(i);\n      }\n      OP_REQUIRES(context, prev_split == input_data_size,\n                  errors::InvalidArgument(\n                      \"Last split value must be data size. Expected \",\n                      input_data_size, \", got \", prev_split));\n    }\n\n    int num_batch_items = splits_vec.size() - 1;\n    tensorflow::Tensor* ngrams_splits;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(1, splits->shape(), &ngrams_splits));\n    auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data();\n\n    // If there is no data or size, return an empty RT.\n    if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) {\n      tensorflow::Tensor* empty;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, data->shape(), &empty));\n      for (int i = 0; i <= num_batch_items; ++i) {\n        ngrams_splits_data[i] = 0;\n      }\n      return;\n    }\n\n    ngrams_splits_data[0] = 0;\n    for (int i = 1; i <= num_batch_items; ++i) {\n      int length = splits_vec(i) - splits_vec(i - 1);\n      int num_ngrams = 0;\n      for (int ngram_width : ngram_widths_)\n        num_ngrams += get_num_ngrams(length, ngram_width);\n      if (preserve_short_ && length > 0 && num_ngrams == 0) {\n        num_ngrams = 1;\n      }\n      ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams;\n    }\n\n    tensorflow::Tensor* ngrams;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams));\n    auto ngrams_data = ngrams->flat<tstring>().data();\n\n    for (int i = 0; i < num_batch_items; ++i) {\n      auto data_start = &input_data[splits_vec(i)];\n      int output_start_idx = ngrams_splits_data[i];\n      for (int ngram_width : ngram_widths_) {\n        auto output_start = &ngrams_data[output_start_idx];\n        int length = splits_vec(i + 1) - splits_vec(i);\n        int num_ngrams = get_num_ngrams(length, ngram_width);\n        CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n        output_start_idx += num_ngrams;\n      }\n      // If we're preserving short sequences, check to see if no sequence was\n      // generated by comparing the current output start idx to the original\n      // one (ngram_splits_data). If no ngrams were generated, then they will\n      // be equal (since we increment output_start_idx by num_ngrams every\n      // time we create a set of ngrams.)\n      if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) {\n        int data_length = splits_vec(i + 1) - splits_vec(i);\n        // One legitimate reason to not have any ngrams when preserve_short_\n        // is true is if the sequence itself is empty. In that case, move on.\n        if (data_length == 0) {\n          continue;\n        }\n        // We don't have to worry about dynamic padding sizes here: if padding\n        // was dynamic, every sequence would have had sufficient padding to\n        // generate at least one ngram.\n        int ngram_width = data_length + 2 * pad_width_;\n        auto output_start = &ngrams_data[output_start_idx];\n        int num_ngrams = 1;\n        CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n      }\n    }\n  }", "func_hash": 93012019628610956612764593105283326156, "file_name": "string_ngrams_op.cc", "file_hash": 245905885483763938680185872776744444218, "cwe": ["CWE-190"], "cve": "CVE-2022-21733", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `StringNGrams` can be used to trigger a denial of service attack by causing an out of memory condition after an integer overflow. We are missing a validation on `pad_witdh` and that result in computing a negative value for `ngram_width` which is later used to allocate parts of the output. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-21733"}
{"idx": 220031, "project": "tensorflow", "commit_id": "a68f68061e263a88321c104a6c911fe5598050a8", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/a68f68061e263a88321c104a6c911fe5598050a8", "commit_message": "Replace faulty overflow check with a builder for `TensorShape`.\n\nPrevents an integer overflow that was not caught before.\n\nPiperOrigin-RevId: 415381595\nChange-Id: I76585ddedc912bd9f4a390aeafa8e2ced1a28863", "target": 0, "func": "  string DebugString() const override { return \"A SparseTensorsMap\"; }", "func_hash": 185315156359592068837380825250301664240, "file_name": "sparse_tensors_map_ops.cc", "file_hash": 224775123349374780251651202891389866533, "cwe": ["CWE-190"], "cve": "CVE-2022-23568", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `AddManySparseToTensorsMap` is vulnerable to an integer overflow which results in a `CHECK`-fail when building new `TensorShape` objects (so, an assert failure based denial of service). We are missing some validation on the shapes of the input tensors as well as directly constructing a large `TensorShape` with user-provided dimensions. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23568"}
{"idx": 197511, "project": "libjpeg", "commit_id": "187035b9726710b4fe11d565c7808975c930895d", "project_url": "https://github.com/thorfdbg/libjpeg", "commit_url": "https://github.com/thorfdbg/libjpeg/commit/187035b9726710b4fe11d565c7808975c930895d", "commit_message": "The code now checks for consistency of the MCU sizes across\nhierarchical levels, and fails in case they are different.", "target": 1, "func": "void HierarchicalBitmapRequester::PrepareForDecoding(void)\n{\n#if ACCUSOFT_CODE\n\n  UBYTE i;\n\n  BuildCommon();\n\n  if (m_ppDecodingMCU == NULL) {\n    m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);\n    memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n  }\n\n  if (m_ppUpsampler == NULL) {\n    m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);\n    memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);\n\n    for(i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE sx = comp->SubXOf();\n      UBYTE sy = comp->SubYOf();\n\n      if (sx > 1 || sy > 1) {\n        m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,\n                                                          m_ulPixelWidth,m_ulPixelHeight,\n                                                          m_pFrame->TablesOf()->isChromaCentered());\n        m_bSubsampling   = true;\n      }\n    }\n  }\n\n  if (m_pLargestScale)\n    m_pLargestScale->PrepareForDecoding();\n#endif\n}", "func_hash": 63468052144489012470048601021040613418, "file_name": "hierarchicalbitmaprequester.cpp", "file_hash": 34345221108539770458549868924228630502, "cwe": ["CWE-787"], "cve": "CVE-2022-31796", "cve_desc": "libjpeg 1.63 has a heap-based buffer over-read in HierarchicalBitmapRequester::FetchRegion in hierarchicalbitmaprequester.cpp because the MCU size can be different between allocation and use.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-31796"}
{"idx": 96951, "project": "Chrome", "commit_id": "3c1864079c441ea2e08f882acaaf441f78a6de3d", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/3c1864079c441ea2e08f882acaaf441f78a6de3d", "commit_message": "None", "target": 0, "func": "void encode(ArgumentEncoder* encoder, CFTypeRef typeRef)\n{\n    CFType type = typeFromCFTypeRef(typeRef);\n    encoder->encodeEnum(type);\n\n    switch (type) {\n    case CFArray:\n        encode(encoder, static_cast<CFArrayRef>(typeRef));\n        return;\n    case CFBoolean:\n        encode(encoder, static_cast<CFBooleanRef>(typeRef));\n        return;\n    case CFData:\n        encode(encoder, static_cast<CFDataRef>(typeRef));\n        return;\n    case CFDate:\n        encode(encoder, static_cast<CFDateRef>(typeRef));\n        return;\n    case CFDictionary:\n        encode(encoder, static_cast<CFDictionaryRef>(typeRef));\n        return;\n    case CFNull:\n        return;\n    case CFNumber:\n        encode(encoder, static_cast<CFNumberRef>(typeRef));\n        return;\n    case CFString:\n        encode(encoder, static_cast<CFStringRef>(typeRef));\n        return;\n    case CFURL:\n        encode(encoder, static_cast<CFURLRef>(typeRef));\n        return;\n#if PLATFORM(MAC)\n    case SecCertificate:\n        encode(encoder, (SecCertificateRef)typeRef);\n        return;\n    case SecKeychainItem:\n        encode(encoder, (SecKeychainItemRef)typeRef);\n        return;\n#endif\n    case Null:\n        return;\n    case Unknown:\n        break;\n    }\n\n    ASSERT_NOT_REACHED();\n}\n", "func_hash": 314043615412523958982815403259581385029, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 219995, "project": "glewlwyd", "commit_id": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "project_url": "https://github.com/babelouest/glewlwyd", "commit_url": "https://github.com/babelouest/glewlwyd/commit/125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "commit_message": "Fix update session when auth fail", "target": 0, "func": "int callback_glewlwyd_get_user (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct config_elements * config = (struct config_elements *)user_data;\n  json_t * j_user;\n  \n  j_user = get_user(config, u_map_get(request->map_url, \"username\"), u_map_get(request->map_url, \"source\"));\n  if (check_result_value(j_user, G_OK)) {\n    ulfius_set_json_body_response(response, 200, json_object_get(j_user, \"user\"));\n  } else if (check_result_value(j_user, G_ERROR_NOT_FOUND)) {\n    response->status = 404;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_get_user - Error j_user\");\n    response->status = 500;\n  }\n  json_decref(j_user);\n  return U_CALLBACK_CONTINUE;\n}", "func_hash": 88027454093600725911642167611306263521, "file_name": "webservice.c", "file_hash": 287798817606377336444620654835011177393, "cwe": ["CWE-287"], "cve": "CVE-2021-45379", "cve_desc": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-45379"}
{"idx": 139220, "project": "Chrome", "commit_id": "fb83de09f2c986ee91741f3a2776feea0e18e3f6", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/fb83de09f2c986ee91741f3a2776feea0e18e3f6", "commit_message": "None", "target": 0, "func": "gfx::Rect OverlayWindowViews::GetFirstCustomControlsBounds() {\n  if (!first_custom_controls_view_)\n    return gfx::Rect();\n  return first_custom_controls_view_->GetMirroredBounds();\n}\n", "func_hash": 301120450789669239444216016296921335123, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 220428, "project": "mruby", "commit_id": "27d1e0132a0804581dca28df042e7047fd27eaa8", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8", "commit_message": "array.c: fix `mrb_ary_shift_m` initialization bug.\n\nThe `ARY_PTR` and `ARY_LEN` may be modified in `mrb_get_args`.", "target": 0, "func": "ary_expand_capa(mrb_state *mrb, struct RArray *a, mrb_int len)\n{\n  mrb_int capa = ARY_CAPA(a);\n\n  if (len > ARY_MAX_SIZE || len < 0) {\n  size_error:\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"array size too big\");\n  }\n\n  if (capa < ARY_DEFAULT_LEN) {\n    capa = ARY_DEFAULT_LEN;\n  }\n  while (capa < len) {\n    if (capa <= ARY_MAX_SIZE / 2) {\n      capa *= 2;\n    }\n    else {\n      capa = len;\n    }\n  }\n  if (capa < len || capa > ARY_MAX_SIZE) {\n    goto size_error;\n  }\n\n  if (ARY_EMBED_P(a)) {\n    mrb_value *ptr = ARY_EMBED_PTR(a);\n    mrb_int len = ARY_EMBED_LEN(a);\n    mrb_value *expanded_ptr = (mrb_value *)mrb_malloc(mrb, sizeof(mrb_value)*capa);\n\n    ARY_UNSET_EMBED_FLAG(a);\n    array_copy(expanded_ptr, ptr, len);\n    a->as.heap.len = len;\n    a->as.heap.aux.capa = capa;\n    a->as.heap.ptr = expanded_ptr;\n  }\n  else if (capa > a->as.heap.aux.capa) {\n    mrb_value *expanded_ptr = (mrb_value *)mrb_realloc(mrb, a->as.heap.ptr, sizeof(mrb_value)*capa);\n\n    a->as.heap.aux.capa = capa;\n    a->as.heap.ptr = expanded_ptr;\n  }\n}", "func_hash": 157262547182546361658646462860182913522, "file_name": "array.c", "file_hash": 295526445825727607536544634773604768998, "cwe": ["CWE-476"], "cve": "CVE-2021-4188", "cve_desc": "mruby is vulnerable to NULL Pointer Dereference", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4188"}
{"idx": 208673, "project": "flatpak", "commit_id": "e2c4ded323161f47609d0af97d00019d04a635f1", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/e2c4ded323161f47609d0af97d00019d04a635f1", "commit_message": "portal: Let --env= and --env-fd= take precedence over extra-args\n\nPreviously, if you launched a subsandbox while specifying environment\nvariable overrides, any environment variable overrides that existed\nin the parent Flatpak app would take precedence:\n\n    host$ flatpak run --env=FOO=1 --command=bash example.app\n    [\ud83d\udce6 example.app ~]$ env | grep FOO\n    FOO=1\n    [\ud83d\udce6 example.app ~]$ flatpak-spawn --env=FOO=x sh -c 'env | grep FOO'\n    FOO=1\n\nThis does not seem like least-astonishment, and in particular will\ncause problems if the app wants to override LD_LIBRARY_PATH in the\nsubsandbox. Change the precedence so that the environment variables\nset by flatpak-spawn will \"win\":\n\n    host$ flatpak run --env=FOO1=1 --env=FOO2=2 --command=bash example.app\n    [\ud83d\udce6 example.app ~]$ env | grep FOO\n    FOO1=1\n    FOO2=2\n    [\ud83d\udce6 example.app ~]$ flatpak-spawn --env=FOO1=x sh -c 'env | grep FOO'\n    FOO1=x\n    FOO2=2\n\nThis follows up from GHSA-4ppf-fxf6-vxg2 to fix an issue that I noticed\nwhile resolving that vulnerability, but is not required for fixing the\nvulnerability.\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "target": 1, "func": "handle_spawn (PortalFlatpak         *object,\n              GDBusMethodInvocation *invocation,\n              GUnixFDList           *fd_list,\n              const gchar           *arg_cwd_path,\n              const gchar *const    *arg_argv,\n              GVariant              *arg_fds,\n              GVariant              *arg_envs,\n              guint                  arg_flags,\n              GVariant              *arg_options)\n{\n  g_autoptr(GError) error = NULL;\n  ChildSetupData child_setup_data = { NULL };\n  GPid pid;\n  PidData *pid_data;\n  InstanceIdReadData *instance_id_read_data = NULL;\n  gsize i, j, n_fds, n_envs;\n  const gint *fds = NULL;\n  gint fds_len = 0;\n  g_autofree FdMapEntry *fd_map = NULL;\n  gchar **env;\n  gint32 max_fd;\n  GKeyFile *app_info;\n  g_autoptr(GPtrArray) flatpak_argv = g_ptr_array_new_with_free_func (g_free);\n  g_autofree char *app_id = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *arch = NULL;\n  g_autofree char *app_commit = NULL;\n  g_autofree char *runtime_ref = NULL;\n  g_auto(GStrv) runtime_parts = NULL;\n  g_autofree char *runtime_commit = NULL;\n  g_autofree char *instance_path = NULL;\n  g_auto(GStrv) extra_args = NULL;\n  g_auto(GStrv) shares = NULL;\n  g_auto(GStrv) sockets = NULL;\n  g_auto(GStrv) devices = NULL;\n  g_auto(GStrv) sandbox_expose = NULL;\n  g_auto(GStrv) sandbox_expose_ro = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;\n  g_autoptr(GOutputStream) instance_id_out_stream = NULL;\n  guint sandbox_flags = 0;\n  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n  g_autoptr(GString) env_string = g_string_new (\"\");\n\n  child_setup_data.instance_id_fd = -1;\n  child_setup_data.env_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \"app-info\");\n  g_assert (app_info != NULL);\n\n  app_id = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_APPLICATION,\n                                  FLATPAK_METADATA_KEY_NAME, NULL);\n  g_assert (app_id != NULL);\n\n  g_debug (\"spawn() called from app: '%s'\", app_id);\n  if (*app_id == 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"org.freedesktop.portal.Flatpak.Spawn only works in a flatpak\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (*arg_cwd_path == 0)\n    arg_cwd_path = NULL;\n\n  if (arg_argv == NULL || *arg_argv == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"No command given\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if ((arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Unsupported flags enabled: 0x%x\", arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_ref = g_key_file_get_string (app_info,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_RUNTIME, NULL);\n  if (runtime_ref == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"No runtime found\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_parts = g_strsplit (runtime_ref, \"/\", -1);\n\n  branch = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_BRANCH, NULL);\n  instance_path = g_key_file_get_string (app_info,\n                                         FLATPAK_METADATA_GROUP_INSTANCE,\n                                         FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL);\n  arch = g_key_file_get_string (app_info,\n                                FLATPAK_METADATA_GROUP_INSTANCE,\n                                FLATPAK_METADATA_KEY_ARCH, NULL);\n  extra_args = g_key_file_get_string_list (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL);\n  app_commit = g_key_file_get_string (app_info,\n                                      FLATPAK_METADATA_GROUP_INSTANCE,\n                                      FLATPAK_METADATA_KEY_APP_COMMIT, NULL);\n  runtime_commit = g_key_file_get_string (app_info,\n                                          FLATPAK_METADATA_GROUP_INSTANCE,\n                                          FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL);\n  shares = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SHARED, NULL, NULL);\n  sockets = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL);\n  devices = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                        FLATPAK_METADATA_KEY_DEVICES, NULL, NULL);\n\n  devel = g_key_file_get_boolean (app_info, FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_DEVEL, NULL);\n\n  g_variant_lookup (arg_options, \"sandbox-expose\", \"^as\", &sandbox_expose);\n  g_variant_lookup (arg_options, \"sandbox-expose-ro\", \"^as\", &sandbox_expose_ro);\n  g_variant_lookup (arg_options, \"sandbox-flags\", \"u\", &sandbox_flags);\n  sandbox_expose_fd = g_variant_lookup_value (arg_options, \"sandbox-expose-fd\", G_VARIANT_TYPE (\"ah\"));\n  sandbox_expose_fd_ro = g_variant_lookup_value (arg_options, \"sandbox-expose-fd-ro\", G_VARIANT_TYPE (\"ah\"));\n\n  if ((sandbox_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Unsupported sandbox flags enabled: 0x%x\", arg_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_path == NULL &&\n      ((sandbox_expose != NULL && sandbox_expose[0] != NULL) ||\n       (sandbox_expose_ro != NULL && sandbox_expose_ro[0] != NULL)))\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Invalid sandbox expose, caller has no instance path\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose[i];\n\n      g_debug (\"exposing %s\", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\"exposing %s\", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  g_debug (\"Running spawn command %s\", arg_argv[0]);\n\n  n_fds = 0;\n  if (fds != NULL)\n    n_fds = g_variant_n_children (arg_fds);\n  fd_map = g_new0 (FdMapEntry, n_fds);\n\n  child_setup_data.fd_map = fd_map;\n  child_setup_data.fd_map_len = n_fds;\n\n  max_fd = -1;\n  for (i = 0; i < n_fds; i++)\n    {\n      gint32 handle, dest_fd;\n      int handle_fd;\n\n      g_variant_get_child (arg_fds, i, \"{uh}\", &dest_fd, &handle);\n\n      if (handle >= fds_len || handle < 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"No file descriptor for handle %d\",\n                                                 handle);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      handle_fd = fds[handle];\n\n      fd_map[i].to = dest_fd;\n      fd_map[i].from = handle_fd;\n      fd_map[i].final = fd_map[i].to;\n\n      /* If stdin/out/err is a tty we try to set it as the controlling\n         tty for the app, this way we can use this to run in a terminal. */\n      if ((dest_fd == 0 || dest_fd == 1 || dest_fd == 2) &&\n          !child_setup_data.set_tty &&\n          isatty (handle_fd))\n        {\n          child_setup_data.set_tty = TRUE;\n          child_setup_data.tty = handle_fd;\n        }\n\n      max_fd = MAX (max_fd, fd_map[i].to);\n      max_fd = MAX (max_fd, fd_map[i].from);\n    }\n\n  /* We make a second pass over the fds to find if any \"to\" fd index\n     overlaps an already in use fd (i.e. one in the \"from\" category\n     that are allocated randomly). If a fd overlaps \"to\" fd then its\n     a caller issue and not our fault, so we ignore that. */\n  for (i = 0; i < n_fds; i++)\n    {\n      int to_fd = fd_map[i].to;\n      gboolean conflict = FALSE;\n\n      /* At this point we're fine with using \"from\" values for this\n         value (because we handle to==from in the code), or values\n         that are before \"i\" in the fd_map (because those will be\n         closed at this point when dup:ing). However, we can't\n         reuse a fd that is in \"from\" for j > i. */\n      for (j = i + 1; j < n_fds; j++)\n        {\n          int from_fd = fd_map[j].from;\n          if (from_fd == to_fd)\n            {\n              conflict = TRUE;\n              break;\n            }\n        }\n\n      if (conflict)\n        fd_map[i].to = ++max_fd;\n    }\n\n  /* TODO: Ideally we should let `flatpak run` inherit the portal's\n   * environment, in case e.g. a LD_LIBRARY_PATH is needed to be able\n   * to run `flatpak run`, but tell it to start from a blank environment\n   * when running the Flatpak app; but this isn't currently possible, so\n   * for now we preserve existing behaviour. */\n  if (arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV)\n    {\n      char *empty[] = { NULL };\n      env = g_strdupv (empty);\n    }\n  else\n    env = g_get_environ ();\n\n  /* Let the environment variables given by the caller override the ones\n   * from extra_args. Don't add them to @env, because they are controlled\n   * by our caller, which might be trying to use them to inject code into\n   * flatpak(1); add them to the environment block instead.\n   *\n   * We don't use --env= here, so that if the values are something that\n   * should not be exposed to other uids, they can remain confidential. */\n  n_envs = g_variant_n_children (arg_envs);\n  for (i = 0; i < n_envs; i++)\n    {\n      const char *var = NULL;\n      const char *val = NULL;\n      g_variant_get_child (arg_envs, i, \"{&s&s}\", &var, &val);\n\n      if (var[0] == '\\0')\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"Environment variable cannot have empty name\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      if (strchr (var, '=') != NULL)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"Environment variable name cannot contain '='\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      g_string_append (env_string, var);\n      g_string_append_c (env_string, '=');\n      g_string_append (env_string, val);\n      g_string_append_c (env_string, '\\0');\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup (\"flatpak\"));\n  g_ptr_array_add (flatpak_argv, g_strdup (\"run\"));\n\n  sandboxed = (arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0;\n\n  if (sandboxed)\n    {\n      g_ptr_array_add (flatpak_argv, g_strdup (\"--sandbox\"));\n\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"wayland\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=wayland\"));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"fallback-x11\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=fallback-x11\"));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"x11\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=x11\"));\n          if (shares != NULL && g_strv_contains ((const char * const *) shares, \"ipc\") &&\n              sockets != NULL && (g_strv_contains ((const char * const *) sockets, \"fallback-x11\") ||\n                                  g_strv_contains ((const char * const *) sockets, \"x11\")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--share=ipc\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"pulseaudio\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=pulseaudio\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU)\n        {\n          if (devices != NULL &&\n              (g_strv_contains ((const char * const *) devices, \"dri\") ||\n               g_strv_contains ((const char * const *) devices, \"all\")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--device=dri\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--session-bus\"));\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--a11y-bus\"));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        {\n          if (g_str_has_prefix (extra_args[i], \"--env=\"))\n            {\n              const char *var_val = extra_args[i] + strlen (\"--env=\");\n\n              if (var_val[0] == '\\0' || var_val[0] == '=')\n                {\n                  g_warning (\"Environment variable in extra-args has empty name\");\n                  continue;\n                }\n\n              if (strchr (var_val, '=') == NULL)\n                {\n                  g_warning (\"Environment variable in extra-args has no value\");\n                  continue;\n                }\n\n              g_string_append (env_string, var_val);\n              g_string_append_c (env_string, '\\0');\n            }\n          else\n            {\n              g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n            }\n        }\n    }\n\n  if (env_string->len > 0)\n    {\n      g_auto(GLnxTmpfile) env_tmpf  = { 0, };\n\n      if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, \"environ\",\n                                                      env_string->str,\n                                                      env_string->len, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);\n      g_ptr_array_add (flatpak_argv,\n                       g_strdup_printf (\"--env-fd=%d\",\n                                        child_setup_data.env_fd));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n\n  if (expose_pids || share_pids)\n    {\n      g_autofree char *instance_id = NULL;\n      int sender_pid1 = 0;\n\n      if (!(supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS))\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_NOT_SUPPORTED,\n                                                 \"Expose pids not supported with setuid bwrap\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      instance_id = g_key_file_get_string (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_INSTANCE_ID, NULL);\n\n      if (instance_id)\n        {\n          g_autoptr(FlatpakInstance) instance = flatpak_instance_new_for_id (instance_id);\n          sender_pid1 = flatpak_instance_get_child_pid (instance);\n        }\n\n      if (sender_pid1 == 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"Could not find requesting pid\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--parent-pid=%d\", sender_pid1));\n\n      if (share_pids)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--parent-share-pids\"));\n      else\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--parent-expose-pids\"));\n    }\n\n  notify_start = (arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0;\n  if (notify_start)\n    {\n      int pipe_fds[2];\n      if (pipe (pipe_fds) == -1)\n        {\n          int errsv = errno;\n          g_dbus_method_invocation_return_error (invocation, G_IO_ERROR,\n                                                 g_io_error_from_errno (errsv),\n                                                 \"Failed to create instance ID pipe: %s\",\n                                                 g_strerror (errsv));\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      GInputStream *in_stream = G_INPUT_STREAM (g_unix_input_stream_new (pipe_fds[0], TRUE));\n      /* This is saved to ensure the portal's end gets closed after the exec. */\n      instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE));\n\n      instance_id_read_data = g_new0 (InstanceIdReadData, 1);\n\n      g_input_stream_read_async (in_stream, instance_id_read_data->buffer,\n                                 INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL,\n                                 instance_id_read_finish, instance_id_read_data);\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--instance-id-fd=%d\", pipe_fds[1]));\n      child_setup_data.instance_id_fd = pipe_fds[1];\n    }\n\n  if (devel)\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--devel\"));\n\n  /* Inherit launcher network access from launcher, unless\n     NO_NETWORK set. */\n  if (shares != NULL && g_strv_contains ((const char * const *) shares, \"network\") &&\n      !(arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK))\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--share=network\"));\n  else\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--unshare=network\"));\n\n\n  if (instance_path)\n    {\n      for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose[i], FALSE));\n      for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose_ro[i], TRUE));\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\"exposing %s\", expose);\n    }\n\n  if (sandbox_expose_fd != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd, i, \"h\", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, !writable));\n                }\n              else\n                {\n                  g_debug (\"unable to get path for sandbox-exposed fd %d, ignoring: %s\",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \"No file descriptor for handle %d\",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  if (sandbox_expose_fd_ro != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd_ro);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd_ro, i, \"h\", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, TRUE));\n                }\n              else\n                {\n                  g_debug (\"unable to get path for sandbox-exposed fd %d, ignoring: %s\",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \"No file descriptor for handle %d\",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime=%s\", runtime_parts[1]));\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime-version=%s\", runtime_parts[3]));\n\n  if ((arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0)\n    {\n      if (app_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--commit=%s\", app_commit));\n      if (runtime_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime-commit=%s\", runtime_commit));\n    }\n\n  if (arg_cwd_path != NULL)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--cwd=%s\", arg_cwd_path));\n\n  if (arg_argv[0][0] != 0)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--command=%s\", arg_argv[0]));\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"%s/%s/%s\", app_id, arch ? arch : \"\", branch ? branch : \"\"));\n  for (i = 1; arg_argv[i] != NULL; i++)\n    g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i]));\n  g_ptr_array_add (flatpak_argv, NULL);\n\n  if (opt_verbose)\n    {\n      g_autoptr(GString) cmd = g_string_new (\"\");\n\n      for (i = 0; flatpak_argv->pdata[i] != NULL; i++)\n        {\n          if (i > 0)\n            g_string_append (cmd, \" \");\n          g_string_append (cmd, flatpak_argv->pdata[i]);\n        }\n\n      g_debug (\"Starting: %s\\n\", cmd->str);\n    }\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_async_with_pipes (NULL,\n                                 (char **) flatpak_argv->pdata,\n                                 env,\n                                 G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                                 child_setup_func, &child_setup_data,\n                                 &pid,\n                                 NULL,\n                                 NULL,\n                                 NULL,\n                                 &error))\n    {\n      gint code = G_DBUS_ERROR_FAILED;\n      if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES))\n        code = G_DBUS_ERROR_ACCESS_DENIED;\n      else if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT))\n        code = G_DBUS_ERROR_FILE_NOT_FOUND;\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code,\n                                             \"Failed to start command: %s\",\n                                             error->message);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_id_read_data)\n    instance_id_read_data->pid = pid;\n\n  pid_data = g_new0 (PidData, 1);\n  pid_data->pid = pid;\n  pid_data->client = g_strdup (g_dbus_method_invocation_get_sender (invocation));\n  pid_data->watch_bus = (arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0;\n  pid_data->expose_or_share_pids = (expose_pids || share_pids);\n  pid_data->child_watch = g_child_watch_add_full (G_PRIORITY_DEFAULT,\n                                                  pid,\n                                                  child_watch_died,\n                                                  pid_data,\n                                                  NULL);\n\n  g_debug (\"Client Pid is %d\", pid_data->pid);\n\n  g_hash_table_replace (client_pid_data_hash, GUINT_TO_POINTER (pid_data->pid),\n                        pid_data);\n\n  portal_flatpak_complete_spawn (object, invocation, NULL, pid);\n  return G_DBUS_METHOD_INVOCATION_HANDLED;\n}", "func_hash": 205356347611707551672955892565169493148, "file_name": "flatpak-portal.c", "file_hash": 43792508612396091243647173065704153095, "cwe": ["CWE-74"], "cve": "CVE-2021-21261", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. A bug was discovered in the `flatpak-portal` service that can allow sandboxed applications to execute arbitrary code on the host system (a sandbox escape). This sandbox-escape bug is present in versions from 0.11.4 and before fixed versions 1.8.5 and 1.10.0. The Flatpak portal D-Bus service (`flatpak-portal`, also known by its D-Bus service name `org.freedesktop.portal.Flatpak`) allows apps in a Flatpak sandbox to launch their own subprocesses in a new sandbox instance, either with the same security settings as the caller or with more restrictive security settings. For example, this is used in Flatpak-packaged web browsers such as Chromium to launch subprocesses that will process untrusted web content, and give those subprocesses a more restrictive sandbox than the browser itself. In vulnerable versions, the Flatpak portal service passes caller-specified environment variables to non-sandboxed processes on the host system, and in particular to the `flatpak run` command that is used to launch the new sandbox instance. A malicious or compromised Flatpak app could set environment variables that are trusted by the `flatpak run` command, and use them to execute arbitrary code that is not in a sandbox. As a workaround, this vulnerability can be mitigated by preventing the `flatpak-portal` service from starting, but that mitigation will prevent many Flatpak apps from working correctly. This is fixed in versions 1.8.5 and 1.10.0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-21261"}
{"idx": 205630, "project": "linux", "commit_id": "32452a3eb8b64e01e2be717f518c0be046975b9d", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/32452a3eb8b64e01e2be717f518c0be046975b9d", "commit_message": "io_uring: fix uninitialized field in rw io_kiocb\n\nio_rw_init_file does not initialize kiocb->private, so when iocb_bio_iopoll\nreads kiocb->private it can contain uninitialized data.\n\nFixes: 3e08773c3841 (\"block: switch polling to be bio based\")\nSigned-off-by: Joseph Ravichandran <jravi@mit.edu>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>", "target": 1, "func": "static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t/*\n\t * If the file is marked O_NONBLOCK, still allow retry for it if it\n\t * supports async. Otherwise it's impossible to use O_NONBLOCK files\n\t * reliably. If not, or it IOCB_NOWAIT is set, don't retry.\n\t */\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\n\treturn 0;\n}", "func_hash": 85149610434779656690730201934331639704, "file_name": "io_uring.c", "file_hash": 148301731450961138992553369142373286456, "cwe": ["CWE-94"], "cve": "CVE-2022-29968", "cve_desc": "An issue was discovered in the Linux kernel through 5.17.5. io_rw_init_file in fs/io_uring.c lacks initialization of kiocb->private.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-29968"}
{"idx": 96942, "project": "Chrome", "commit_id": "3c1864079c441ea2e08f882acaaf441f78a6de3d", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/3c1864079c441ea2e08f882acaaf441f78a6de3d", "commit_message": "None", "target": 0, "func": "bool decode(ArgumentDecoder* decoder, RetainPtr<CFTypeRef>& result)\n{\n    CFType type;\n    if (!decoder->decodeEnum(type))\n        return false;\n\n    switch (type) {\n    case CFArray: {\n        RetainPtr<CFArrayRef> array;\n        if (!decode(decoder, array))\n            return false;\n        result.adoptCF(array.leakRef());\n        return true;\n    }\n    case CFBoolean: {\n        RetainPtr<CFBooleanRef> boolean;\n        if (!decode(decoder, boolean))\n            return false;\n        result.adoptCF(boolean.leakRef());\n        return true;\n    }\n    case CFData: {\n        RetainPtr<CFDataRef> data;\n        if (!decode(decoder, data))\n            return false;\n        result.adoptCF(data.leakRef());\n        return true;\n    }\n    case CFDate: {\n        RetainPtr<CFDateRef> date;\n        if (!decode(decoder, date))\n            return false;\n        result.adoptCF(date.leakRef());\n        return true;\n    }\n    case CFDictionary: {\n        RetainPtr<CFDictionaryRef> dictionary;\n        if (!decode(decoder, dictionary))\n            return false;\n        result.adoptCF(dictionary.leakRef());\n        return true;\n    }\n    case CFNull:\n        result.adoptCF(kCFNull);\n        return true;\n    case CFNumber: {\n        RetainPtr<CFNumberRef> number;\n        if (!decode(decoder, number))\n            return false;\n        result.adoptCF(number.leakRef());\n        return true;\n    }\n    case CFString: {\n        RetainPtr<CFStringRef> string;\n        if (!decode(decoder, string))\n            return false;\n        result.adoptCF(string.leakRef());\n        return true;\n    }\n    case CFURL: {\n        RetainPtr<CFURLRef> url;\n        if (!decode(decoder, url))\n            return false;\n        result.adoptCF(url.leakRef());\n        return true;\n    }\n#if PLATFORM(MAC)\n    case SecCertificate: {\n        RetainPtr<SecCertificateRef> certificate;\n        if (!decode(decoder, certificate))\n            return false;\n        result.adoptCF(certificate.leakRef());\n        return true;\n    }\n    case SecKeychainItem: {\n        RetainPtr<SecKeychainItemRef> keychainItem;\n        if (!decode(decoder, keychainItem))\n            return false;\n        result.adoptCF(keychainItem.leakRef());\n        return true;\n    }\n#endif\n    case Null:\n        result = tokenNullTypeRef();\n        return true;\n    case Unknown:\n        ASSERT_NOT_REACHED();\n        return false;\n    }\n\n    return false;\n}\n", "func_hash": 245579797449716001356193440894924004354, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 218785, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  const unsigned char\n    *p;\n\n  IndexPacket\n    *indexes;\n\n  PixelPacket\n    *q;\n\n  ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  unsigned short\n    nibble;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (PixelPacket *) NULL)\n    return MagickFalse;\n  indexes=GetAuthenticIndexQueue(image);\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);\n        q++;\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit=0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,\n            (((unsigned char) ((ssize_t) pixel)) & (0x01 << (7-bit))) != 0 ? 0 :\n            QuantumRange,q++,indexes,x++);\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "func_hash": 177518249272594340059836567736761123364, "file_name": "psd.c", "file_hash": 226732625250511916284298083592366716300, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 213513, "project": "ImageMagick", "commit_id": "3d71aa8265ffaaf686021a6fbd54c037f71ee3a2", "project_url": "https://github.com/ImageMagick/ImageMagick", "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/3d71aa8265ffaaf686021a6fbd54c037f71ee3a2", "commit_message": "https://github.com/ImageMagick/ImageMagick/issues/1739", "target": 1, "func": "static inline void ConvertLuvToXYZ(const double L,const double u,const double v,\n  double *X,double *Y,double *Z)\n{\n  assert(X != (double *) NULL);\n  assert(Y != (double *) NULL);\n  assert(Z != (double *) NULL);\n  if (L > (CIEK*CIEEpsilon))\n    *Y=(double) pow((L+16.0)/116.0,3.0);\n  else\n    *Y=L/CIEK;\n  *X=((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+\n    5.0*(*Y))/((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/\n    3.0)-(-1.0/3.0));\n  *Z=(*X*(((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-\n    5.0*(*Y);\n}", "func_hash": 251636738386254214072120454540191627299, "file_name": "None", "file_hash": null, "cwe": ["CWE-369"], "cve": "CVE-2020-27773", "cve_desc": "A flaw was found in ImageMagick in MagickCore/gem-private.h. An attacker who submits a crafted file that is processed by ImageMagick could trigger undefined behavior in the form of values outside the range of type `unsigned char` or division by zero. This would most likely lead to an impact to application availability, but could potentially cause other problems related to undefined behavior. This flaw affects ImageMagick versions prior to 7.0.9-0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-27773"}
{"idx": 201382, "project": "gerbv", "commit_id": "672214abb47a802fc000125996e6e0a46c623a4e", "project_url": "https://github.com/gerbv/gerbv", "commit_url": "https://github.com/gerbv/gerbv/commit/672214abb47a802fc000125996e6e0a46c623a4e", "commit_message": "Add test to demonstrate buffer overrun", "target": 1, "func": "drill_parse_T_code(gerb_file_t *fd, drill_state_t *state,\n\t\t\tgerbv_image_t *image, ssize_t file_line)\n{\n    int tool_num;\n    gboolean done = FALSE;\n    int temp;\n    double size;\n    gerbv_drill_stats_t *stats = image->drill_stats;\n    gerbv_aperture_t *apert;\n    gchar *tmps;\n    gchar *string;\n\n    dprintf(\"---> entering %s()...\\n\", __FUNCTION__);\n\n    /* Sneak a peek at what's hiding after the 'T'. Ugly fix for\n       broken headers from Orcad, which is crap */\n    temp = gerb_fgetc(fd);\n    dprintf(\"  Found a char '%s' (0x%02x) after the T\\n\",\n\t    gerbv_escape_char(temp), temp);\n    \n    /* might be a tool tool change stop switch on/off*/\n    if((temp == 'C') && ((fd->ptr + 2) < fd->datalen)){\n    \tif(gerb_fgetc(fd) == 'S'){\n    \t    if (gerb_fgetc(fd) == 'T' ){\n    \t  \tfd->ptr -= 4;\n    \t  \ttmps = get_line(fd++);\n    \t  \tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_NOTE, -1,\n\t\t\t_(\"Tool change stop switch found \\\"%s\\\" \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\ttmps, file_line, fd->filename);\n\t  \tg_free (tmps);\n\n\t  \treturn -1;\n\t    }\n\t    gerb_ungetc(fd);\n\t}\n\tgerb_ungetc(fd);\n    }\n\n    if( !(isdigit(temp) != 0 || temp == '+' || temp =='-') ) {\n\tif(temp != EOF) {\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t   _(\"OrCAD bug: Junk text found in place of tool definition\"));\n\t    tmps = get_line(fd);\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t    _(\"Junk text \\\"%s\\\" \"\n\t\t\t\"at line %ld in file \\\"%s\\\"\"),\n\t\t    tmps, file_line, fd->filename);\n\t    g_free (tmps);\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t\t\t  _(\"Ignoring junk text\"));\n\t}\n\treturn -1;\n    }\n    gerb_ungetc(fd);\n\n    tool_num = (int) gerb_fgetint(fd, NULL);\n    dprintf (\"  Handling tool T%d at line %ld\\n\", tool_num, file_line);\n\n    if (tool_num == 0) \n\treturn tool_num; /* T00 is a command to unload the drill */\n\n    if (tool_num < TOOL_MIN || tool_num >= TOOL_MAX) {\n\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t_(\"Out of bounds drill number %d \"\n\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\ttool_num, file_line, fd->filename);\n    }\n\n    /* Set the current tool to the correct one */\n    state->current_tool = tool_num;\n    apert = image->aperture[tool_num];\n\n    /* Check for a size definition */\n    temp = gerb_fgetc(fd);\n\n    /* This bit of code looks for a tool definition by scanning for strings\n     * of form TxxC, TxxF, TxxS.  */\n    while (!done) {\n\tswitch((char)temp) {\n\tcase 'C':\n\t    size = read_double(fd, state->header_number_format, GERBV_OMIT_ZEROS_TRAILING, state->decimals);\n\t    dprintf (\"  Read a size of %g\\n\", size);\n\n\t    if (state->unit == GERBV_UNIT_MM) {\n\t\tsize /= 25.4;\n\t    } else if(size >= 4.0) {\n\t\t/* If the drill size is >= 4 inches, assume that this\n\t\t   must be wrong and that the units are mils.\n\t\t   The limit being 4 inches is because the smallest drill\n\t\t   I've ever seen used is 0,3mm(about 12mil). Half of that\n\t\t   seemed a bit too small a margin, so a third it is */\n\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t\t_(\"Read a drill of diameter %g inches \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\t    size, file_line, fd->filename);\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t\t_(\"Assuming units are mils\"));\n\t\tsize /= 1000.0;\n\t    }\n\n\t    if (size <= 0. || size >= 10000.) {\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t\t_(\"Unreasonable drill size %g found for drill %d \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\t    size, tool_num, file_line, fd->filename);\n\t    } else {\n\t\tif (apert != NULL) {\n\t\t    /* allow a redefine of a tool only if the new definition is exactly the same.\n\t\t     * This avoid lots of spurious complaints with the output of some cad\n\t\t     * tools while keeping complaints if there is a true problem\n\t\t     */\n\t\t    if (apert->parameter[0] != size\n\t\t    ||  apert->type != GERBV_APTYPE_CIRCLE\n\t\t    ||  apert->nuf_parameters != 1\n\t\t    ||  apert->unit != GERBV_UNIT_INCH) {\n\n\t\t\tgerbv_stats_printf(stats->error_list,\n\t\t\t\tGERBV_MESSAGE_ERROR, -1,\n\t\t\t\t_(\"Found redefinition of drill %d \"\n\t\t\t\t\"at line %ld in file \\\"%s\\\"\"),\n\t\t\t\ttool_num, file_line, fd->filename);\n\t\t    }\n\t\t} else {\n\t\t    apert = image->aperture[tool_num] =\n\t\t\t\t\t\tg_new0(gerbv_aperture_t, 1);\n\t\t    if (apert == NULL)\n\t\t\tGERB_FATAL_ERROR(\"malloc tool failed in %s()\",\n\t\t\t\t\t__FUNCTION__);\n\n\t\t    /* There's really no way of knowing what unit the tools\n\t\t       are defined in without sneaking a peek in the rest of\n\t\t       the file first. That's done in drill_guess_format() */\n\t\t    apert->parameter[0] = size;\n\t\t    apert->type = GERBV_APTYPE_CIRCLE;\n\t\t    apert->nuf_parameters = 1;\n\t\t    apert->unit = GERBV_UNIT_INCH;\n\t\t}\n\t    }\n\t    \n\t    /* Add the tool whose definition we just found into the list\n\t     * of tools for this layer used to generate statistics. */\n\t    stats = image->drill_stats;\n\t    string = g_strdup_printf(\"%s\", (state->unit == GERBV_UNIT_MM ? _(\"mm\") : _(\"inch\")));\n\t    drill_stats_add_to_drill_list(stats->drill_list, \n\t\t\t\t\t  tool_num, \n\t\t\t\t\t  state->unit == GERBV_UNIT_MM ? size*25.4 : size, \n\t\t\t\t\t  string);\n\t    g_free(string);\n\t    break;\n\n\tcase 'F':\n\tcase 'S' :\n\t    /* Silently ignored. They're not important. */\n\t    gerb_fgetint(fd, NULL);\n\t    break;\n\n\tdefault:\n\t    /* Stop when finding anything but what's expected\n\t       (and put it back) */\n\t    gerb_ungetc(fd);\n\t    done = TRUE;\n\t    break;\n\t}  /* switch((char)temp) */\n\n\ttemp = gerb_fgetc(fd);\n\tif (EOF == temp) {\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t    _(\"Unexpected EOF encountered in header of \"\n\t\t\t\"drill file \\\"%s\\\"\"), fd->filename);\n\n\t/* Restore new line character for processing */\n\tif ('\\n' == temp || '\\r' == temp)\n\t    gerb_ungetc(fd);\n\t}\n    }   /* while(!done) */  /* Done looking at tool definitions */\n\n    /* Catch the tools that aren't defined.\n       This isn't strictly a good thing, but at least something is shown */\n    if (apert == NULL) {\n        double dia;\n\n\tapert = image->aperture[tool_num] = g_new0(gerbv_aperture_t, 1);\n\tif (apert == NULL)\n\t    GERB_FATAL_ERROR(\"malloc tool failed in %s()\", __FUNCTION__);\n\n        /* See if we have the tool table */\n        dia = gerbv_get_tool_diameter(tool_num);\n        if (dia <= 0) {\n            /*\n             * There is no tool. So go out and make some.\n             * This size calculation is, of course, totally bogus.\n             */\n            dia = (double)(16 + 8 * tool_num) / 1000;\n            /*\n             * Oooh, this is sooo ugly. But some CAD systems seem to always\n             * use T00 at the end of the file while others that don't have\n             * tool definitions inside the file never seem to use T00 at all.\n             */\n            if (tool_num != 0) {\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t\t_(\"Tool %02d used without being defined \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\ttool_num, file_line, fd->filename);\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t\t_(\"Setting a default size of %g\\\"\"), dia);\n            }\n\t}\n\n\tapert->type = GERBV_APTYPE_CIRCLE;\n\tapert->nuf_parameters = 1;\n\tapert->parameter[0] = dia;\n\n\t/* Add the tool whose definition we just found into the list\n\t * of tools for this layer used to generate statistics. */\n\tif (tool_num != 0) {  /* Only add non-zero tool nums.  \n\t\t\t       * Zero = unload command. */\n\t    stats = image->drill_stats;\n\t    string = g_strdup_printf(\"%s\", \n\t\t\t\t     (state->unit == GERBV_UNIT_MM ? _(\"mm\") : _(\"inch\")));\n\t    drill_stats_add_to_drill_list(stats->drill_list, \n\t\t\t\t\t  tool_num, \n\t\t\t\t\t  state->unit == GERBV_UNIT_MM ? dia*25.4 : dia,\n\t\t\t\t\t  string);\n\t    g_free(string);\n\t}\n    } /* if(image->aperture[tool_num] == NULL) */\t\n    \n    dprintf(\"<----  ...leaving %s()\\n\", __FUNCTION__);\n\n    return tool_num;\n} /* drill_parse_T_code() */", "func_hash": 185752158214328372341115505036759500651, "file_name": "drill.c", "file_hash": 62463866492734341751893387181625909179, "cwe": ["CWE-787"], "cve": "CVE-2021-40391", "cve_desc": "An out-of-bounds write vulnerability exists in the drill format T-code tool number functionality of Gerbv 2.7.0, dev (commit b5f1eacd), and the forked version of Gerbv (commit 71493260). A specially-crafted drill file can lead to code execution. An attacker can provide a malicious file to trigger this vulnerability.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40391"}
{"idx": 220101, "project": "linux", "commit_id": "ab0fc21bc7105b54bafd85bd8b82742f9e68898a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/ab0fc21bc7105b54bafd85bd8b82742f9e68898a", "commit_message": "Revert \"NFSv4: Handle the special Linux file open access mode\"\n\nThis reverts commit 44942b4e457beda00981f616402a1a791e8c616e.\n\nAfter secondly opening a file with O_ACCMODE|O_DIRECT flags,\nnfs4_valid_open_stateid() will dereference NULL nfs4_state when lseek().\n\nReproducer:\n  1. mount -t nfs -o vers=4.2 $server_ip:/ /mnt/\n  2. fd = open(\"/mnt/file\", O_ACCMODE|O_DIRECT|O_CREAT)\n  3. close(fd)\n  4. fd = open(\"/mnt/file\", O_ACCMODE|O_DIRECT)\n  5. lseek(fd)\n\nReported-by: Lyu Tao <tao.lyu@epfl.ch>\nSigned-off-by: ChenXiaoSong <chenxiaosong2@huawei.com>\nSigned-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>", "target": 0, "func": "static int nfs4_setlease(struct file *file, long arg, struct file_lock **lease,\n\t\t\t void **priv)\n{\n\treturn nfs4_proc_setlease(file, arg, lease, priv);\n}", "func_hash": 328644775258974346383692955835990795605, "file_name": "nfs4file.c", "file_hash": 19160442996144037090827134285929888626, "cwe": ["CWE-909"], "cve": "CVE-2022-24448", "cve_desc": "An issue was discovered in fs/nfs/dir.c in the Linux kernel before 5.16.5. If an application sets the O_DIRECTORY flag, and tries to open a regular file, nfs_atomic_open() performs a regular lookup. If a regular file is found, ENOTDIR should occur, but the server instead returns uninitialized data in the file descriptor.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-24448"}
{"idx": 195040, "project": "tensorflow", "commit_id": "e21af685e1828f7ca65038307df5cc06de4479e8", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/e21af685e1828f7ca65038307df5cc06de4479e8", "commit_message": "Fix Null-pointer dereference in BuildXlaCompilationCache\n\nIf ConfigProto is not used, then use the default settings which is to allow all devices.\n\nPiperOrigin-RevId: 420391800\nChange-Id: I88161ad7042990aef678e77b597a2fb2c8f815be", "target": 1, "func": "Status BuildXlaCompilationCache(DeviceBase* device, FunctionLibraryRuntime* flr,\n                                const XlaPlatformInfo& platform_info,\n                                XlaCompilationCache** cache) {\n  if (platform_info.xla_device_metadata()) {\n    *cache = new XlaCompilationCache(\n        platform_info.xla_device_metadata()->client(),\n        platform_info.xla_device_metadata()->jit_device_type());\n    return Status::OK();\n  }\n\n  auto platform =\n      se::MultiPlatformManager::PlatformWithId(platform_info.platform_id());\n  if (!platform.ok()) {\n    return platform.status();\n  }\n\n  StatusOr<xla::Compiler*> compiler_for_platform =\n      xla::Compiler::GetForPlatform(platform.ValueOrDie());\n  if (!compiler_for_platform.ok()) {\n    // In some rare cases (usually in unit tests with very small clusters) we\n    // may end up transforming an XLA cluster with at least one GPU operation\n    // (which would normally force the cluster to be compiled using XLA:GPU)\n    // into an XLA cluster with no GPU operations (i.e. containing only CPU\n    // operations).  Such a cluster can fail compilation (in way that\n    // MarkForCompilation could not have detected) if the CPU JIT is not linked\n    // in.\n    //\n    // So bail out of _XlaCompile in this case, and let the executor handle the\n    // situation for us.\n    const Status& status = compiler_for_platform.status();\n    if (status.code() == error::NOT_FOUND) {\n      return errors::Unimplemented(\"Could not find compiler for platform \",\n                                   platform.ValueOrDie()->Name(), \": \",\n                                   status.ToString());\n    }\n  }\n\n  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n\n  string allowed_gpus =\n      flr->config_proto()->gpu_options().visible_device_list();\n  TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                      ParseVisibleDeviceList(allowed_gpus));\n  client_options.set_allowed_devices(gpu_ids);\n\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }\n  const XlaOpRegistry::DeviceRegistration* registration;\n  if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),\n                                           &registration)) {\n    return errors::InvalidArgument(\"No JIT device registered for \",\n                                   platform_info.device_type().type());\n  }\n  *cache = new XlaCompilationCache(\n      client.ValueOrDie(), DeviceType(registration->compilation_device_name));\n  return Status::OK();\n}", "func_hash": 179065639871904945359341382009364285020, "file_name": "xla_platform_info.cc", "file_hash": 171804916137745205288117058026592469555, "cwe": ["CWE-476"], "cve": "CVE-2022-23595", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. When building an XLA compilation cache, if default settings are used, TensorFlow triggers a null pointer dereference. In the default scenario, all devices are allowed, so `flr->config_proto` is `nullptr`. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23595"}
{"idx": 200379, "project": "radare2", "commit_id": "48f0ea79f99174fb0a62cb2354e13496ce5b7c44", "project_url": "https://github.com/radare/radare2", "commit_url": "https://github.com/radareorg/radare2/commit/48f0ea79f99174fb0a62cb2354e13496ce5b7c44", "commit_message": "Fix null deref in ne parser ##crash\n\n* Reported by @cnitlrt via huntr.dev\n* BountyID: d8b6d239-6d7b-4783-b26b-5be848c01aa1/\n* Reproducer: nenull", "target": 1, "func": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}", "func_hash": 32265811031369210493685487313253460681, "file_name": "ne.c", "file_hash": 158187364999589473605822811150926540610, "cwe": ["CWE-476"], "cve": "CVE-2022-1382", "cve_desc": "NULL Pointer Dereference in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is capable of making the radare2 crash, thus affecting the availability of the system.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1382"}
{"idx": 220024, "project": "tensorflow", "commit_id": "a68f68061e263a88321c104a6c911fe5598050a8", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/a68f68061e263a88321c104a6c911fe5598050a8", "commit_message": "Replace faulty overflow check with a builder for `TensorShape`.\n\nPrevents an integer overflow that was not caught before.\n\nPiperOrigin-RevId: 415381595\nChange-Id: I76585ddedc912bd9f4a390aeafa8e2ced1a28863", "target": 0, "func": "  explicit AddManySparseToTensorsMapOp(OpKernelConstruction* context)\n      : SparseTensorAccessingOp(context) {}", "func_hash": 272673574002997572865080479294978697809, "file_name": "sparse_tensors_map_ops.cc", "file_hash": 224775123349374780251651202891389866533, "cwe": ["CWE-190"], "cve": "CVE-2022-23568", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `AddManySparseToTensorsMap` is vulnerable to an integer overflow which results in a `CHECK`-fail when building new `TensorShape` objects (so, an assert failure based denial of service). We are missing some validation on the shapes of the input tensors as well as directly constructing a large `TensorShape` with user-provided dimensions. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23568"}
{"idx": 196316, "project": "barebox", "commit_id": "0a9f9a7410681e55362f8311537ebc7be9ad0fbe", "project_url": "https://github.com/saschahauer/barebox", "commit_url": "https://github.com/saschahauer/barebox/commit/0a9f9a7410681e55362f8311537ebc7be9ad0fbe", "commit_message": "crypto: digest: use crypto_memneq()\n\nWhen verifying a digest it is important not to leak timing information\nthrough memcmp(). Use crypto_memneq() instead.\n\nSigned-off-by: Sascha Hauer <s.hauer@pengutronix.de>", "target": 1, "func": "int digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\n\ttmp = xmalloc(len);\n\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\n\tret = memcmp(md, tmp, len);\n\tret = ret ? -EINVAL : 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}", "func_hash": 71480685616976545176363965575731858659, "file_name": "digest.c", "file_hash": 309636649404648894565051311749383985179, "cwe": ["CWE-200"], "cve": "CVE-2021-37847", "cve_desc": "crypto/digest.c in Pengutronix barebox through 2021.07.0 leaks timing information because memcmp is used during digest verification.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-37847"}
{"idx": 221164, "project": "gpac", "commit_id": "a69b567b8c95c72f9560c873c5ab348be058f340", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340", "commit_message": "fixed #1895", "target": 0, "func": "GF_Err gf_odf_write_descriptor_list_filter(GF_BitStream *bs, GF_List *descList, u8 only_tag)\n{\n\tGF_Err e;\n\tu32 count, i;\n\n\tif (! descList) return GF_OK;\n\tcount = gf_list_count(descList);\n\tfor ( i = 0; i < count; i++ ) {\n\t\tGF_Descriptor *tmp = (GF_Descriptor*)gf_list_get(descList, i);\n\t\tif (tmp && (tmp->tag==only_tag) ) {\n\t\t\te = gf_odf_write_descriptor(bs, tmp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\treturn GF_OK;\n}", "func_hash": 272810548935966941391437336493507405026, "file_name": "descriptors.c", "file_hash": 86476492964393375980272696403064975409, "cwe": ["CWE-415"], "cve": "CVE-2021-40571", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40571"}
{"idx": 96957, "project": "Chrome", "commit_id": "3c1864079c441ea2e08f882acaaf441f78a6de3d", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/3c1864079c441ea2e08f882acaaf441f78a6de3d", "commit_message": "None", "target": 0, "func": "void encode(ArgumentEncoder* encoder, CFNumberRef number)\n{\n    CFNumberType numberType = CFNumberGetType(number);\n\n    Vector<uint8_t> buffer(CFNumberGetByteSize(number));\n    bool result = CFNumberGetValue(number, numberType, buffer.data());\n    ASSERT_UNUSED(result, result);\n\n    encoder->encodeEnum(numberType);\n    encoder->encodeVariableLengthByteArray(buffer);\n}\n", "func_hash": 155862216858219035008515243988693306465, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90903, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "void ClientUsageTracker::OnSpecialStoragePolicyChanged() {\n  DCHECK(CalledOnValidThread());\n  global_unlimited_usage_is_valid_ = false;\n}\n", "func_hash": 221448258899107311035849444155641135260, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 195029, "project": "tensorflow", "commit_id": "c99d98cd189839dcf51aee94e7437b54b31f8abd", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/c99d98cd189839dcf51aee94e7437b54b31f8abd", "commit_message": "Handle invalid inputs instead of crashing.\n\nPiperOrigin-RevId: 409549744\nChange-Id: I7f5935b34b53f7e426a5462fcc027bdbf5dcda24", "target": 1, "func": "void Node::RunForwardTypeInference() {\n  VLOG(4) << \"Forward type inference: \" << props_->node_def.DebugString();\n\n  if (props_->fwd_type_fn == nullptr) {\n    return;\n  }\n\n  std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);\n  std::vector<int> input_idx(props_->input_types.size(), 0);\n  for (const auto& edge : in_edges_) {\n    if (edge->IsControlEdge()) {\n      continue;\n    }\n    DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();\n    int i = edge->dst_input();\n    input_nodes.at(i) = edge->src();\n    input_idx.at(i) = edge->src_output();\n  }\n\n  // Note: technically, we could use a very generic type when some of the inputs\n  // are unknown. But there is an expectation that a node will have complete\n  // inputs soon, so updating intermediate types is largely unnecessary.\n\n  for (const auto* node : input_nodes) {\n    if (node == nullptr) {\n      // Incomplete inputs, bail.\n      ClearTypeInfo();\n      return;\n    }\n  }\n\n  static FullTypeDef* no_type = new FullTypeDef();\n\n  std::vector<std::reference_wrapper<const FullTypeDef>> input_types;\n  for (int i = 0; i < input_nodes.size(); i++) {\n    const auto* node = input_nodes[i];\n    if (node->def().has_experimental_type()) {\n      const auto& node_t = node->def().experimental_type();\n      if (node_t.type_id() != TFT_UNSET) {\n        int ix = input_idx[i];\n        DCHECK(ix < node_t.args_size())\n            << \"input \" << i << \" should have an output \" << ix\n            << \" but instead only has \" << node_t.args_size()\n            << \" outputs: \" << node_t.DebugString();\n        input_types.emplace_back(node_t.args(ix));\n      } else {\n        input_types.emplace_back(*no_type);\n      }\n    } else {\n      // Incomplete inputs, bail.\n      ClearTypeInfo();\n      return;\n    }\n  }\n\n  const auto infer_type = props_->fwd_type_fn(input_types);\n  const FullTypeDef infer_typedef = infer_type.ValueOrDie();\n  if (infer_typedef.type_id() != TFT_UNSET) {\n    MaybeCopyOnWrite();\n    *(props_->node_def.mutable_experimental_type()) = infer_typedef;\n  }\n}", "func_hash": 285691869172413131662679092330979772991, "file_name": "graph.cc", "file_hash": 172099243927919341591512227523808328051, "cwe": ["CWE-125"], "cve": "CVE-2022-23592", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. TensorFlow's type inference can cause a heap out of bounds read as the bounds checking is done in a `DCHECK` (which is a no-op during production). An attacker can control the `input_idx` variable such that `ix` would be larger than the number of values in `node_t.args`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23592"}
{"idx": 220398, "project": "mruby", "commit_id": "27d1e0132a0804581dca28df042e7047fd27eaa8", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8", "commit_message": "array.c: fix `mrb_ary_shift_m` initialization bug.\n\nThe `ARY_PTR` and `ARY_LEN` may be modified in `mrb_get_args`.", "target": 0, "func": "join_ary(mrb_state *mrb, mrb_value ary, mrb_value sep, mrb_value list)\n{\n  mrb_int i;\n  mrb_value result, val, tmp;\n\n  /* check recursive */\n  for (i=0; i<RARRAY_LEN(list); i++) {\n    if (mrb_obj_equal(mrb, ary, RARRAY_PTR(list)[i])) {\n      mrb_raise(mrb, E_ARGUMENT_ERROR, \"recursive array join\");\n    }\n  }\n\n  mrb_ary_push(mrb, list, ary);\n\n  result = mrb_str_new_capa(mrb, 64);\n\n  for (i=0; i<RARRAY_LEN(ary); i++) {\n    if (i > 0 && !mrb_nil_p(sep)) {\n      mrb_str_cat_str(mrb, result, sep);\n    }\n\n    val = RARRAY_PTR(ary)[i];\n    switch (mrb_type(val)) {\n    case MRB_TT_ARRAY:\n    ary_join:\n      val = join_ary(mrb, val, sep, list);\n      /* fall through */\n\n    case MRB_TT_STRING:\n    str_join:\n      mrb_str_cat_str(mrb, result, val);\n      break;\n\n    default:\n      if (!mrb_immediate_p(val)) {\n        tmp = mrb_check_string_type(mrb, val);\n        if (!mrb_nil_p(tmp)) {\n          val = tmp;\n          goto str_join;\n        }\n        tmp = mrb_check_array_type(mrb, val);\n        if (!mrb_nil_p(tmp)) {\n          val = tmp;\n          goto ary_join;\n        }\n      }\n      val = mrb_obj_as_string(mrb, val);\n      goto str_join;\n    }\n  }\n\n  mrb_ary_pop(mrb, list);\n\n  return result;\n}", "func_hash": 109391772069289543428620158167834346409, "file_name": "array.c", "file_hash": 295526445825727607536544634773604768998, "cwe": ["CWE-476"], "cve": "CVE-2021-4188", "cve_desc": "mruby is vulnerable to NULL Pointer Dereference", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4188"}
{"idx": 195908, "project": "linux", "commit_id": "e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091", "commit_message": "btrfs: fix NULL pointer dereference when deleting device by invalid id\n\n[BUG]\nIt's easy to trigger NULL pointer dereference, just by removing a\nnon-existing device id:\n\n # mkfs.btrfs -f -m single -d single /dev/test/scratch1 \\\n\t\t\t\t     /dev/test/scratch2\n # mount /dev/test/scratch1 /mnt/btrfs\n # btrfs device remove 3 /mnt/btrfs\n\nThen we have the following kernel NULL pointer dereference:\n\n BUG: kernel NULL pointer dereference, address: 0000000000000000\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: 0000 [#1] PREEMPT SMP NOPTI\n CPU: 9 PID: 649 Comm: btrfs Not tainted 5.14.0-rc3-custom+ #35\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n RIP: 0010:btrfs_rm_device+0x4de/0x6b0 [btrfs]\n  btrfs_ioctl+0x18bb/0x3190 [btrfs]\n  ? lock_is_held_type+0xa5/0x120\n  ? find_held_lock.constprop.0+0x2b/0x80\n  ? do_user_addr_fault+0x201/0x6a0\n  ? lock_release+0xd2/0x2d0\n  ? __x64_sys_ioctl+0x83/0xb0\n  __x64_sys_ioctl+0x83/0xb0\n  do_syscall_64+0x3b/0x90\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n[CAUSE]\nCommit a27a94c2b0c7 (\"btrfs: Make btrfs_find_device_by_devspec return\nbtrfs_device directly\") moves the \"missing\" device path check into\nbtrfs_rm_device().\n\nBut btrfs_rm_device() itself can have case where it only receives\n@devid, with NULL as @device_path.\n\nIn that case, calling strcmp() on NULL will trigger the NULL pointer\ndereference.\n\nBefore that commit, we handle the \"missing\" case inside\nbtrfs_find_device_by_devspec(), which will not check @device_path at all\nif @devid is provided, thus no way to trigger the bug.\n\n[FIX]\nBefore calling strcmp(), also make sure @device_path is not NULL.\n\nFixes: a27a94c2b0c7 (\"btrfs: Make btrfs_find_device_by_devspec return btrfs_device directly\")\nCC: stable@vger.kernel.org # 5.4+\nReported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>\nReviewed-by: Anand Jain <anand.jain@oracle.com>\nSigned-off-by: Qu Wenruo <wqu@suse.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>", "target": 1, "func": "int btrfs_rm_device(struct btrfs_fs_info *fs_info, const char *device_path,\n\t\t    u64 devid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tu64 num_devices;\n\tint ret = 0;\n\n\tmutex_lock(&uuid_mutex);\n\n\tnum_devices = btrfs_num_devices(fs_info);\n\n\tret = btrfs_check_raid_min_devices(fs_info, num_devices - 1);\n\tif (ret)\n\t\tgoto out;\n\n\tdevice = btrfs_find_device_by_devspec(fs_info, devid, device_path);\n\n\tif (IS_ERR(device)) {\n\t\tif (PTR_ERR(device) == -ENOENT &&\n\t\t    strcmp(device_path, \"missing\") == 0)\n\t\t\tret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;\n\t\telse\n\t\t\tret = PTR_ERR(device);\n\t\tgoto out;\n\t}\n\n\tif (btrfs_pinned_by_swapfile(fs_info, device)) {\n\t\tbtrfs_warn_in_rcu(fs_info,\n\t\t  \"cannot remove device %s (devid %llu) due to active swapfile\",\n\t\t\t\t  rcu_str_deref(device->name), device->devid);\n\t\tret = -ETXTBSY;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {\n\t\tret = BTRFS_ERROR_DEV_TGT_REPLACE;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state) &&\n\t    fs_info->fs_devices->rw_devices == 1) {\n\t\tret = BTRFS_ERROR_DEV_ONLY_WRITABLE;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tlist_del_init(&device->dev_alloc_list);\n\t\tdevice->fs_devices->rw_devices--;\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t}\n\n\tmutex_unlock(&uuid_mutex);\n\tret = btrfs_shrink_device(device, 0);\n\tif (!ret)\n\t\tbtrfs_reada_remove_dev(device);\n\tmutex_lock(&uuid_mutex);\n\tif (ret)\n\t\tgoto error_undo;\n\n\t/*\n\t * TODO: the superblock still includes this device in its num_devices\n\t * counter although write_all_supers() is not locked out. This\n\t * could give a filesystem state which requires a degraded mount.\n\t */\n\tret = btrfs_rm_dev_item(device);\n\tif (ret)\n\t\tgoto error_undo;\n\n\tclear_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &device->dev_state);\n\tbtrfs_scrub_cancel_dev(device);\n\n\t/*\n\t * the device list mutex makes sure that we don't change\n\t * the device list while someone else is writing out all\n\t * the device supers. Whoever is writing all supers, should\n\t * lock the device list mutex before getting the number of\n\t * devices in the super block (super_copy). Conversely,\n\t * whoever updates the number of devices in the super block\n\t * (super_copy) should hold the device list mutex.\n\t */\n\n\t/*\n\t * In normal cases the cur_devices == fs_devices. But in case\n\t * of deleting a seed device, the cur_devices should point to\n\t * its own fs_devices listed under the fs_devices->seed.\n\t */\n\tcur_devices = device->fs_devices;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_del_rcu(&device->dev_list);\n\n\tcur_devices->num_devices--;\n\tcur_devices->total_devices--;\n\t/* Update total_devices of the parent fs_devices if it's seed */\n\tif (cur_devices != fs_devices)\n\t\tfs_devices->total_devices--;\n\n\tif (test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state))\n\t\tcur_devices->missing_devices--;\n\n\tbtrfs_assign_next_active_device(device, NULL);\n\n\tif (device->bdev) {\n\t\tcur_devices->open_devices--;\n\t\t/* remove sysfs entry */\n\t\tbtrfs_sysfs_remove_device(device);\n\t}\n\n\tnum_devices = btrfs_super_num_devices(fs_info->super_copy) - 1;\n\tbtrfs_set_super_num_devices(fs_info->super_copy, num_devices);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t/*\n\t * at this point, the device is zero sized and detached from\n\t * the devices list.  All that's left is to zero out the old\n\t * supers and free the device.\n\t */\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state))\n\t\tbtrfs_scratch_superblocks(fs_info, device->bdev,\n\t\t\t\t\t  device->name->str);\n\n\tbtrfs_close_bdev(device);\n\tsynchronize_rcu();\n\tbtrfs_free_device(device);\n\n\tif (cur_devices->open_devices == 0) {\n\t\tlist_del_init(&cur_devices->seed_list);\n\t\tclose_fs_devices(cur_devices);\n\t\tfree_fs_devices(cur_devices);\n\t}\n\nout:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n\nerror_undo:\n\tbtrfs_reada_undo_remove_dev(device);\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tlist_add(&device->dev_alloc_list,\n\t\t\t &fs_devices->alloc_list);\n\t\tdevice->fs_devices->rw_devices++;\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t}\n\tgoto out;\n}", "func_hash": 109862119097507194285189243526662049352, "file_name": "volumes.c", "file_hash": 327977751785202812455417482244318484271, "cwe": ["CWE-703"], "cve": "CVE-2021-3739", "cve_desc": "A NULL pointer dereference flaw was found in the btrfs_rm_device function in fs/btrfs/volumes.c in the Linux Kernel, where triggering the bug requires \u2018CAP_SYS_ADMIN\u2019. This flaw allows a local attacker to crash the system or leak kernel internal information. The highest threat from this vulnerability is to system availability.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3739"}
{"idx": 220220, "project": "tensorflow", "commit_id": "c99d98cd189839dcf51aee94e7437b54b31f8abd", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/c99d98cd189839dcf51aee94e7437b54b31f8abd", "commit_message": "Handle invalid inputs instead of crashing.\n\nPiperOrigin-RevId: 409549744\nChange-Id: I7f5935b34b53f7e426a5462fcc027bdbf5dcda24", "target": 0, "func": "void Graph::RemoveNode(Node* node) {\n  TF_DCHECK_OK(IsValidNode(node)) << node->DebugString();\n  DCHECK(!node->IsSource());\n  DCHECK(!node->IsSink());\n\n  // Remove any edges involving this node.\n  for (const Edge* e : node->in_edges_) {\n    CHECK_EQ(e->src_->out_edges_.erase(e), size_t{1});\n    edges_[e->id_] = nullptr;\n    RecycleEdge(e);\n    --num_edges_;\n  }\n  node->in_edges_.clear();\n  for (const Edge* e : node->out_edges_) {\n    CHECK_EQ(e->dst_->in_edges_.erase(e), size_t{1});\n    edges_[e->id_] = nullptr;\n    RecycleEdge(e);\n    --num_edges_;\n  }\n  node->out_edges_.clear();\n  ReleaseNode(node);\n}", "func_hash": 228141351483367580033080203910181495095, "file_name": "graph.cc", "file_hash": 172099243927919341591512227523808328051, "cwe": ["CWE-125"], "cve": "CVE-2022-23592", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. TensorFlow's type inference can cause a heap out of bounds read as the bounds checking is done in a `DCHECK` (which is a no-op during production). An attacker can control the `input_idx` variable such that `ix` would be larger than the number of values in `node_t.args`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23592"}
{"idx": 90155, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  const std::string& IPAddress() const { return ip_address_; }\n", "func_hash": 112572501574773710308430208778388548631, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 218763, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static void XSetTextColor(Display *display,const XWindowInfo *window_info,\n  const MagickStatusType raised)\n{\n  ssize_t\n    foreground,\n    matte;\n\n  if (window_info->depth == 1)\n    {\n      /*\n        Monochrome window.\n      */\n      if (raised)\n        (void) XSetForeground(display,window_info->widget_context,\n          XBlackPixel(display,window_info->screen));\n      else\n        (void) XSetForeground(display,window_info->widget_context,\n          XWhitePixel(display,window_info->screen));\n      return;\n    }\n  foreground=(ssize_t) XPixelIntensity(\n    &window_info->pixel_info->foreground_color);\n  matte=(ssize_t) XPixelIntensity(&window_info->pixel_info->matte_color);\n  if (MagickAbsoluteValue((int) (foreground-matte)) > (65535L >> 3))\n    (void) XSetForeground(display,window_info->widget_context,\n      window_info->pixel_info->foreground_color.pixel);\n  else\n    (void) XSetForeground(display,window_info->widget_context,\n      window_info->pixel_info->background_color.pixel);\n}", "func_hash": 191235699588292576786637483876108815664, "file_name": "widget.c", "file_hash": 31318598747823313517201273606802259325, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 101680, "project": "Chrome", "commit_id": "2bfb2b8299e2fb6a432390a93a99a85fed1d29c9", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/2bfb2b8299e2fb6a432390a93a99a85fed1d29c9", "commit_message": "None", "target": 0, "func": "bool WebProcessProxy::fullKeyboardAccessEnabled()\n{\n    return false;\n}\n", "func_hash": 304359859513965936787195250639141969459, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 221680, "project": "e2guardian", "commit_id": "eae46a7e2a57103aadca903c4a24cca94dc502a2", "project_url": "https://github.com/e2guardian/e2guardian", "commit_url": "https://github.com/e2guardian/e2guardian/commit/eae46a7e2a57103aadca903c4a24cca94dc502a2", "commit_message": "Fix bug #707 cert hostnames not being checked\n- only happened when openssl v1.1 is used", "target": 0, "func": "bool Socket::writeToSocket(const char *buff, int len, unsigned int flags, int timeout, bool check_first, bool honour_reloadconfig)\n{\n    if (len == 0)   // nothing to write\n        return true;\n    if (!isssl) {\n        return BaseSocket::writeToSocket(buff, len, flags, timeout, check_first, honour_reloadconfig);\n    }\n\n    int actuallysent = 0;\n    int sent;\n    while (actuallysent < len) {\n       if (check_first) {\n    //        try {\n                if(!breadyForOutput(timeout))\n                   return false;\n     //       } catch (std::exception &e) {\n      //          return false;\n       //     }\n        }\n        ERR_clear_error();\n        sent = SSL_write(ssl, buff + actuallysent, len - actuallysent);\n        if (sent < 0) {\n    //        if (errno == EINTR ) {\n    //            continue; // was interupted by signal so restart\n    //        }\n            s_errno = errno;\n            String serr(s_errno);\n            log_ssl_errors(\"ssl_write failed - error \",serr.c_str());\n            return false;\n        }\n        if (sent == 0) {\n            ishup = true;\n            return false; // other end is closed\n        }\n        actuallysent += sent;\n    }\n    return true;\n}", "func_hash": 28911988928573014114249853755251981164, "file_name": "Socket.cpp", "file_hash": 316707147744091371767800459911917453562, "cwe": ["CWE-295"], "cve": "CVE-2021-44273", "cve_desc": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-44273"}
{"idx": 162322, "project": "Chrome", "commit_id": "3c1864079c441ea2e08f882acaaf441f78a6de3d", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/3c1864079c441ea2e08f882acaaf441f78a6de3d", "commit_message": "None", "target": 0, "func": "bool decode(ArgumentDecoder* decoder, RetainPtr<CFURLRef>& result)\n{\n    RetainPtr<CFURLRef> baseURL;\n    bool hasBaseURL;\n    if (!decoder->decodeBool(hasBaseURL))\n        return false;\n    if (hasBaseURL) {\n        if (!decode(decoder, baseURL))\n            return false;\n    }\n\n    RetainPtr<CFStringRef> string;\n     if (!decode(decoder, string))\n         return false;\n \n#if PLATFORM(MAC)\n    // FIXME: Move this to ArgumentCodersCFMac.mm and change this file back to be C++\n    // instead of Objective-C++.\n    if (!CFStringGetLength(string.get())) {\n        // CFURL can't hold an empty URL, unlike NSURL.\n        result = reinterpret_cast<CFURLRef>([NSURL URLWithString:@\"\"]);\n        return true;\n    }\n#endif\n                    \n     CFURLRef url = CFURLCreateWithString(0, string.get(), baseURL.get());\n     if (!url)\n         return false;\n\n    result.adoptCF(url);\n    return true;\n}\n", "func_hash": 315018138351705334660192363324138616137, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 180233, "project": "Chrome", "commit_id": "6d067124e87295721c62a77f0610e4b37f6098ad", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/6d067124e87295721c62a77f0610e4b37f6098ad", "commit_message": "None", "target": 0, "func": "v8::Handle<v8::Value> V8ThrowException::createReferenceError(v8::Isolate* isolate, const String& message)\n{\n    return v8::Exception::ReferenceError(v8String(isolate, message.isNull() ? \"Reference error\" : message));\n}\n", "func_hash": 52290048754550229978658600205251663944, "file_name": "None", "file_hash": null, "cwe": [], "cve": "CVE-2015-1210", "cve_desc": "", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1210"}
{"idx": 221427, "project": "linux", "commit_id": "c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc", "commit_message": "KVM: nSVM: always intercept VMLOAD/VMSAVE when nested (CVE-2021-3656)\n\nIf L1 disables VMLOAD/VMSAVE intercepts, and doesn't enable\nVirtual VMLOAD/VMSAVE (currently not supported for the nested hypervisor),\nthen VMLOAD/VMSAVE must operate on the L1 physical memory, which is only\npossible by making L0 intercept these instructions.\n\nFailure to do so allowed the nested guest to run VMLOAD/VMSAVE unintercepted,\nand thus read/write portions of the host physical memory.\n\nFixes: 89c8a4984fc9 (\"KVM: SVM: Enable Virtual VMLOAD VMSAVE feature\")\n\nSuggested-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Maxim Levitsky <mlevitsk@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "target": 0, "func": "void nested_vmcb02_compute_g_pat(struct vcpu_svm *svm)\n{\n\tif (!svm->nested.vmcb02.ptr)\n\t\treturn;\n\n\t/* FIXME: merge g_pat from vmcb01 and vmcb12.  */\n\tsvm->nested.vmcb02.ptr->save.g_pat = svm->vmcb01.ptr->save.g_pat;\n}", "func_hash": 108634419986377851812988464464071916415, "file_name": "None", "file_hash": null, "cwe": ["CWE-862"], "cve": "CVE-2021-3656", "cve_desc": "A flaw was found in the KVM's AMD code for supporting SVM nested virtualization. The flaw occurs when processing the VMCB (virtual machine control block) provided by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation of the \"virt_ext\" field, this issue could allow a malicious L1 to disable both VMLOAD/VMSAVE intercepts and VLS (Virtual VMLOAD/VMSAVE) for the L2 guest. As a result, the L2 guest would be allowed to read/write physical pages of the host, resulting in a crash of the entire system, leak of sensitive data or potential guest-to-host escape.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3656"}
{"idx": 214358, "project": "clamav-devel", "commit_id": "224fee54dd6cd8933d7007331ec2bfca0398d4b4", "project_url": "https://github.com/vrtadmin/clamav-devel", "commit_url": "http://git.clamav.net/gitweb?p=clamav-devel.git;a=commit;h=224fee54dd6cd8933d7007331ec2bfca0398d4b4", "commit_message": "libclamav/mspack.c: fix Quantum decompressor (bb#1771)", "target": 1, "func": "int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) {\n  unsigned int frame_start, frame_end, window_posn, match_offset, range;\n  unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n  int i, j, selector, extra, sym, match_length, ret;\n  unsigned short H, L, C, symf;\n\n  register unsigned int bit_buffer;\n  register unsigned char bits_left;\n  unsigned char bits_needed, bit_run;\n\n  /* easy answers */\n  if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n  if (qtm->error) return qtm->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = qtm->o_end - qtm->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  QTM_RESTORE_BITS;\n  window = qtm->window;\n  window_posn = qtm->window_posn;\n  frame_start = qtm->frame_start;\n  H = qtm->H;\n  L = qtm->L;\n  C = qtm->C;\n\n  /* while we do not have enough decoded bytes in reserve: */\n  while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n\n    /* read header if necessary. Initialises H, L and C */\n    if (!qtm->header_read) {\n      H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n      qtm->header_read = 1;\n    }\n\n    /* decode more, at most up to to frame boundary */\n    frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n    if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n      frame_end = frame_start + QTM_FRAME_SIZE;\n    }\n\n    while (window_posn < frame_end) {\n      QTM_GET_SYMBOL(qtm->model7, selector);\n      if (selector < 4) {\n\tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n\t                        ((selector == 1) ? &qtm->model1 :\n\t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                   &qtm->model3));\n\tQTM_GET_SYMBOL((*mdl), sym);\n\twindow[window_posn++] = sym;\n      }\n      else {\n\tswitch (selector) {\n\tcase 4: /* selector 4 = fixed length match (3 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model4, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 3;\n\t  break;\n\n\tcase 5: /* selector 5 = fixed length match (4 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model5, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 4;\n\t  break;\n\n\tcase 6: /* selector 6 = variable length match */\n\t  QTM_GET_SYMBOL(qtm->model6len, sym);\n\t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n\t  match_length = qtm->length_base[sym] + extra + 5;\n\n\t  QTM_GET_SYMBOL(qtm->model6, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  break;\n\n\tdefault:\n\t  /* should be impossible, model7 can only return 0-6 */\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\trundest = &window[window_posn];\n\ti = match_length;\n\t/* does match offset wrap the window? */\n\tif (match_offset > window_posn) {\n\t  /* j = length from match offset to end of window */\n\t  j = match_offset - window_posn;\n\t  if (j > (int) qtm->window_size) {\n\t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n\t    return qtm->error = CL_EFORMAT;\n\t  }\n\t  runsrc = &window[qtm->window_size - j];\n\t  if (j < i) {\n\t    /* if match goes over the window edge, do two copy runs */\n\t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t    runsrc = window;\n\t  }\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\telse {\n\t  runsrc = rundest - match_offset;\n\t  if(i > (int) (qtm->window_size - window_posn))\n\t    i = qtm->window_size - window_posn;\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\twindow_posn += match_length;\n      }\n    } /* while (window_posn < frame_end) */\n\n    qtm->o_end = &window[window_posn];\n\n    /* another frame completed? */\n    if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n      if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n\tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n\treturn qtm->error = CL_EFORMAT;\n      }\n\n      /* re-align input */\n      if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n      do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n      qtm->header_read = 0;\n\n      /* window wrap? */\n      if (window_posn == qtm->window_size) {\n\t/* flush all currently stored data */\n\ti = (qtm->o_end - qtm->o_ptr);\n\tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n\t  return qtm->error = ret;\n\t}\n\tout_bytes -= i;\n\tqtm->o_ptr = &window[0];\n\tqtm->o_end = &window[0];\n\twindow_posn = 0;\n      }\n\n      frame_start = window_posn;\n    }\n\n  } /* while (more bytes needed) */\n\n  if (out_bytes) {\n    i = (int) out_bytes;\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr += i;\n  }\n\n  /* store local state */\n  QTM_STORE_BITS;\n  qtm->window_posn = window_posn;\n  qtm->frame_start = frame_start;\n  qtm->H = H;\n  qtm->L = L;\n  qtm->C = C;\n\n  return CL_SUCCESS;\n}", "func_hash": 291050376752284006088755347145639053650, "file_name": "mspack.c", "file_hash": 137114659534783781079186144852150621076, "cwe": ["CWE-20"], "cve": "CVE-2010-1311", "cve_desc": "The qtm_decompress function in libclamav/mspack.c in ClamAV before 0.96 allows remote attackers to cause a denial of service (memory corruption and application crash) via a crafted CAB archive that uses the Quantum (aka .Q) compression format.  NOTE: some of these details are obtained from third party information.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-1311"}
{"idx": 214160, "project": "linux", "commit_id": "75e5b4849b81e19e9efe1654b30d7f3151c33c2c", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/75e5b4849b81e19e9efe1654b30d7f3151c33c2c", "commit_message": "USB: gadget: validate interface OS descriptor requests\n\nStall the control endpoint in case provided index exceeds array size of\nMAX_CONFIG_INTERFACES or when the retrieved function pointer is null.\n\nSigned-off-by: Szymon Heidrich <szymon.heidrich@gmail.com>\nCc: stable@kernel.org\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 1, "func": "composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_request\t\t*req = cdev->req;\n\tint\t\t\t\tvalue = -EOPNOTSUPP;\n\tint\t\t\t\tstatus = 0;\n\tu16\t\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu8\t\t\t\tintf = w_index & 0xFF;\n\tu16\t\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\tstruct usb_function\t\t*f = NULL;\n\tu8\t\t\t\tendp;\n\n\tif (w_length > USB_COMP_EP0_BUFSIZ) {\n\t\tif (ctrl->bRequestType & USB_DIR_IN) {\n\t\t\t/* Cast away the const, we are going to overwrite on purpose. */\n\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n\n\t\t\t*temp = cpu_to_le16(USB_COMP_EP0_BUFSIZ);\n\t\t\tw_length = USB_COMP_EP0_BUFSIZ;\n\t\t} else {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* partial re-init of the response message; the function or the\n\t * gadget might need to intercept e.g. a control-OUT completion\n\t * when we delegate to it.\n\t */\n\treq->zero = 0;\n\treq->context = cdev;\n\treq->complete = composite_setup_complete;\n\treq->length = 0;\n\tgadget->ep0->driver_data = cdev;\n\n\t/*\n\t * Don't let non-standard requests match any of the cases below\n\t * by accident.\n\t */\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\n\t\tgoto unknown;\n\n\tswitch (ctrl->bRequest) {\n\n\t/* we handle all standard USB descriptors */\n\tcase USB_REQ_GET_DESCRIPTOR:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tswitch (w_value >> 8) {\n\n\t\tcase USB_DT_DEVICE:\n\t\t\tcdev->desc.bNumConfigurations =\n\t\t\t\tcount_configs(cdev, USB_DT_DEVICE);\n\t\t\tcdev->desc.bMaxPacketSize0 =\n\t\t\t\tcdev->gadget->ep0->maxpacket;\n\t\t\tif (gadget_is_superspeed(gadget)) {\n\t\t\t\tif (gadget->speed >= USB_SPEED_SUPER) {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0320);\n\t\t\t\t\tcdev->desc.bMaxPacketSize0 = 9;\n\t\t\t\t} else {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0210);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (gadget->lpm_capable)\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0201);\n\t\t\t\telse\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0200);\n\t\t\t}\n\n\t\t\tvalue = min(w_length, (u16) sizeof cdev->desc);\n\t\t\tmemcpy(req->buf, &cdev->desc, value);\n\t\t\tbreak;\n\t\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tdevice_qual(cdev);\n\t\t\tvalue = min_t(int, w_length,\n\t\t\t\tsizeof(struct usb_qualifier_descriptor));\n\t\t\tbreak;\n\t\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase USB_DT_CONFIG:\n\t\t\tvalue = config_desc(cdev, w_value);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_STRING:\n\t\t\tvalue = get_string(cdev, req->buf,\n\t\t\t\t\tw_index, w_value & 0xff);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_BOS:\n\t\t\tif (gadget_is_superspeed(gadget) ||\n\t\t\t    gadget->lpm_capable) {\n\t\t\t\tvalue = bos_desc(cdev);\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_DT_OTG:\n\t\t\tif (gadget_is_otg(gadget)) {\n\t\t\t\tstruct usb_configuration *config;\n\t\t\t\tint otg_desc_len = 0;\n\n\t\t\t\tif (cdev->config)\n\t\t\t\t\tconfig = cdev->config;\n\t\t\t\telse\n\t\t\t\t\tconfig = list_first_entry(\n\t\t\t\t\t\t\t&cdev->configs,\n\t\t\t\t\t\tstruct usb_configuration, list);\n\t\t\t\tif (!config)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tif (gadget->otg_caps &&\n\t\t\t\t\t(gadget->otg_caps->otg_rev >= 0x0200))\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg20_descriptor);\n\t\t\t\telse\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg_descriptor);\n\n\t\t\t\tvalue = min_t(int, w_length, otg_desc_len);\n\t\t\t\tmemcpy(req->buf, config->descriptors[0], value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* any number of configs can work */\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != 0)\n\t\t\tgoto unknown;\n\t\tif (gadget_is_otg(gadget)) {\n\t\t\tif (gadget->a_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP available\\n\");\n\t\t\telse if (gadget->a_alt_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP on another port\\n\");\n\t\t\telse\n\t\t\t\tVDBG(cdev, \"HNP inactive\\n\");\n\t\t}\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = set_config(cdev, ctrl, w_value);\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tif (cdev->config)\n\t\t\t*(u8 *)req->buf = cdev->config->bConfigurationValue;\n\t\telse\n\t\t\t*(u8 *)req->buf = 0;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\n\t/* function drivers must handle get/set altsetting */\n\tcase USB_REQ_SET_INTERFACE:\n\t\tif (ctrl->bRequestType != USB_RECIP_INTERFACE)\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If there's no get_alt() method, we know only altsetting zero\n\t\t * works. There is no need to check if set_alt() is not NULL\n\t\t * as we check this in usb_add_function().\n\t\t */\n\t\tif (w_value && !f->get_alt)\n\t\t\tbreak;\n\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = f->set_alt(f, w_index, w_value);\n\t\tif (value == USB_GADGET_DELAYED_STATUS) {\n\t\t\tDBG(cdev,\n\t\t\t \"%s: interface %d (%s) requested delayed status\\n\",\n\t\t\t\t\t__func__, intf, f->name);\n\t\t\tcdev->delayed_status++;\n\t\t\tDBG(cdev, \"delayed_status count %d\\n\",\n\t\t\t\t\tcdev->delayed_status);\n\t\t}\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_INTERFACE:\n\t\tif (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\t/* lots of interfaces only need altsetting zero... */\n\t\tvalue = f->get_alt ? f->get_alt(f, w_index) : 0;\n\t\tif (value < 0)\n\t\t\tbreak;\n\t\t*((u8 *)req->buf) = value;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tif (gadget_is_otg(gadget) && gadget->hnp_polling_support &&\n\t\t\t\t\t\t(w_index == OTG_STS_SELECTOR)) {\n\t\t\tif (ctrl->bRequestType != (USB_DIR_IN |\n\t\t\t\t\t\t\tUSB_RECIP_DEVICE))\n\t\t\t\tgoto unknown;\n\t\t\t*((u8 *)req->buf) = gadget->host_request_flag;\n\t\t\tvalue = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * USB 3.0 additions:\n\t\t * Function driver should handle get_status request. If such cb\n\t\t * wasn't supplied we respond with default value = 0\n\t\t * Note: function driver should supply such cb only for the\n\t\t * first interface of the function\n\t\t */\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tvalue = 2;\t/* This is the length of the get_status reply */\n\t\tput_unaligned_le16(0, req->buf);\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\tstatus = f->get_status ? f->get_status(f) : 0;\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tput_unaligned_le16(status & 0x0000ffff, req->buf);\n\t\tbreak;\n\t/*\n\t * Function drivers should handle SetFeature/ClearFeature\n\t * (FUNCTION_SUSPEND) request. function_suspend cb should be supplied\n\t * only for the first interface of the function\n\t */\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tswitch (w_value) {\n\t\tcase USB_INTRF_FUNC_SUSPEND:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tif (!f)\n\t\t\t\tbreak;\n\t\t\tvalue = 0;\n\t\t\tif (f->func_suspend)\n\t\t\t\tvalue = f->func_suspend(f, w_index >> 8);\n\t\t\tif (value < 0) {\n\t\t\t\tERROR(cdev,\n\t\t\t\t      \"func_suspend() returned error %d\\n\",\n\t\t\t\t      value);\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\nunknown:\n\t\t/*\n\t\t * OS descriptors handling\n\t\t */\n\t\tif (cdev->use_os_string && cdev->os_desc_config &&\n\t\t    (ctrl->bRequestType & USB_TYPE_VENDOR) &&\n\t\t    ctrl->bRequest == cdev->b_vendor_code) {\n\t\t\tstruct usb_configuration\t*os_desc_cfg;\n\t\t\tu8\t\t\t\t*buf;\n\t\t\tint\t\t\t\tinterface;\n\t\t\tint\t\t\t\tcount = 0;\n\n\t\t\treq = cdev->os_desc_req;\n\t\t\treq->context = cdev;\n\t\t\treq->complete = composite_setup_complete;\n\t\t\tbuf = req->buf;\n\t\t\tos_desc_cfg = cdev->os_desc_config;\n\t\t\tw_length = min_t(u16, w_length, USB_COMP_EP0_OS_DESC_BUFSIZ);\n\t\t\tmemset(buf, 0, w_length);\n\t\t\tbuf[5] = 0x01;\n\t\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\t\tcase USB_RECIP_DEVICE:\n\t\t\t\tif (w_index != 0x4 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\t/* Number of ext compat interfaces */\n\t\t\t\tcount = count_ext_compat(os_desc_cfg);\n\t\t\t\tbuf[8] = count;\n\t\t\t\tcount *= 24; /* 24 B/ext compat desc */\n\t\t\t\tcount += 16; /* header */\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x10) {\n\t\t\t\t\tvalue = fill_ext_compat(os_desc_cfg, buf);\n\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_RECIP_INTERFACE:\n\t\t\t\tif (w_index != 0x5 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tinterface = w_value & 0xFF;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\tcount = count_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le16(count, buf + 8);\n\t\t\t\tcount = len_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x0A) {\n\t\t\t\t\tvalue = fill_ext_prop(os_desc_cfg,\n\t\t\t\t\t\t\t      interface, buf);\n\t\t\t\t\tif (value >= 0)\n\t\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgoto check_value;\n\t\t}\n\n\t\tVDBG(cdev,\n\t\t\t\"non-core control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\n\t\t/* functions always handle their interfaces and endpoints...\n\t\t * punt other recipients (other, WUSB, ...) to the current\n\t\t * configuration code.\n\t\t */\n\t\tif (cdev->config) {\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list)\n\t\t\t\tif (f->req_match &&\n\t\t\t\t    f->req_match(f, ctrl, false))\n\t\t\t\t\tgoto try_fun_setup;\n\t\t} else {\n\t\t\tstruct usb_configuration *c;\n\t\t\tlist_for_each_entry(c, &cdev->configs, list)\n\t\t\t\tlist_for_each_entry(f, &c->functions, list)\n\t\t\t\t\tif (f->req_match &&\n\t\t\t\t\t    f->req_match(f, ctrl, true))\n\t\t\t\t\t\tgoto try_fun_setup;\n\t\t}\n\t\tf = NULL;\n\n\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\tcase USB_RECIP_INTERFACE:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tbreak;\n\n\t\tcase USB_RECIP_ENDPOINT:\n\t\t\tif (!cdev->config)\n\t\t\t\tbreak;\n\t\t\tendp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\t\tif (test_bit(endp, f->endpoints))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&f->list == &cdev->config->functions)\n\t\t\t\tf = NULL;\n\t\t\tbreak;\n\t\t}\ntry_fun_setup:\n\t\tif (f && f->setup)\n\t\t\tvalue = f->setup(f, ctrl);\n\t\telse {\n\t\t\tstruct usb_configuration\t*c;\n\n\t\t\tc = cdev->config;\n\t\t\tif (!c)\n\t\t\t\tgoto done;\n\n\t\t\t/* try current config's setup */\n\t\t\tif (c->setup) {\n\t\t\t\tvalue = c->setup(c, ctrl);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* try the only function in the current config */\n\t\t\tif (!list_is_singular(&c->functions))\n\t\t\t\tgoto done;\n\t\t\tf = list_first_entry(&c->functions, struct usb_function,\n\t\t\t\t\t     list);\n\t\t\tif (f->setup)\n\t\t\t\tvalue = f->setup(f, ctrl);\n\t\t}\n\n\t\tgoto done;\n\t}\n\ncheck_value:\n\t/* respond with data transfer before status phase? */\n\tif (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {\n\t\treq->length = value;\n\t\treq->context = cdev;\n\t\treq->zero = value < w_length;\n\t\tvalue = composite_ep0_queue(cdev, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tDBG(cdev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t\tcomposite_setup_complete(gadget->ep0, req);\n\t\t}\n\t} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {\n\t\tWARN(cdev,\n\t\t\t\"%s: Delayed status not supported for w_length != 0\",\n\t\t\t__func__);\n\t}\n\ndone:\n\t/* device either stalls (value < 0) or reports success */\n\treturn value;\n}", "func_hash": 303126640832251617876878392273862526744, "file_name": "composite.c", "file_hash": 18887355761308803276229129312051135602, "cwe": ["CWE-476"], "cve": "CVE-2022-25258", "cve_desc": "An issue was discovered in drivers/usb/gadget/composite.c in the Linux kernel before 5.16.10. The USB Gadget subsystem lacks certain validation of interface OS descriptor requests (ones with a large array index and ones associated with NULL function pointer retrieval). Memory corruption might occur.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-25258"}
{"idx": 220195, "project": "tensorflow", "commit_id": "c99d98cd189839dcf51aee94e7437b54b31f8abd", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/c99d98cd189839dcf51aee94e7437b54b31f8abd", "commit_message": "Handle invalid inputs instead of crashing.\n\nPiperOrigin-RevId: 409549744\nChange-Id: I7f5935b34b53f7e426a5462fcc027bdbf5dcda24", "target": 0, "func": "std::unordered_map<std::string, Node*> Graph::BuildNodeNameIndex() const {\n  std::unordered_map<std::string, Node*> result;\n  for (Node* n : nodes()) {\n    result[n->name()] = n;\n  }\n  return result;\n}", "func_hash": 197202433198762332076220624249404901083, "file_name": "graph.cc", "file_hash": 172099243927919341591512227523808328051, "cwe": ["CWE-125"], "cve": "CVE-2022-23592", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. TensorFlow's type inference can cause a heap out of bounds read as the bounds checking is done in a `DCHECK` (which is a no-op during production). An attacker can control the `input_idx` variable such that `ix` would be larger than the number of values in `node_t.args`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23592"}
{"idx": 218754, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static wchar_t *ConvertUTF8ToUTF16(const unsigned char *source)\n{\n  size_t\n    length;\n\n  wchar_t\n    *utf16;\n\n  length=UTF8ToUTF16(source,(wchar_t *) NULL);\n  if (length == 0)\n    {\n      ssize_t\n        i;\n\n      /*\n        Not UTF-8, just copy.\n      */\n      length=strlen((char *) source);\n      utf16=(wchar_t *) AcquireQuantumMemory(length+1,sizeof(*utf16));\n      if (utf16 == (wchar_t *) NULL)\n        return((wchar_t *) NULL);\n      for (i=0; i <= (ssize_t) length; i++)\n        utf16[i]=source[i];\n      return(utf16);\n    }\n  utf16=(wchar_t *) AcquireQuantumMemory(length+1,sizeof(*utf16));\n  if (utf16 == (wchar_t *) NULL)\n    return((wchar_t *) NULL);\n  length=UTF8ToUTF16(source,utf16);\n  return(utf16);\n}", "func_hash": 40697322064819167267544778781891956822, "file_name": "emf.c", "file_hash": 107669295784465069224649926956785164656, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 197395, "project": "tensorflow", "commit_id": "4071d8e2f6c45c1955a811fee757ca2adbe462c1", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/4071d8e2f6c45c1955a811fee757ca2adbe462c1", "commit_message": "Fix FPE issue with `tf.raw_ops.Reverse`.\n\nPiperOrigin-RevId: 371176973\nChange-Id: Ic6d483bfc95313ec2299c2d1c956cfe96c96626c", "target": 1, "func": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& dims = context->input(1);\n\n    if (TensorShapeUtils::IsScalar(input.shape())) {\n      context->set_output(0, input);\n    } else {\n      const int input_dims = input.dims();\n      OP_REQUIRES(context, TensorShapeUtils::IsVector(dims.shape()),\n                  errors::InvalidArgument(\"'dims' must be 1-dimension, not \",\n                                          dims.dims()));\n\n      OP_REQUIRES(\n          context, input_dims == dims.dim_size(0),\n          errors::InvalidArgument(\n              \"'dims' must have the same number of values as 'input' has \"\n              \"dimensions. 'input' has \",\n              input_dims, \"'dims' has \", dims.dim_size(0), \" values\"));\n      OP_REQUIRES(context, input_dims <= 8,\n                  errors::Unimplemented(\n                      \"reverse is not implemented for tensors of rank > 8.\"));\n\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, input.shape(), &output));\n\n#define HANDLE_REVERSE(NDIMS)                                               \\\n  case NDIMS:                                                               \\\n    HandleReverseCase<Device, T, NDIMS>(context, dims.vec<bool>(), output); \\\n    return;\n\n      switch (input_dims) {\n        HANDLE_REVERSE(0);\n        HANDLE_REVERSE(1);\n        HANDLE_REVERSE(2);\n        HANDLE_REVERSE(3);\n        HANDLE_REVERSE(4);\n        HANDLE_REVERSE(5);\n        HANDLE_REVERSE(6);\n        HANDLE_REVERSE(7);\n        HANDLE_REVERSE(8);\n      }\n#undef HANDLE_REVERSE\n    }\n  }", "func_hash": 320359893140451578623172737965362672352, "file_name": "reverse_op.cc", "file_hash": 11850357512767152498311955295464965693, "cwe": ["CWE-369"], "cve": "CVE-2021-29556", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.Reverse`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/36229ea9e9451dac14a8b1f4711c435a1d84a594/tensorflow/core/kernels/reverse_op.cc#L75-L76) performs a division based on the first dimension of the tensor argument. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-29556"}
{"idx": 139248, "project": "Chrome", "commit_id": "fb83de09f2c986ee91741f3a2776feea0e18e3f6", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/fb83de09f2c986ee91741f3a2776feea0e18e3f6", "commit_message": "None", "target": 0, "func": "void OverlayWindowViews::UpdateControlsBounds() {\n  gfx::Rect larger_window_bounds = GetBounds();\n  larger_window_bounds.Inset(-1, -1);\n  controls_scrim_view_->SetBoundsRect(\n      gfx::Rect(gfx::Point(0, 0), larger_window_bounds.size()));\n\n  WindowQuadrant quadrant = GetCurrentWindowQuadrant(GetBounds(), controller_);\n  close_controls_view_->SetPosition(GetBounds().size(), quadrant);\n#if defined(OS_CHROMEOS)\n  resize_handle_view_->SetPosition(GetBounds().size(), quadrant);\n#endif\n\n  controls_parent_view_->SetBoundsRect(\n      gfx::Rect(gfx::Point(0, 0), GetBounds().size()));\n\n  UpdateControlsPositions();\n}\n", "func_hash": 37978632559101286639193585142236048344, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 218769, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static MagickBooleanType ApplyPSDLayerOpacity(Image *image,Quantum opacity,\n  MagickBooleanType revert,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  applying layer opacity %.20g\", (double) opacity);\n  if (opacity == QuantumRange)\n    return(MagickTrue);\n  if (image->matte != MagickTrue)\n    (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static) shared(status) \\\n  magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    PixelPacket\n      *magick_restrict q;\n\n    ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (revert == MagickFalse)\n        SetPixelAlpha(q,ClampToQuantum(QuantumScale*GetPixelAlpha(q)*opacity));\n      else if (opacity > 0)\n        SetPixelAlpha(q,ClampToQuantum((double) QuantumRange*GetPixelAlpha(q)/\n          (MagickRealType) opacity));\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  return(status);\n}", "func_hash": 84598550776265420894773107264585164131, "file_name": "psd.c", "file_hash": 226732625250511916284298083592366716300, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 125906, "project": "Chrome", "commit_id": "6d067124e87295721c62a77f0610e4b37f6098ad", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/6d067124e87295721c62a77f0610e4b37f6098ad", "commit_message": "None", "target": 0, "func": "v8::Handle<v8::Value> V8ThrowException::throwDOMException(int ec, const String& sanitizedMessage, const String& unsanitizedMessage, const v8::Handle<v8::Object>& creationContext, v8::Isolate* isolate)\n{\n    ASSERT(ec == SecurityError || unsanitizedMessage.isEmpty());\n    v8::Handle<v8::Value> exception = createDOMException(isolate, ec, sanitizedMessage, unsanitizedMessage, creationContext);\n    if (exception.IsEmpty())\n        return v8Undefined();\n\n    return V8ThrowException::throwException(exception, isolate);\n}\n", "func_hash": 83282090160072350649440660819587619629, "file_name": "None", "file_hash": null, "cwe": [], "cve": "CVE-2015-1210", "cve_desc": "", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1210"}
{"idx": 221393, "project": "linux", "commit_id": "c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc", "commit_message": "KVM: nSVM: always intercept VMLOAD/VMSAVE when nested (CVE-2021-3656)\n\nIf L1 disables VMLOAD/VMSAVE intercepts, and doesn't enable\nVirtual VMLOAD/VMSAVE (currently not supported for the nested hypervisor),\nthen VMLOAD/VMSAVE must operate on the L1 physical memory, which is only\npossible by making L0 intercept these instructions.\n\nFailure to do so allowed the nested guest to run VMLOAD/VMSAVE unintercepted,\nand thus read/write portions of the host physical memory.\n\nFixes: 89c8a4984fc9 (\"KVM: SVM: Enable Virtual VMLOAD VMSAVE feature\")\n\nSuggested-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Maxim Levitsky <mlevitsk@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "target": 0, "func": "void svm_leave_nested(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\tif (is_guest_mode(vcpu)) {\n\t\tsvm->nested.nested_run_pending = 0;\n\t\tsvm->nested.vmcb12_gpa = INVALID_GPA;\n\n\t\tleave_guest_mode(vcpu);\n\n\t\tsvm_switch_vmcb(svm, &svm->vmcb01);\n\n\t\tnested_svm_uninit_mmu_context(vcpu);\n\t\tvmcb_mark_all_dirty(svm->vmcb);\n\t}\n\n\tkvm_clear_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu);\n}", "func_hash": 45498705495892756367904775259102357664, "file_name": "None", "file_hash": null, "cwe": ["CWE-862"], "cve": "CVE-2021-3656", "cve_desc": "A flaw was found in the KVM's AMD code for supporting SVM nested virtualization. The flaw occurs when processing the VMCB (virtual machine control block) provided by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation of the \"virt_ext\" field, this issue could allow a malicious L1 to disable both VMLOAD/VMSAVE intercepts and VLS (Virtual VMLOAD/VMSAVE) for the L2 guest. As a result, the L2 guest would be allowed to read/write physical pages of the host, resulting in a crash of the entire system, leak of sensitive data or potential guest-to-host escape.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3656"}
{"idx": 204036, "project": "net", "commit_id": "b922f622592af76b57cbc566eaeccda0b31a3496", "project_url": "https://git.kernel.org/cgit/linux/kernel/git/davem/net", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=b922f622592af76b57cbc566eaeccda0b31a3496", "commit_message": "atlantic: Fix OOB read and write in hw_atl_utils_fw_rpc_wait\n\nThis bug report shows up when running our research tools. The\nreports is SOOB read, but it seems SOOB write is also possible\na few lines below.\n\nIn details, fw.len and sw.len are inputs coming from io. A len\nover the size of self->rpc triggers SOOB. The patch fixes the\nbugs by adding sanity checks.\n\nThe bugs are triggerable with compromised/malfunctioning devices.\nThey are potentially exploitable given they first leak up to\n0xffff bytes and able to overwrite the region later.\n\nThe patch is tested with QEMU emulater.\nThis is NOT tested with a real device.\n\nAttached is the log we found by fuzzing.\n\nBUG: KASAN: slab-out-of-bounds in\n\thw_atl_utils_fw_upload_dwords+0x393/0x3c0 [atlantic]\nRead of size 4 at addr ffff888016260b08 by task modprobe/213\nCPU: 0 PID: 213 Comm: modprobe Not tainted 5.6.0 #1\nCall Trace:\n dump_stack+0x76/0xa0\n print_address_description.constprop.0+0x16/0x200\n ? hw_atl_utils_fw_upload_dwords+0x393/0x3c0 [atlantic]\n ? hw_atl_utils_fw_upload_dwords+0x393/0x3c0 [atlantic]\n __kasan_report.cold+0x37/0x7c\n ? aq_hw_read_reg_bit+0x60/0x70 [atlantic]\n ? hw_atl_utils_fw_upload_dwords+0x393/0x3c0 [atlantic]\n kasan_report+0xe/0x20\n hw_atl_utils_fw_upload_dwords+0x393/0x3c0 [atlantic]\n hw_atl_utils_fw_rpc_call+0x95/0x130 [atlantic]\n hw_atl_utils_fw_rpc_wait+0x176/0x210 [atlantic]\n hw_atl_utils_mpi_create+0x229/0x2e0 [atlantic]\n ? hw_atl_utils_fw_rpc_wait+0x210/0x210 [atlantic]\n ? hw_atl_utils_initfw+0x9f/0x1c8 [atlantic]\n hw_atl_utils_initfw+0x12a/0x1c8 [atlantic]\n aq_nic_ndev_register+0x88/0x650 [atlantic]\n ? aq_nic_ndev_init+0x235/0x3c0 [atlantic]\n aq_pci_probe+0x731/0x9b0 [atlantic]\n ? aq_pci_func_init+0xc0/0xc0 [atlantic]\n local_pci_probe+0xd3/0x160\n pci_device_probe+0x23f/0x3e0\n\nReported-by: Brendan Dolan-Gavitt <brendandg@nyu.edu>\nSigned-off-by: Zekun Shen <bruceshenzk@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,\n\t\t\t     struct hw_atl_utils_fw_rpc **rpc)\n{\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s sw;\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s fw;\n\tint err = 0;\n\n\tdo {\n\t\tsw.val = aq_hw_read_reg(self, HW_ATL_RPC_CONTROL_ADR);\n\n\t\tself->rpc_tid = sw.tid;\n\n\t\terr = readx_poll_timeout_atomic(hw_atl_utils_rpc_state_get,\n\t\t\t\t\t\tself, fw.val,\n\t\t\t\t\t\tsw.tid == fw.tid,\n\t\t\t\t\t\t1000U, 100000U);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = aq_hw_err_from_flags(self);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\tif (fw.len == 0xFFFFU) {\n\t\t\terr = hw_atl_utils_fw_rpc_call(self, sw.len);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\t} while (sw.tid != fw.tid || 0xFFFFU == fw.len);\n\n\tif (rpc) {\n\t\tif (fw.len) {\n\t\t\terr =\n\t\t\thw_atl_utils_fw_downld_dwords(self,\n\t\t\t\t\t\t      self->rpc_addr,\n\t\t\t\t\t\t      (u32 *)(void *)\n\t\t\t\t\t\t      &self->rpc,\n\t\t\t\t\t\t      (fw.len + sizeof(u32) -\n\t\t\t\t\t\t       sizeof(u8)) /\n\t\t\t\t\t\t      sizeof(u32));\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\n\t\t*rpc = &self->rpc;\n\t}\n\nerr_exit:\n\treturn err;\n}", "func_hash": 172267235624297887549936176387558671779, "file_name": "hw_atl_utils.c", "file_hash": 44971629265501342494525008338833784195, "cwe": ["CWE-787"], "cve": "CVE-2021-43975", "cve_desc": "In the Linux kernel through 5.15.2, hw_atl_utils_fw_rpc_wait in drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c allows an attacker (who can introduce a crafted device) to trigger an out-of-bounds write via a crafted length value.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-43975"}
{"idx": 206273, "project": "radare2", "commit_id": "a7ce29647fcb38386d7439696375e16e093d6acb", "project_url": "https://github.com/radare/radare2", "commit_url": "https://github.com/radareorg/radare2/commit/a7ce29647fcb38386d7439696375e16e093d6acb", "commit_message": "Fix UAF in aaaa on arm/thumb switching ##crash\n\n* Reported by @peacock-doris via huntr.dev\n* Reproducer tests_65185\n* This is a logic fix, but not the fully safe as changes in the code\n  can result on UAF again, to properly protect r2 from crashing we\n  need to break the ABI and add refcounting to RRegItem, which can't\n  happen in 5.6.x because of abi-compat rules", "target": 1, "func": "static void extract_arg(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, const char *reg, const char *sign, char type) {\n\tst64 ptr = 0;\n\tchar *addr, *esil_buf = NULL;\n\tconst st64 maxstackframe = 1024 * 8; \n\n\tr_return_if_fail (anal && fcn && op && reg);\n\n\tsize_t i;\n\tfor (i = 0; i < R_ARRAY_SIZE (op->src); i++) {\n\t\tif (op->src[i] && op->src[i]->reg && op->src[i]->reg->name) {\n\t\t\tif (!strcmp (reg, op->src[i]->reg->name)) {\n\t\t\t\tst64 delta = op->src[i]->delta;\n\t\t\t\tif ((delta > 0 && *sign == '+') || (delta < 0 && *sign == '-')) {\n\t\t\t\t\tptr = R_ABS (op->src[i]->delta);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ptr) {\n\t\tconst char *op_esil = r_strbuf_get (&op->esil);\n\t\tif (!op_esil) {\n\t\t\treturn;\n\t\t}\n\t\tesil_buf = strdup (op_esil);\n\t\tif (!esil_buf) {\n\t\t\treturn;\n\t\t}\n\t\tr_strf_var (esilexpr, 64, \",%s,%s,\", reg, sign);\n\t\tchar *ptr_end = strstr (esil_buf, esilexpr);\n\t\tif (!ptr_end) {\n\t\t\tfree (esil_buf);\n\t\t\treturn;\n\t\t}\n\t\t*ptr_end = 0;\n\t\taddr = ptr_end;\n\t\twhile ((addr[0] != '0' || addr[1] != 'x') && addr >= esil_buf + 1 && *addr != ',') {\n\t\t\taddr--;\n\t\t}\n\t\tif (strncmp (addr, \"0x\", 2)) {\n\t\t\t//XXX: This is a workaround for inconsistent esil\n\t\t\tif (!op->stackop && op->dst) {\n\t\t\t\tconst char *sp = r_reg_get_name (anal->reg, R_REG_NAME_SP);\n\t\t\t\tconst char *bp = r_reg_get_name (anal->reg, R_REG_NAME_BP);\n\t\t\t\tconst char *rn = op->dst->reg ? op->dst->reg->name : NULL;\n\t\t\t\tif (rn && ((bp && !strcmp (bp, rn)) || (sp && !strcmp (sp, rn)))) {\n\t\t\t\t\tif (anal->verbose) {\n\t\t\t\t\t\teprintf (\"Warning: Analysis didn't fill op->stackop for instruction that alters stack at 0x%\" PFMT64x \".\\n\", op->addr);\n\t\t\t\t\t}\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*addr == ',') {\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tif (!op->stackop && op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_POP\n\t\t\t\t&& op->type != R_ANAL_OP_TYPE_RET && r_str_isnumber (addr)) {\n\t\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t\t\tif (ptr && op->src[0] && ptr == op->src[0]->imm) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t} else if ((op->stackop == R_ANAL_STACK_SET) || (op->stackop == R_ANAL_STACK_GET)) {\n\t\t\t\tif (op->ptr % 4) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tptr = R_ABS (op->ptr);\n\t\t\t} else {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t}\n\t}\n\n\tif (anal->verbose && (!op->src[0] || !op->dst)) {\n\t\teprintf (\"Warning: Analysis didn't fill op->src/dst at 0x%\" PFMT64x \".\\n\", op->addr);\n\t}\n\n\tint rw = (op->direction == R_ANAL_OP_DIR_WRITE) ? R_ANAL_VAR_ACCESS_TYPE_WRITE : R_ANAL_VAR_ACCESS_TYPE_READ;\n\tif (*sign == '+') {\n\t\tconst bool isarg = type == R_ANAL_VAR_KIND_SPV ? ptr >= fcn->stack : ptr >= fcn->bp_off;\n\t\tconst char *pfx = isarg ? ARGPREFIX : VARPREFIX;\n\t\tst64 frame_off;\n\t\tif (type == R_ANAL_VAR_KIND_SPV) {\n\t\t\tframe_off = ptr - fcn->stack;\n\t\t} else {\n\t\t\tframe_off = ptr - fcn->bp_off;\n\t\t}\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = NULL, *vartype = NULL;\n\t\tif (isarg) {\n\t\t\tconst char *place = fcn->cc ? r_anal_cc_arg (anal, fcn->cc, ST32_MAX) : NULL;\n\t\t\tbool stack_rev = place ? !strcmp (place, \"stack_rev\") : false;\n\t\t\tchar *fname = r_type_func_guess (anal->sdb_types, fcn->name);\n\t\t\tif (fname) {\n\t\t\t\tut64 sum_sz = 0;\n\t\t\t\tsize_t from, to, i;\n\t\t\t\tif (stack_rev) {\n\t\t\t\t\tconst size_t cnt = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t\tfrom = cnt ? cnt - 1 : cnt;\n\t\t\t\t\tto = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t} else {\n\t\t\t\t\tfrom = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t\tto = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t}\n\t\t\t\tconst int bytes = (fcn->bits ? fcn->bits : anal->bits) / 8;\n\t\t\t\tfor (i = from; stack_rev ? i >= to : i < to; stack_rev ? i-- : i++) {\n\t\t\t\t\tchar *tp = r_type_func_args_type (anal->sdb_types, fname, i);\n\t\t\t\t\tif (!tp) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sum_sz == frame_off) {\n\t\t\t\t\t\tvartype = tp;\n\t\t\t\t\t\tvarname = strdup (r_type_func_args_name (anal->sdb_types, fname, i));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 bit_sz = r_type_get_bitsize (anal->sdb_types, tp);\n\t\t\t\t\tsum_sz += bit_sz ? bit_sz / 8 : bytes;\n\t\t\t\t\tsum_sz = R_ROUND (sum_sz, bytes);\n\t\t\t\t\tfree (tp);\n\t\t\t\t}\n\t\t\t\tfree (fname);\n\t\t\t}\n\t\t}\n\t\tif (!varname) {\n\t\t\tif (anal->opt.varname_stack) {\n\t\t\t\tvarname = r_str_newf (\"%s_%\" PFMT64x \"h\", pfx, R_ABS (frame_off));\n\t\t\t} else {\n\t\t\t\tvarname = r_anal_function_autoname_var (fcn, type, pfx, ptr);\n\t\t\t}\n\t\t}\n\t\tif (varname) {\n#if 0\n\t\t\tif (isarg && frame_off > 48) {\n\t\t\t\tfree (varname);\n\t\t\t\tgoto beach;\n\t\t\t}\n#endif\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, vartype, anal->bits / 8, isarg, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t\tfree (vartype);\n\t} else {\n\t\tst64 frame_off = -(ptr + fcn->bp_off);\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = anal->opt.varname_stack\n\t\t\t? r_str_newf (\"%s_%\" PFMT64x \"h\", VARPREFIX, R_ABS (frame_off))\n\t\t\t: r_anal_function_autoname_var (fcn, type, VARPREFIX, -ptr);\n\t\tif (varname) {\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, NULL, anal->bits / 8, false, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t}\nbeach:\n\tfree (esil_buf);\n}", "func_hash": 336184840247355587470651192558617642560, "file_name": "None", "file_hash": null, "cwe": ["CWE-416"], "cve": "CVE-2022-1031", "cve_desc": "Use After Free in op_is_set_bp in GitHub repository radareorg/radare2 prior to 5.6.6.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1031"}
{"idx": 221665, "project": "e2guardian", "commit_id": "eae46a7e2a57103aadca903c4a24cca94dc502a2", "project_url": "https://github.com/e2guardian/e2guardian", "commit_url": "https://github.com/e2guardian/e2guardian/commit/eae46a7e2a57103aadca903c4a24cca94dc502a2", "commit_message": "Fix bug #707 cert hostnames not being checked\n- only happened when openssl v1.1 is used", "target": 0, "func": "bool Socket::getIeof() {\n    return ieof;\n}", "func_hash": 171675382251824627304339034760893177319, "file_name": "Socket.cpp", "file_hash": 316707147744091371767800459911917453562, "cwe": ["CWE-295"], "cve": "CVE-2021-44273", "cve_desc": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-44273"}
{"idx": 219949, "project": "glewlwyd", "commit_id": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "project_url": "https://github.com/babelouest/glewlwyd", "commit_url": "https://github.com/babelouest/glewlwyd/commit/125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "commit_message": "Fix update session when auth fail", "target": 0, "func": "int callback_glewlwyd_user_update_password (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct config_elements * config = (struct config_elements *)user_data;\n  json_t * j_session, * j_password, * j_element = NULL;\n  char * session_uid = get_session_id(config, request);\n  const char ** passwords = NULL;\n  int res;\n  struct _user_module_instance * user_module;\n  size_t index = 0;\n\n  if (session_uid != NULL && o_strlen(session_uid)) {\n    j_session = get_current_user_for_session(config, session_uid);\n    if (check_result_value(j_session, G_OK)) {\n      j_password = ulfius_get_json_body_request(request, NULL);\n      user_module = get_user_module_instance(config, json_string_value(json_object_get(json_object_get(j_session, \"user\"), \"source\")));\n      if (user_module && user_module->multiple_passwords) {\n        if (json_string_length(json_object_get(j_password, \"old_password\")) && json_is_array(json_object_get(j_password, \"password\"))) {\n          if ((passwords = o_malloc(json_array_size(json_object_get(j_password, \"password\")) * sizeof(char *))) != NULL) {\n            json_array_foreach(json_object_get(j_password, \"password\"), index, j_element) {\n              passwords[index] = json_string_value(j_element);\n            }\n            if ((res = user_update_password(config, json_string_value(json_object_get(json_object_get(j_session, \"user\"), \"username\")), json_string_value(json_object_get(j_password, \"old_password\")), passwords, json_array_size(json_object_get(j_password, \"password\")))) == G_ERROR_PARAM) {\n              response->status = 400;\n            } else if (res != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_update_password - Error user_update_password (1)\");\n              response->status = 500;\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_update_password - Error allocating resources for passwords (1)\");\n            response->status = 500;\n          }\n          o_free(passwords);\n        } else {\n          response->status = 400;\n        }\n      } else {\n        if (json_string_length(json_object_get(j_password, \"old_password\")) && json_string_length(json_object_get(j_password, \"password\"))) {\n          if ((passwords = o_malloc(sizeof(char *))) != NULL) {\n            passwords[0] = json_string_value(json_object_get(j_password, \"password\"));\n            if ((res = user_update_password(config, json_string_value(json_object_get(json_object_get(j_session, \"user\"), \"username\")), json_string_value(json_object_get(j_password, \"old_password\")), passwords, 1)) == G_ERROR_PARAM) {\n              response->status = 400;\n            } else if (res != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_update_password - Error user_update_password (2)\");\n              response->status = 500;\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_update_password - Error allocating resources for passwords (2)\");\n            response->status = 500;\n          }\n          o_free(passwords);\n        } else {\n          response->status = 400;\n        }\n      }\n      json_decref(j_password);\n    } else if (check_result_value(j_session, G_ERROR_NOT_FOUND)) {\n      response->status = 401;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_update_password - Error get_current_user_for_session\");\n      response->status = 500;\n    }\n    json_decref(j_session);\n  } else {\n    response->status = 401;\n  }\n  o_free(session_uid);\n  \n  return U_CALLBACK_CONTINUE;\n}", "func_hash": 258712616433507944431066330335248899362, "file_name": "webservice.c", "file_hash": 287798817606377336444620654835011177393, "cwe": ["CWE-287"], "cve": "CVE-2021-45379", "cve_desc": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-45379"}
{"idx": 90218, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual bool has_cellular_networks() const {\n    return cellular_networks_.begin() != cellular_networks_.end();\n  }\n", "func_hash": 165114074431011224452094363737422850170, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 218751, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static Image *ReadEMFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  BITMAPINFO\n    DIBinfo;\n\n  HBITMAP\n    hBitmap,\n    hOldBitmap;\n\n  HDC\n    hDC;\n\n  HENHMETAFILE\n    hemf;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  RECT\n    rect;\n\n  ssize_t\n    x;\n\n  PixelPacket\n    *q;\n\n  RGBQUAD\n    *pBits,\n    *ppBits;\n\n  ssize_t\n    height,\n    width,\n    y;\n\n  image=AcquireImage(image_info);\n  hemf=ReadEnhMetaFile(image_info->filename,&width,&height);\n  if (hemf == (HENHMETAFILE) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((image->columns == 0) || (image->rows == 0))\n    {\n      double\n        y_resolution,\n        x_resolution;\n\n      y_resolution=DefaultResolution;\n      x_resolution=DefaultResolution;\n      if (image->y_resolution > 0)\n        {\n          y_resolution=image->y_resolution;\n          if (image->units == PixelsPerCentimeterResolution)\n            y_resolution*=CENTIMETERS_INCH;\n        }\n      if (image->x_resolution > 0)\n        {\n          x_resolution=image->x_resolution;\n          if (image->units == PixelsPerCentimeterResolution)\n            x_resolution*=CENTIMETERS_INCH;\n        }\n      image->rows=(size_t) ((height/1000.0/CENTIMETERS_INCH)*y_resolution+0.5);\n      image->columns=(size_t) ((width/1000.0/CENTIMETERS_INCH)*\n        x_resolution+0.5);\n    }\n  if (image_info->size != (char *) NULL)\n    {\n      image->columns=width;\n      image->rows=height;\n      (void) GetGeometry(image_info->size,(ssize_t *) NULL,(ssize_t *) NULL,\n        &image->columns,&image->rows);\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_info->page != (char *) NULL)\n    {\n      char\n        *geometry;\n\n      char\n        *p;\n\n      MagickStatusType\n        flags;\n\n      ssize_t\n        sans;\n\n      geometry=GetPageGeometry(image_info->page);\n      p=strchr(geometry,'>');\n      if (p == (char *) NULL)\n        {\n          flags=ParseMetaGeometry(geometry,&sans,&sans,&image->columns,\n            &image->rows);\n          if (image->x_resolution != 0.0)\n            image->columns=(size_t) floor((image->columns*image->x_resolution)+\n              0.5);\n          if (image->y_resolution != 0.0)\n            image->rows=(size_t) floor((image->rows*image->y_resolution)+0.5);\n        }\n      else\n        {\n          *p='\\0';\n          flags=ParseMetaGeometry(geometry,&sans,&sans,&image->columns,\n            &image->rows);\n          if (image->x_resolution != 0.0)\n            image->columns=(size_t) floor(((image->columns*image->x_resolution)/\n              DefaultResolution)+0.5);\n          if (image->y_resolution != 0.0)\n            image->rows=(size_t) floor(((image->rows*image->y_resolution)/\n              DefaultResolution)+0.5);\n        }\n      (void) flags;\n      geometry=DestroyString(geometry);\n    }\n  hDC=GetDC(NULL);\n  if (hDC == (HDC) NULL)\n    {\n      DeleteEnhMetaFile(hemf);\n      ThrowReaderException(ResourceLimitError,\"UnableToCreateADC\");\n    }\n  /*\n    Initialize the bitmap header info.\n  */\n  (void) memset(&DIBinfo,0,sizeof(BITMAPINFO));\n  DIBinfo.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);\n  DIBinfo.bmiHeader.biWidth=(LONG) image->columns;\n  DIBinfo.bmiHeader.biHeight=(-1)*(LONG) image->rows;\n  DIBinfo.bmiHeader.biPlanes=1;\n  DIBinfo.bmiHeader.biBitCount=32;\n  DIBinfo.bmiHeader.biCompression=BI_RGB;\n  hBitmap=CreateDIBSection(hDC,&DIBinfo,DIB_RGB_COLORS,(void **) &ppBits,NULL,\n    0);\n  ReleaseDC(NULL,hDC);\n  if (hBitmap == (HBITMAP) NULL)\n    {\n      DeleteEnhMetaFile(hemf);\n      ThrowReaderException(ResourceLimitError,\"UnableToCreateBitmap\");\n    }\n  hDC=CreateCompatibleDC(NULL);\n  if (hDC == (HDC) NULL)\n    {\n      DeleteEnhMetaFile(hemf);\n      DeleteObject(hBitmap);\n      ThrowReaderException(ResourceLimitError,\"UnableToCreateADC\");\n    }\n  hOldBitmap=(HBITMAP) SelectObject(hDC,hBitmap);\n  if (hOldBitmap == (HBITMAP) NULL)\n    {\n      DeleteEnhMetaFile(hemf);\n      DeleteDC(hDC);\n      DeleteObject(hBitmap);\n      ThrowReaderException(ResourceLimitError,\"UnableToCreateBitmap\");\n    }\n  /*\n    Initialize the bitmap to the image background color.\n  */\n  pBits=ppBits;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      pBits->rgbRed=ScaleQuantumToChar(image->background_color.red);\n      pBits->rgbGreen=ScaleQuantumToChar(image->background_color.green);\n      pBits->rgbBlue=ScaleQuantumToChar(image->background_color.blue);\n      pBits++;\n    }\n  }\n  rect.top=0;\n  rect.left=0;\n  rect.right=(LONG) image->columns;\n  rect.bottom=(LONG) image->rows;\n  /*\n    Convert metafile pixels.\n  */\n  PlayEnhMetaFile(hDC,hemf,&rect);\n  pBits=ppBits;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelRed(q,ScaleCharToQuantum(pBits->rgbRed));\n      SetPixelGreen(q,ScaleCharToQuantum(pBits->rgbGreen));\n      SetPixelBlue(q,ScaleCharToQuantum(pBits->rgbBlue));\n      SetPixelOpacity(q,OpaqueOpacity);\n      pBits++;\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n  DeleteEnhMetaFile(hemf);\n  SelectObject(hDC,hOldBitmap);\n  DeleteDC(hDC);\n  DeleteObject(hBitmap);\n  return(GetFirstImageInList(image));\n}", "func_hash": 122550995580190722696564351194813451780, "file_name": "emf.c", "file_hash": 107669295784465069224649926956785164656, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 90835, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  void DeleteClientOriginData(QuotaClient* client,\n                        const GURL& origin,\n                        StorageType type) {\n    DCHECK(client);\n    quota_status_ = kQuotaStatusUnknown;\n    client->DeleteOriginData(origin, type,\n        callback_factory_.NewCallback(\n            &QuotaManagerTest::StatusCallback));\n  }\n", "func_hash": 60539797550806086161040973822172423982, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 221161, "project": "gpac", "commit_id": "a69b567b8c95c72f9560c873c5ab348be058f340", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340", "commit_message": "fixed #1895", "target": 0, "func": "void gf_odf_avc_cfg_del(GF_AVCConfig *cfg)\n{\n\tif (!cfg) return;\n\twhile (gf_list_count(cfg->sequenceParameterSets)) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->sequenceParameterSets, 0);\n\t\tgf_list_rem(cfg->sequenceParameterSets, 0);\n\t\tif (sl->data) gf_free(sl->data);\n\t\tgf_free(sl);\n\t}\n\tgf_list_del(cfg->sequenceParameterSets);\n\tcfg->sequenceParameterSets = NULL;\n\n\twhile (gf_list_count(cfg->pictureParameterSets)) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->pictureParameterSets, 0);\n\t\tgf_list_rem(cfg->pictureParameterSets, 0);\n\t\tif (sl->data) gf_free(sl->data);\n\t\tgf_free(sl);\n\t}\n\tgf_list_del(cfg->pictureParameterSets);\n\tcfg->pictureParameterSets = NULL;\n\n\tif (cfg->sequenceParameterSetExtensions) {\n\t\twhile (gf_list_count(cfg->sequenceParameterSetExtensions)) {\n\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->sequenceParameterSetExtensions, 0);\n\t\t\tgf_list_rem(cfg->sequenceParameterSetExtensions, 0);\n\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\tgf_free(sl);\n\t\t}\n\t\tgf_list_del(cfg->sequenceParameterSetExtensions);\n\t\tcfg->sequenceParameterSetExtensions = NULL;\n\t}\n\tgf_free(cfg);\n}", "func_hash": 18308552652950503852936706783775801185, "file_name": "descriptors.c", "file_hash": 86476492964393375980272696403064975409, "cwe": ["CWE-415"], "cve": "CVE-2021-40571", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40571"}
{"idx": 220410, "project": "mruby", "commit_id": "27d1e0132a0804581dca28df042e7047fd27eaa8", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8", "commit_message": "array.c: fix `mrb_ary_shift_m` initialization bug.\n\nThe `ARY_PTR` and `ARY_LEN` may be modified in `mrb_get_args`.", "target": 0, "func": "mrb_ary_subseq(mrb_state *mrb, mrb_value ary, mrb_int beg, mrb_int len)\n{\n  struct RArray *a = mrb_ary_ptr(ary);\n  return ary_subseq(mrb, a, beg, len);\n}", "func_hash": 167569208306229787481235930767139924547, "file_name": "array.c", "file_hash": 295526445825727607536544634773604768998, "cwe": ["CWE-476"], "cve": "CVE-2021-4188", "cve_desc": "mruby is vulnerable to NULL Pointer Dereference", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4188"}
{"idx": 175688, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual void EnableWifiNetworkDevice(bool enable) {}\n", "func_hash": 145055075868060404088435281603403491116, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 220194, "project": "tensorflow", "commit_id": "c99d98cd189839dcf51aee94e7437b54b31f8abd", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/c99d98cd189839dcf51aee94e7437b54b31f8abd", "commit_message": "Handle invalid inputs instead of crashing.\n\nPiperOrigin-RevId: 409549744\nChange-Id: I7f5935b34b53f7e426a5462fcc027bdbf5dcda24", "target": 0, "func": "int Graph::InternDeviceName(const std::string& device_name) {\n  // Special case, very common.  Also, this allows us to use a single map\n  // lookup below, instead of two.  The 'if (index_cell > 0)' test below\n  // relies on this check.\n  if (device_name.empty()) {\n    return 0;\n  }\n\n  int& index_cell = device_names_map_[device_name];\n  if (index_cell > 0) {\n    return index_cell;\n  }\n\n  const int index = device_names_map_.size();\n  index_cell = index;\n  device_names_.push_back(device_name);\n  return index;\n}", "func_hash": 5721671002864600088732922000601564664, "file_name": "graph.cc", "file_hash": 172099243927919341591512227523808328051, "cwe": ["CWE-125"], "cve": "CVE-2022-23592", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. TensorFlow's type inference can cause a heap out of bounds read as the bounds checking is done in a `DCHECK` (which is a no-op during production). An attacker can control the `input_idx` variable such that `ix` would be larger than the number of values in `node_t.args`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23592"}
{"idx": 210896, "project": "spice", "commit_id": "a4a16ac42d2f19a17e36556546aa94d5cd83745f", "project_url": "https://gitlab.freedesktop.org/spice/spice", "commit_url": "https://gitlab.freedesktop.org/spice/spice/commit/a4a16ac42d2f19a17e36556546aa94d5cd83745f", "commit_message": "memslot: Fix off-by-one error in group/slot boundary check\n\nRedMemSlotInfo keeps an array of groups, and each group contains an\narray of slots. Unfortunately, these checks are off by 1, they check\nthat the index is greater or equal to the number of elements in the\narray, while these arrays are 0 based. The check should only check for\nstrictly greater than the number of elements.\n\nFor the group array, this is not a big issue, as these memslot groups\nare created by spice-server users (eg QEMU), and the group ids used to\nindex that array are also generated by the spice-server user, so it\nshould not be possible for the guest to set them to arbitrary values.\n\nThe slot id is more problematic, as it's calculated from a QXLPHYSICAL\naddress, and such addresses are usually set by the guest QXL driver, so\nthe guest can set these to arbitrary values, including malicious values,\nwhich are probably easy to build from the guest PCI configuration.\n\nThis patch fixes the arrays bound check, and adds a test case for this.\nThis fixes CVE-2019-3813.\n\nSigned-off-by: Christophe Fergeau <cfergeau@redhat.com>\nAcked-by: Frediano Ziglio <fziglio@redhat.com>", "target": 1, "func": "void *memslot_get_virt(RedMemSlotInfo *info, QXLPHYSICAL addr, uint32_t add_size,\n                       int group_id)\n{\n    int slot_id;\n    int generation;\n    unsigned long h_virt;\n\n    MemSlot *slot;\n\n    if (group_id > info->num_memslots_groups) {\n        spice_critical(\"group_id too big\");\n        return NULL;\n    }\n\n    slot_id = memslot_get_id(info, addr);\n    if (slot_id > info->num_memslots) {\n        print_memslots(info);\n        spice_critical(\"slot_id %d too big, addr=%\" PRIx64, slot_id, addr);\n        return NULL;\n    }\n\n    slot = &info->mem_slots[group_id][slot_id];\n\n    generation = memslot_get_generation(info, addr);\n    if (generation != slot->generation) {\n        print_memslots(info);\n        spice_critical(\"address generation is not valid, group_id %d, slot_id %d, \"\n                       \"gen %d, slot_gen %d\",\n                       group_id, slot_id,\n                       generation, slot->generation);\n        return NULL;\n    }\n\n    h_virt = __get_clean_virt(info, addr);\n    h_virt += slot->address_delta;\n\n    if (!memslot_validate_virt(info, h_virt, slot_id, add_size, group_id)) {\n        return NULL;\n    }\n\n    return (void*)(uintptr_t)h_virt;\n}", "func_hash": 339666083531536346198123409033012275535, "file_name": "memslot.c", "file_hash": 314430538622797217223560939109800616180, "cwe": ["CWE-193"], "cve": "CVE-2019-3813", "cve_desc": "Spice, versions 0.5.2 through 0.14.1, are vulnerable to an out-of-bounds read due to an off-by-one error in memslot_get_virt. This may lead to a denial of service, or, in the worst case, code-execution by unauthenticated attackers.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-3813"}
{"idx": 221482, "project": "flatpak", "commit_id": "89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "commit_message": "run: Add cross-references for some other seccomp syscall filters\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "target": 0, "func": "flatpak_run_setup_base_argv (FlatpakBwrap   *bwrap,\n                             GFile          *runtime_files,\n                             GFile          *app_id_dir,\n                             const char     *arch,\n                             FlatpakRunFlags flags,\n                             GError        **error)\n{\n  g_autofree char *run_dir = NULL;\n  g_autofree char *passwd_contents = NULL;\n  g_autoptr(GString) group_contents = NULL;\n  const char *pkcs11_conf_contents = NULL;\n  struct group *g;\n  gulong pers;\n  gid_t gid = getgid ();\n  g_autoptr(GFile) etc = NULL;\n\n  run_dir = g_strdup_printf (\"/run/user/%d\", getuid ());\n\n  passwd_contents = g_strdup_printf (\"%s:x:%d:%d:%s:%s:%s\\n\"\n                                     \"nfsnobody:x:65534:65534:Unmapped user:/:/sbin/nologin\\n\",\n                                     g_get_user_name (),\n                                     getuid (), gid,\n                                     g_get_real_name (),\n                                     g_get_home_dir (),\n                                     DEFAULT_SHELL);\n\n  group_contents = g_string_new (\"\");\n  g = getgrgid (gid);\n  /* if NULL, the primary group is not known outside the container, so\n   * it might as well stay unknown inside the container... */\n  if (g != NULL)\n    g_string_append_printf (group_contents, \"%s:x:%d:%s\\n\",\n                            g->gr_name, gid, g_get_user_name ());\n  g_string_append (group_contents, \"nfsnobody:x:65534:\\n\");\n\n  pkcs11_conf_contents =\n    \"# Disable user pkcs11 config, because the host modules don't work in the runtime\\n\"\n    \"user-config: none\\n\";\n\n  if ((flags & FLATPAK_RUN_FLAG_NO_PROC) == 0)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--proc\", \"/proc\",\n                            NULL);\n\n  if (!(flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS))\n    flatpak_bwrap_add_arg (bwrap, \"--unshare-pid\");\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--dir\", \"/tmp\",\n                          \"--dir\", \"/var/tmp\",\n                          \"--dir\", \"/run/host\",\n                          \"--dir\", run_dir,\n                          \"--setenv\", \"XDG_RUNTIME_DIR\", run_dir,\n                          \"--symlink\", \"../run\", \"/var/run\",\n                          \"--ro-bind\", \"/sys/block\", \"/sys/block\",\n                          \"--ro-bind\", \"/sys/bus\", \"/sys/bus\",\n                          \"--ro-bind\", \"/sys/class\", \"/sys/class\",\n                          \"--ro-bind\", \"/sys/dev\", \"/sys/dev\",\n                          \"--ro-bind\", \"/sys/devices\", \"/sys/devices\",\n                          \"--ro-bind-try\", \"/proc/self/ns/user\", \"/run/.userns\",\n                          /* glib uses this like /etc/timezone */\n                          \"--symlink\", \"/etc/timezone\", \"/var/db/zoneinfo\",\n                          NULL);\n\n  if (flags & FLATPAK_RUN_FLAG_DIE_WITH_PARENT)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--die-with-parent\",\n                            NULL);\n\n  if (flags & FLATPAK_RUN_FLAG_WRITABLE_ETC)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--dir\", \"/usr/etc\",\n                            \"--symlink\", \"usr/etc\", \"/etc\",\n                            NULL);\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"passwd\", passwd_contents, -1, \"/etc/passwd\", error))\n    return FALSE;\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"group\", group_contents->str, -1, \"/etc/group\", error))\n    return FALSE;\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"pkcs11.conf\", pkcs11_conf_contents, -1, \"/etc/pkcs11/pkcs11.conf\", error))\n    return FALSE;\n\n  if (g_file_test (\"/etc/machine-id\", G_FILE_TEST_EXISTS))\n    flatpak_bwrap_add_args (bwrap, \"--ro-bind\", \"/etc/machine-id\", \"/etc/machine-id\", NULL);\n  else if (g_file_test (\"/var/lib/dbus/machine-id\", G_FILE_TEST_EXISTS))\n    flatpak_bwrap_add_args (bwrap, \"--ro-bind\", \"/var/lib/dbus/machine-id\", \"/etc/machine-id\", NULL);\n\n  if (runtime_files)\n    etc = g_file_get_child (runtime_files, \"etc\");\n  if (etc != NULL &&\n      (flags & FLATPAK_RUN_FLAG_WRITABLE_ETC) == 0 &&\n      g_file_query_exists (etc, NULL))\n    {\n      g_auto(GLnxDirFdIterator) dfd_iter = { 0, };\n      struct dirent *dent;\n      gboolean inited;\n\n      inited = glnx_dirfd_iterator_init_at (AT_FDCWD, flatpak_file_get_path_cached (etc), FALSE, &dfd_iter, NULL);\n\n      while (inited)\n        {\n          g_autofree char *src = NULL;\n          g_autofree char *dest = NULL;\n\n          if (!glnx_dirfd_iterator_next_dent_ensure_dtype (&dfd_iter, &dent, NULL, NULL) || dent == NULL)\n            break;\n\n          if (strcmp (dent->d_name, \"passwd\") == 0 ||\n              strcmp (dent->d_name, \"group\") == 0 ||\n              strcmp (dent->d_name, \"machine-id\") == 0 ||\n              strcmp (dent->d_name, \"resolv.conf\") == 0 ||\n              strcmp (dent->d_name, \"host.conf\") == 0 ||\n              strcmp (dent->d_name, \"hosts\") == 0 ||\n              strcmp (dent->d_name, \"gai.conf\") == 0 ||\n              strcmp (dent->d_name, \"localtime\") == 0 ||\n              strcmp (dent->d_name, \"timezone\") == 0 ||\n              strcmp (dent->d_name, \"pkcs11\") == 0)\n            continue;\n\n          src = g_build_filename (flatpak_file_get_path_cached (etc), dent->d_name, NULL);\n          dest = g_build_filename (\"/etc\", dent->d_name, NULL);\n          if (dent->d_type == DT_LNK)\n            {\n              g_autofree char *target = NULL;\n\n              target = glnx_readlinkat_malloc (dfd_iter.fd, dent->d_name,\n                                               NULL, error);\n              if (target == NULL)\n                return FALSE;\n\n              flatpak_bwrap_add_args (bwrap, \"--symlink\", target, dest, NULL);\n            }\n          else\n            {\n              flatpak_bwrap_add_args (bwrap, \"--ro-bind\", src, dest, NULL);\n            }\n        }\n    }\n\n  if (app_id_dir != NULL)\n    {\n      g_autoptr(GFile) app_cache_dir = g_file_get_child (app_id_dir, \"cache\");\n      g_autoptr(GFile) app_tmp_dir = g_file_get_child (app_cache_dir, \"tmp\");\n      g_autoptr(GFile) app_data_dir = g_file_get_child (app_id_dir, \"data\");\n      g_autoptr(GFile) app_config_dir = g_file_get_child (app_id_dir, \"config\");\n\n      flatpak_bwrap_add_args (bwrap,\n                              /* These are nice to have as a fixed path */\n                              \"--bind\", flatpak_file_get_path_cached (app_cache_dir), \"/var/cache\",\n                              \"--bind\", flatpak_file_get_path_cached (app_data_dir), \"/var/data\",\n                              \"--bind\", flatpak_file_get_path_cached (app_config_dir), \"/var/config\",\n                              \"--bind\", flatpak_file_get_path_cached (app_tmp_dir), \"/var/tmp\",\n                              NULL);\n    }\n\n  flatpak_run_setup_usr_links (bwrap, runtime_files, NULL);\n\n  add_tzdata_args (bwrap, runtime_files);\n\n  pers = PER_LINUX;\n\n  if ((flags & FLATPAK_RUN_FLAG_SET_PERSONALITY) &&\n      flatpak_is_linux32_arch (arch))\n    {\n      g_debug (\"Setting personality linux32\");\n      pers = PER_LINUX32;\n    }\n\n  /* Always set the personallity, and clear all weird flags */\n  personality (pers);\n\n#ifdef ENABLE_SECCOMP\n  if (!setup_seccomp (bwrap, arch, pers, flags, error))\n    return FALSE;\n#endif\n\n  if ((flags & FLATPAK_RUN_FLAG_WRITABLE_ETC) == 0)\n    add_monitor_path_args ((flags & FLATPAK_RUN_FLAG_NO_SESSION_HELPER) == 0, bwrap);\n\n  return TRUE;\n}", "func_hash": 192672726911907640804685852007123379612, "file_name": "flatpak-run.c", "file_hash": 32398709380082441128978861691951488575, "cwe": ["CWE-20"], "cve": "CVE-2021-41133", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41133"}
{"idx": 181940, "project": "Chrome", "commit_id": "fb83de09f2c986ee91741f3a2776feea0e18e3f6", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/fb83de09f2c986ee91741f3a2776feea0e18e3f6", "commit_message": "None", "target": 0, "func": " void OverlayWindowViews::ButtonPressed(views::Button* sender,\n                                       const ui::Event& event) {\n  if (sender == close_controls_view_.get())\n    controller_->Close(true /* should_pause_video */,\n                       true /* should_reset_pip_player */);\n\n  if (sender == play_pause_controls_view_.get())\n    TogglePlayPause();\n\n  if (sender == first_custom_controls_view_.get())\n    controller_->CustomControlPressed(first_custom_controls_view_->id());\n\n  if (sender == second_custom_controls_view_.get())\n    controller_->CustomControlPressed(second_custom_controls_view_->id());\n}\n", "func_hash": 335498214510436229672470102293461790668, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 96958, "project": "Chrome", "commit_id": "3c1864079c441ea2e08f882acaaf441f78a6de3d", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/3c1864079c441ea2e08f882acaaf441f78a6de3d", "commit_message": "None", "target": 0, "func": "void encode(ArgumentEncoder* encoder, CFURLRef url)\n{\n    CFURLRef baseURL = CFURLGetBaseURL(url);\n    encoder->encodeBool(baseURL);\n    if (baseURL)\n        encode(encoder, baseURL);\n\n    encode(encoder, CFURLGetString(url));\n}\n", "func_hash": 305318043598852328788919451097842805535, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 198552, "project": "engine", "commit_id": "7df766124f87768b43b9e8947c5a01e17545772c", "project_url": "https://github.com/gost-engine/engine", "commit_url": "https://github.com/gost-engine/engine/commit/7df766124f87768b43b9e8947c5a01e17545772c", "commit_message": "Fix buffer overrun in creating key transport blob according to RFC 9189, 4.2.4.2\n\nResolves: CVE-2022-29242", "target": 1, "func": "static int pkey_GOST_ECcp_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out,\n                           size_t *out_len, const unsigned char *key,\n                           size_t key_len)\n{\n    GOST_KEY_TRANSPORT *gkt = NULL;\n    EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx);\n    struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(pctx);\n    int pkey_nid = EVP_PKEY_base_id(pubk);\n    ASN1_OBJECT *crypt_params_obj = (pkey_nid == NID_id_GostR3410_2001 || pkey_nid == NID_id_GostR3410_2001DH) ?\n        OBJ_nid2obj(NID_id_Gost28147_89_CryptoPro_A_ParamSet) :\n        OBJ_nid2obj(NID_id_tc26_gost_28147_param_Z);\n    const struct gost_cipher_info *param =\n        get_encryption_params(crypt_params_obj);\n    unsigned char ukm[8], shared_key[32], crypted_key[44];\n    int ret = 0;\n    int key_is_ephemeral = 1;\n    gost_ctx cctx;\n    EVP_PKEY *sec_key = EVP_PKEY_CTX_get0_peerkey(pctx);\n    if (data->shared_ukm_size) {\n        memcpy(ukm, data->shared_ukm, 8);\n    } else {\n        if (RAND_bytes(ukm, 8) <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, GOST_R_RNG_ERROR);\n            return 0;\n        }\n    }\n    if (!param)\n        goto err;\n    /* Check for private key in the peer_key of context */\n    if (sec_key) {\n        key_is_ephemeral = 0;\n        if (!gost_get0_priv_key(sec_key)) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                    GOST_R_NO_PRIVATE_PART_OF_NON_EPHEMERAL_KEYPAIR);\n            goto err;\n        }\n    } else {\n        key_is_ephemeral = 1;\n        if (out) {\n            sec_key = EVP_PKEY_new();\n            if (!EVP_PKEY_assign(sec_key, EVP_PKEY_base_id(pubk), EC_KEY_new())\n                || !EVP_PKEY_copy_parameters(sec_key, pubk)\n                || !gost_ec_keygen(EVP_PKEY_get0(sec_key))) {\n                GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                        GOST_R_ERROR_COMPUTING_SHARED_KEY);\n                goto err;\n            }\n        }\n    }\n    if (out) {\n        int dgst_nid = NID_undef;\n        EVP_PKEY_get_default_digest_nid(pubk, &dgst_nid);\n        if (dgst_nid == NID_id_GostR3411_2012_512)\n            dgst_nid = NID_id_GostR3411_2012_256;\n\n        if (!VKO_compute_key(shared_key,\n                             EC_KEY_get0_public_key(EVP_PKEY_get0(pubk)),\n                             EVP_PKEY_get0(sec_key), ukm, 8, dgst_nid)) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                    GOST_R_ERROR_COMPUTING_SHARED_KEY);\n            goto err;\n        }\n        gost_init(&cctx, param->sblock);\n        keyWrapCryptoPro(&cctx, shared_key, ukm, key, crypted_key);\n    }\n    gkt = GOST_KEY_TRANSPORT_new();\n    if (!gkt) {\n        goto err;\n    }\n    if (!ASN1_OCTET_STRING_set(gkt->key_agreement_info->eph_iv, ukm, 8)) {\n        goto err;\n    }\n    if (!ASN1_OCTET_STRING_set(gkt->key_info->imit, crypted_key + 40, 4)) {\n        goto err;\n    }\n    if (!ASN1_OCTET_STRING_set\n        (gkt->key_info->encrypted_key, crypted_key + 8, 32)) {\n        goto err;\n    }\n    if (key_is_ephemeral) {\n        if (!X509_PUBKEY_set\n            (&gkt->key_agreement_info->ephem_key, out ? sec_key : pubk)) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                    GOST_R_CANNOT_PACK_EPHEMERAL_KEY);\n            goto err;\n        }\n    }\n    ASN1_OBJECT_free(gkt->key_agreement_info->cipher);\n    gkt->key_agreement_info->cipher = OBJ_nid2obj(param->nid);\n    if (key_is_ephemeral)\n        EVP_PKEY_free(sec_key);\n    if (!key_is_ephemeral) {\n        /* Set control \"public key from client certificate used\" */\n        if (EVP_PKEY_CTX_ctrl(pctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 3, NULL)\n            <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, GOST_R_CTRL_CALL_FAILED);\n            goto err;\n        }\n    }\n    if ((*out_len = i2d_GOST_KEY_TRANSPORT(gkt, out ? &out : NULL)) > 0)\n        ret = 1;\n    OPENSSL_cleanse(shared_key, sizeof(shared_key));\n    GOST_KEY_TRANSPORT_free(gkt);\n    return ret;\n err:\n    OPENSSL_cleanse(shared_key, sizeof(shared_key));\n    if (key_is_ephemeral)\n        EVP_PKEY_free(sec_key);\n    GOST_KEY_TRANSPORT_free(gkt);\n    return -1;\n}", "func_hash": 89031298057192357207711119163171237832, "file_name": "gost_ec_keyx.c", "file_hash": 151021593107318778140165694464640459536, "cwe": ["CWE-787"], "cve": "CVE-2022-29242", "cve_desc": "GOST engine is a reference implementation of the Russian GOST crypto algorithms for OpenSSL. TLS clients using GOST engine when ciphersuite `TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC` is agreed and the server uses 512 bit GOST secret keys are vulnerable to buffer overflow. GOST engine version 3.0.1 contains a patch for this issue. Disabling ciphersuite `TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC` is a possible workaround.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-29242"}
{"idx": 90839, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  void DidDumpQuotaTable(const QuotaTableEntries& entries) {\n    quota_entries_ = entries;\n  }\n", "func_hash": 219969577054585516743561590926308385178, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90828, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  void set_db_disabled(bool db_disabled) {\n    db_disabled_ = db_disabled;\n  }\n", "func_hash": 65245838285767773216647767618793825540, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 195261, "project": "tensorflow", "commit_id": "955059813cc325dc1db5e2daa6221271406d4439", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/955059813cc325dc1db5e2daa6221271406d4439", "commit_message": "Check for type inference error on node construction.\n\nPiperOrigin-RevId: 409415804\nChange-Id: Ieb6e020906b96f522bf8e2fa103715ddbbdc434a", "target": 1, "func": "Node* Graph::AddNode(NodeDef node_def, Status* status) {\n  const OpRegistrationData* op_reg_data;\n  status->Update(ops_.LookUp(node_def.op(), &op_reg_data));\n  if (!status->ok()) return nullptr;\n\n  DataTypeVector inputs;\n  DataTypeVector outputs;\n  status->Update(\n      InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs));\n  if (!status->ok()) {\n    *status = AttachDef(*status, node_def);\n    return nullptr;\n  }\n\n  Node::NodeClass node_class = op_reg_data->is_function_op\n                                   ? Node::NC_FUNCTION_OP\n                                   : Node::GetNodeClassForOp(node_def.op());\n\n  if (op_reg_data->type_ctor != nullptr) {\n    VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();\n    const auto ctor_type =\n        full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);\n    const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();\n    if (ctor_typedef.type_id() != TFT_UNSET) {\n      *(node_def.mutable_experimental_type()) = ctor_typedef;\n    }\n  } else {\n    VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();\n  }\n\n  Node* node = AllocateNode(std::make_shared<NodeProperties>(\n                                &op_reg_data->op_def, std::move(node_def),\n                                inputs, outputs, op_reg_data->fwd_type_fn),\n                            nullptr, node_class);\n  return node;\n}", "func_hash": 216608112162338080739127582529653382623, "file_name": "graph.cc", "file_hash": 171004513035817799651733534811388619872, "cwe": ["CWE-754"], "cve": "CVE-2022-23590", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. A `GraphDef` from a TensorFlow `SavedModel` can be maliciously altered to cause a TensorFlow process to crash due to encountering a `StatusOr` value that is an error and forcibly extracting the value from it. We have patched the issue in multiple GitHub commits and these will be included in TensorFlow 2.8.0 and TensorFlow 2.7.1, as both are affected.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23590"}
{"idx": 175697, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual void UpdateSystemInfo() {}\n", "func_hash": 274675798593492238376005335658074197744, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 210453, "project": "ghostpdl", "commit_id": "366ad48d076c1aa4c8f83c65011258a04e348207", "project_url": "https://github.com/ArtifexSoftware/ghostpdl", "commit_url": "https://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=366ad48d076c1aa4c8f83c65011258a04e348207", "commit_message": "Bug 701815: avoid uninitialised bytes being >7, which broke indexing.\n\nFixes:\n    ./sanbin/gs -dBATCH -dNOPAUSE -sOutputFile=tmp -sDEVICE=jetp3852 ../bug-701815.pdf", "target": 1, "func": "jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\n#define DATA_SIZE (LINE_SIZE * 8)\n\n    unsigned int cnt_2prn;\n    unsigned int count,tempcnt;\n    unsigned char vtp,cntc1,cntc2;\n    int line_size_color_plane;\n\n    byte data[DATA_SIZE];\n    byte plane_data[LINE_SIZE * 3];\n\n    /* Set initial condition for printer */\n    gp_fputs(\"\\033@\",prn_stream);\n\n    /* Send each scan line in turn */\n    {\n        int lnum;\n        int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int num_blank_lines = 0;\n\n        if (line_size > DATA_SIZE) {\n            emprintf2(pdev->memory, \"invalid resolution and/or width gives line_size = %d, max. is %d\\n\",\n                      line_size, DATA_SIZE);\n            return_error(gs_error_rangecheck);\n        }\n\n        for ( lnum = 0; lnum < pdev->height; lnum++ ) {\n            byte *end_data = data + line_size;\n            gdev_prn_copy_scan_lines(pdev, lnum,\n                                     (byte *)data, line_size);\n            /* Remove trailing 0s. */\n            while ( end_data > data && end_data[-1] == 0 )\n                end_data--;\n            if ( end_data == data ) {\n                /* Blank line */\n                num_blank_lines++;\n            } else {\n                int i;\n                byte *odp;\n                byte *row;\n\n                /* Pad with 0s to fill out the last */\n                /* block of 8 bytes. */\n                memset(end_data, 0, 7);\n\n                /* Transpose the data to get pixel planes. */\n                for ( i = 0, odp = plane_data; i < DATA_SIZE;\n                      i += 8, odp++\n                    ) { /* The following is for 16-bit machines */\n#define spread3(c)\\\n { 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }\n                    static ulong spr40[8] = spread3(0x40);\n                    static ulong spr8[8] = spread3(8);\n                    static ulong spr2[8] = spread3(2);\n                    register byte *dp = data + i;\n                    register ulong pword =\n                                     (spr40[dp[0]] << 1) +\n                                     (spr40[dp[1]]) +\n                                     (spr40[dp[2]] >> 1) +\n                                     (spr8[dp[3]] << 1) +\n                                     (spr8[dp[4]]) +\n                                     (spr8[dp[5]] >> 1) +\n                                     (spr2[dp[6]]) +\n                                     (spr2[dp[7]] >> 1);\n                    odp[0] = (byte)(pword >> 16);\n                    odp[LINE_SIZE] = (byte)(pword >> 8);\n                    odp[LINE_SIZE*2] = (byte)(pword);\n                }\n                /* Skip blank lines if any */\n                if ( num_blank_lines > 0 ) {\n                    /* Do \"dot skips\" */\n                    while(num_blank_lines > 255) {\n                        gp_fputs(\"\\033e\\377\",prn_stream);\n                        num_blank_lines -= 255;\n                    }\n                    vtp = num_blank_lines;\n                    gp_fprintf(prn_stream,\"\\033e%c\",vtp);\n                    num_blank_lines = 0;\n                }\n\n                /* Transfer raster graphics in the order R, G, B. */\n                /* Apparently it is stored in B, G, R */\n                /* Calculate the amount of data to send by what */\n                /* Ghostscript tells us the scan line_size in (bytes) */\n\n                count = line_size / 3;\n                line_size_color_plane = count / 3;\n                cnt_2prn = line_size_color_plane * 3 + 5;\n                tempcnt = cnt_2prn;\n                cntc1 = (tempcnt & 0xFF00) >> 8;\n                cntc2 = (tempcnt & 0x00FF);\n                gp_fprintf(prn_stream, \"\\033[O%c%c\\200\\037\",cntc2,cntc1);\n                gp_fputc('\\000',prn_stream);\n                gp_fputs(\"\\124\\124\",prn_stream);\n\n                for ( row = plane_data + LINE_SIZE * 2, i = 0;\n                      i < 3; row -= LINE_SIZE, i++ ) {\n                    int jj;\n                    byte ctemp;\n                    odp = row;\n                    /* Complement bytes */\n                    for (jj=0; jj< line_size_color_plane; jj++) {\n                        ctemp = *odp;\n                        *odp++ = ~ctemp;\n                    }\n                    gp_fwrite(row, sizeof(byte),\n                              line_size_color_plane, prn_stream);\n                }\n            }\n        }\n    }\n\n    /* eject page */\n    gp_fputs(\"\\014\", prn_stream);\n\n    return 0;\n}", "func_hash": 93148813029453334596229816591999204427, "file_name": "gdev3852.c", "file_hash": 229444063869235911698513683887059150132, "cwe": ["CWE-120"], "cve": "CVE-2020-16302", "cve_desc": "A buffer overflow vulnerability in jetp3852_print_page() in devices/gdev3852.c of Artifex Software GhostScript v9.50 allows a remote attacker to escalate privileges via a crafted PDF file. This is fixed in v9.51.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-16302"}
{"idx": 221459, "project": "flatpak", "commit_id": "89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "commit_message": "run: Add cross-references for some other seccomp syscall filters\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "target": 0, "func": "flatpak_run_add_pulseaudio_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char *pulseaudio_server = flatpak_run_get_pulseaudio_server ();\n  g_autofree char *pulseaudio_socket = NULL;\n  g_autofree char *pulse_runtime_dir = flatpak_run_get_pulse_runtime_dir ();\n\n  if (pulseaudio_server)\n    pulseaudio_socket = flatpak_run_parse_pulse_server (pulseaudio_server);\n\n  if (!pulseaudio_socket)\n    {\n      pulseaudio_socket = g_build_filename (pulse_runtime_dir, \"native\", NULL);\n\n      if (!g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n        g_clear_pointer (&pulseaudio_socket, g_free);\n    }\n\n  if (!pulseaudio_socket)\n    {\n      pulseaudio_socket = realpath (\"/var/run/pulse/native\", NULL);\n\n      if (pulseaudio_socket && !g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n        g_clear_pointer (&pulseaudio_socket, g_free);\n    }\n\n  flatpak_bwrap_unset_env (bwrap, \"PULSE_SERVER\");\n\n  if (pulseaudio_socket && g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n    {\n      static const char sandbox_socket_path[] = \"/run/flatpak/pulse/native\";\n      static const char pulse_server[] = \"unix:/run/flatpak/pulse/native\";\n      static const char config_path[] = \"/run/flatpak/pulse/config\";\n      gboolean share_shm = FALSE; /* TODO: When do we add this? */\n      g_autofree char *client_config = g_strdup_printf (\"enable-shm=%s\\n\", share_shm ? \"yes\" : \"no\");\n\n      /* FIXME - error handling */\n      if (!flatpak_bwrap_add_args_data (bwrap, \"pulseaudio\", client_config, -1, config_path, NULL))\n        return;\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", pulseaudio_socket, sandbox_socket_path,\n                              NULL);\n\n      flatpak_bwrap_set_env (bwrap, \"PULSE_SERVER\", pulse_server, TRUE);\n      flatpak_bwrap_set_env (bwrap, \"PULSE_CLIENTCONFIG\", config_path, TRUE);\n      flatpak_bwrap_add_runtime_dir_member (bwrap, \"pulse\");\n    }\n  else\n    g_debug (\"Could not find pulseaudio socket\");\n\n  /* Also allow ALSA access. This was added in 1.8, and is not ideally named. However,\n   * since the practical permission of ALSA and PulseAudio are essentially the same, and\n   * since we don't want to add more permissions for something we plan to replace with\n   * portals/pipewire going forward we reinterpret pulseaudio to also mean ALSA.\n   */\n  if (g_file_test (\"/dev/snd\", G_FILE_TEST_IS_DIR))\n    flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/snd\", \"/dev/snd\", NULL);\n}", "func_hash": 38890507665134696353107676973681282846, "file_name": "flatpak-run.c", "file_hash": 32398709380082441128978861691951488575, "cwe": ["CWE-20"], "cve": "CVE-2021-41133", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41133"}
{"idx": 219941, "project": "glewlwyd", "commit_id": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "project_url": "https://github.com/babelouest/glewlwyd", "commit_url": "https://github.com/babelouest/glewlwyd/commit/125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "commit_message": "Fix update session when auth fail", "target": 0, "func": "int callback_glewlwyd_get_user_module_list (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  UNUSED(request);\n  struct config_elements * config = (struct config_elements *)user_data;\n  json_t * j_module;\n  \n  j_module = get_user_module_list(config);\n  if (check_result_value(j_module, G_OK)) {\n    ulfius_set_json_body_response(response, 200, json_object_get(j_module, \"module\"));\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_get_user_module_list - Error get_user_module_list\");\n    response->status = 500;\n  }\n  json_decref(j_module);\n  return U_CALLBACK_CONTINUE;\n}", "func_hash": 124551755567429373400951833138878152992, "file_name": "webservice.c", "file_hash": 287798817606377336444620654835011177393, "cwe": ["CWE-287"], "cve": "CVE-2021-45379", "cve_desc": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-45379"}
{"idx": 210283, "project": "dpdk", "commit_id": "af74f7db384ed149fe42b21dbd7975f8a54ef227", "project_url": "https://github.com/DPDK/dpdk", "commit_url": "https://github.com/DPDK/dpdk/commit/af74f7db384ed149fe42b21dbd7975f8a54ef227", "commit_message": "vhost: fix FD leak with inflight messages\n\nEven if unlikely, a buggy vhost-user master might attach fds to inflight\nmessages. Add checks like for other types of vhost-user messages.\n\nFixes: d87f1a1cb7b6 (\"vhost: support inflight info sharing\")\nCc: stable@dpdk.org\n\nSigned-off-by: David Marchand <david.marchand@redhat.com>\nReviewed-by: Maxime Coquelin <maxime.coquelin@redhat.com>", "target": 1, "func": "vhost_user_set_inflight_fd(struct virtio_net **pdev,\n\t\t\t   struct vhu_msg_context *ctx,\n\t\t\t   int main_fd __rte_unused)\n{\n\tuint64_t mmap_size, mmap_offset;\n\tuint16_t num_queues, queue_size;\n\tstruct virtio_net *dev = *pdev;\n\tuint32_t pervq_inflight_size;\n\tstruct vhost_virtqueue *vq;\n\tvoid *addr;\n\tint fd, i;\n\tint numa_node = SOCKET_ID_ANY;\n\n\tfd = ctx->fds[0];\n\tif (ctx->msg.size != sizeof(ctx->msg.payload.inflight) || fd < 0) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid set_inflight_fd message size is %d,fd is %d\\n\",\n\t\t\tdev->ifname, ctx->msg.size, fd);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\tmmap_size = ctx->msg.payload.inflight.mmap_size;\n\tmmap_offset = ctx->msg.payload.inflight.mmap_offset;\n\tnum_queues = ctx->msg.payload.inflight.num_queues;\n\tqueue_size = ctx->msg.payload.inflight.queue_size;\n\n\tif (vq_is_packed(dev))\n\t\tpervq_inflight_size = get_pervq_shm_size_packed(queue_size);\n\telse\n\t\tpervq_inflight_size = get_pervq_shm_size_split(queue_size);\n\n\tVHOST_LOG_CONFIG(INFO, \"(%s) set_inflight_fd mmap_size: %\"PRIu64\"\\n\",\n\t\t\tdev->ifname, mmap_size);\n\tVHOST_LOG_CONFIG(INFO, \"(%s) set_inflight_fd mmap_offset: %\"PRIu64\"\\n\",\n\t\t\tdev->ifname, mmap_offset);\n\tVHOST_LOG_CONFIG(INFO, \"(%s) set_inflight_fd num_queues: %u\\n\", dev->ifname, num_queues);\n\tVHOST_LOG_CONFIG(INFO, \"(%s) set_inflight_fd queue_size: %u\\n\", dev->ifname, queue_size);\n\tVHOST_LOG_CONFIG(INFO, \"(%s) set_inflight_fd fd: %d\\n\", dev->ifname, fd);\n\tVHOST_LOG_CONFIG(INFO, \"(%s) set_inflight_fd pervq_inflight_size: %d\\n\",\n\t\t\tdev->ifname, pervq_inflight_size);\n\n\t/*\n\t * If VQ 0 has already been allocated, try to allocate on the same\n\t * NUMA node. It can be reallocated later in numa_realloc().\n\t */\n\tif (dev->nr_vring > 0)\n\t\tnuma_node = dev->virtqueue[0]->numa_node;\n\n\tif (!dev->inflight_info) {\n\t\tdev->inflight_info = rte_zmalloc_socket(\"inflight_info\",\n\t\t\t\tsizeof(struct inflight_mem_info), 0, numa_node);\n\t\tif (dev->inflight_info == NULL) {\n\t\t\tVHOST_LOG_CONFIG(ERR, \"(%s) failed to alloc dev inflight area\\n\",\n\t\t\t\t\tdev->ifname);\n\t\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t\t}\n\t\tdev->inflight_info->fd = -1;\n\t}\n\n\tif (dev->inflight_info->addr) {\n\t\tmunmap(dev->inflight_info->addr, dev->inflight_info->size);\n\t\tdev->inflight_info->addr = NULL;\n\t}\n\n\taddr = mmap(0, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,\n\t\t    fd, mmap_offset);\n\tif (addr == MAP_FAILED) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) failed to mmap share memory.\\n\", dev->ifname);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\tif (dev->inflight_info->fd >= 0) {\n\t\tclose(dev->inflight_info->fd);\n\t\tdev->inflight_info->fd = -1;\n\t}\n\n\tdev->inflight_info->fd = fd;\n\tdev->inflight_info->addr = addr;\n\tdev->inflight_info->size = mmap_size;\n\n\tfor (i = 0; i < num_queues; i++) {\n\t\tvq = dev->virtqueue[i];\n\t\tif (!vq)\n\t\t\tcontinue;\n\n\t\tif (vq_is_packed(dev)) {\n\t\t\tvq->inflight_packed = addr;\n\t\t\tvq->inflight_packed->desc_num = queue_size;\n\t\t} else {\n\t\t\tvq->inflight_split = addr;\n\t\t\tvq->inflight_split->desc_num = queue_size;\n\t\t}\n\t\taddr = (void *)((char *)addr + pervq_inflight_size);\n\t}\n\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "func_hash": 13095885723937845585670342074688916492, "file_name": "vhost_user.c", "file_hash": 63503821127437927181843920110423384686, "cwe": ["CWE-703"], "cve": "CVE-2022-0669", "cve_desc": "A flaw was found in dpdk. This flaw allows a malicious vhost-user master to attach an unexpected number of fds as ancillary data to VHOST_USER_GET_INFLIGHT_FD / VHOST_USER_SET_INFLIGHT_FD messages that are not closed by the vhost-user slave. By sending such messages continuously, the vhost-user master exhausts available fd in the vhost-user slave process, leading to a denial of service.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0669"}
{"idx": 95906, "project": "Chrome", "commit_id": "45bae236b03f577ed6682ef4c7ef3ee006de5e5a", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/45bae236b03f577ed6682ef4c7ef3ee006de5e5a", "commit_message": "None", "target": 0, "func": "void AddUsageStatsWorkItems(const InstallationState& original_state,\n                            const InstallerState& installer_state,\n                            WorkItemList* install_list) {\n  DCHECK(installer_state.operation() == InstallerState::MULTI_INSTALL ||\n         installer_state.operation() == InstallerState::MULTI_UPDATE);\n\n  HKEY root_key = installer_state.root_key();\n  bool value_found = false;\n  DWORD usagestats = 0;\n  const Products& products = installer_state.products();\n\n  for (Products::const_iterator scan = products.begin(), end = products.end();\n       !value_found && scan != end; ++scan) {\n    BrowserDistribution* dist = (*scan)->distribution();\n    const ProductState* product_state =\n        original_state.GetNonVersionedProductState(\n            installer_state.system_install(), dist->GetType());\n    value_found = product_state->GetUsageStats(&usagestats);\n  }\n\n  if (value_found) {\n    std::wstring state_key(\n        installer_state.multi_package_binaries_distribution()->GetStateKey());\n    install_list->AddCreateRegKeyWorkItem(root_key, state_key);\n    install_list->AddSetRegValueWorkItem(root_key, state_key,\n                                         google_update::kRegUsageStatsField,\n                                         usagestats, false);\n\n    for (Products::const_iterator scan = products.begin(), end = products.end();\n         scan != end; ++scan) {\n      BrowserDistribution* dist = (*scan)->distribution();\n      if (installer_state.system_install()) {\n        install_list->AddDeleteRegValueWorkItem(\n            root_key, dist->GetStateMediumKey(),\n            google_update::kRegUsageStatsField);\n        install_list->AddDeleteRegValueWorkItem(\n            HKEY_CURRENT_USER, dist->GetStateKey(),\n            google_update::kRegUsageStatsField);\n      }\n      install_list->AddDeleteRegValueWorkItem(root_key, dist->GetStateKey(),\n          google_update::kRegUsageStatsField);\n    }\n  }\n}\n", "func_hash": 147981642094506301187936301171596353125, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90845, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  void DidGetModifiedOrigins(const std::set<GURL>& origins, StorageType type) {\n    modified_origins_ = origins;\n    modified_origins_type_ = type;\n  }\n", "func_hash": 303618201146505061336859258130906191991, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90789, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  GlobalUsageCallback* NewWaitableGlobalUsageCallback() {\n    ++waiting_callbacks_;\n    return callback_factory_.NewCallback(\n            &UsageAndQuotaDispatcherTask::DidGetGlobalUsage);\n  }\n", "func_hash": 327829511280689427137325844698412968707, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90809, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "void QuotaManager::StartEviction() {\n  DCHECK(!temporary_storage_evictor_.get());\n  temporary_storage_evictor_.reset(new QuotaTemporaryStorageEvictor(this,\n      kEvictionIntervalInMilliSeconds));\n  temporary_storage_evictor_->Start();\n}\n", "func_hash": 307577243601854639342283289386358217455, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 220827, "project": "tensorflow", "commit_id": "8c6f391a2282684a25cbfec7687bd5d35261a209", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/8c6f391a2282684a25cbfec7687bd5d35261a209", "commit_message": "[lite] Add check for bias_size is zero to avoid division by zero. This shouldn't happen for properly converted models. Just safety check\n\nPiperOrigin-RevId: 416383645\nChange-Id: If8e508bf696ae8ecfb927e69c139a8ccf7fe60cb", "target": 0, "func": "gemmlowp::FixedPoint<tRawType, tIntegerBits> SaturatingSub(\n    gemmlowp::FixedPoint<tRawType, tIntegerBits> a,\n    gemmlowp::FixedPoint<tRawType, tIntegerBits> b) {\n  return gemmlowp::FixedPoint<tRawType, tIntegerBits>::FromRaw(\n      SaturatingSub(a.raw(), b.raw()));\n}", "func_hash": 315277933086349190224008758129439590671, "file_name": "common.h", "file_hash": 206010119069068373550820723284960883967, "cwe": ["CWE-369"], "cve": "CVE-2022-23557", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would trigger a division by zero in `BiasAndClamp` implementation. There is no check that the `bias_size` is non zero. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23557"}
{"idx": 210619, "project": "vim", "commit_id": "8d02ce1ed75d008c34a5c9aaa51b67cbb9d33baa", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/8d02ce1ed75d008c34a5c9aaa51b67cbb9d33baa", "commit_message": "patch 8.2.4217: illegal memory access when undo makes Visual area invalid\n\nProblem:    Illegal memory access when undo makes Visual area invalid.\nSolution:   Correct the Visual area after undo.", "target": 1, "func": "u_undo_end(\n    int\t\tdid_undo,\t// just did an undo\n    int\t\tabsolute)\t// used \":undo N\"\n{\n    char\t*msgstr;\n    u_header_T\t*uhp;\n    char_u\tmsgbuf[80];\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_UNDO) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n\n    if (global_busy\t    // no messages now, wait until global is finished\n\t    || !messaging())  // 'lazyredraw' set, don't do messages now\n\treturn;\n\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t--u_newcount;\n\n    u_oldcount -= u_newcount;\n    if (u_oldcount == -1)\n\tmsgstr = N_(\"more line\");\n    else if (u_oldcount < 0)\n\tmsgstr = N_(\"more lines\");\n    else if (u_oldcount == 1)\n\tmsgstr = N_(\"line less\");\n    else if (u_oldcount > 1)\n\tmsgstr = N_(\"fewer lines\");\n    else\n    {\n\tu_oldcount = u_newcount;\n\tif (u_newcount == 1)\n\t    msgstr = N_(\"change\");\n\telse\n\t    msgstr = N_(\"changes\");\n    }\n\n    if (curbuf->b_u_curhead != NULL)\n    {\n\t// For \":undo N\" we prefer a \"after #N\" message.\n\tif (absolute && curbuf->b_u_curhead->uh_next.ptr != NULL)\n\t{\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n\t    did_undo = FALSE;\n\t}\n\telse if (did_undo)\n\t    uhp = curbuf->b_u_curhead;\n\telse\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n    }\n    else\n\tuhp = curbuf->b_u_newhead;\n\n    if (uhp == NULL)\n\t*msgbuf = NUL;\n    else\n\tadd_time(msgbuf, sizeof(msgbuf), uhp->uh_time);\n\n#ifdef FEAT_CONCEAL\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_buffer == curbuf && wp->w_p_cole > 0)\n\t\tredraw_win_later(wp, NOT_VALID);\n\t}\n    }\n#endif\n\n    smsg_attr_keep(0, _(\"%ld %s; %s #%ld  %s\"),\n\t    u_oldcount < 0 ? -u_oldcount : u_oldcount,\n\t    _(msgstr),\n\t    did_undo ? _(\"before\") : _(\"after\"),\n\t    uhp == NULL ? 0L : uhp->uh_seq,\n\t    msgbuf);\n}", "func_hash": 216816943849658280412191138013917994713, "file_name": "undo.c", "file_hash": 258314296511456990975181275339726726034, "cwe": ["CWE-787"], "cve": "CVE-2022-0368", "cve_desc": "Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0368"}
{"idx": 195230, "project": "pjproject", "commit_id": "f74c1fc22b760d2a24369aa72c74c4a9ab985859", "project_url": "https://github.com/pjsip/pjproject", "commit_url": "https://github.com/pjsip/pjproject/commit/f74c1fc22b760d2a24369aa72c74c4a9ab985859", "commit_message": "Merge pull request from GHSA-r374-qrwv-86hh", "target": 1, "func": "void pjmedia_rtcp_xr_rx_rtcp_xr( pjmedia_rtcp_xr_session *sess,\n\t\t\t\t const void *pkt,\n\t\t\t\t pj_size_t size)\n{\n    const pjmedia_rtcp_xr_pkt\t      *rtcp_xr = (pjmedia_rtcp_xr_pkt*) pkt;\n    const pjmedia_rtcp_xr_rb_rr_time  *rb_rr_time = NULL;\n    const pjmedia_rtcp_xr_rb_dlrr     *rb_dlrr = NULL;\n    const pjmedia_rtcp_xr_rb_stats    *rb_stats = NULL;\n    const pjmedia_rtcp_xr_rb_voip_mtc *rb_voip_mtc = NULL;\n    const pjmedia_rtcp_xr_rb_header   *rb_hdr = (pjmedia_rtcp_xr_rb_header*) \n\t\t\t\t\t\trtcp_xr->buf;\n    unsigned pkt_len, rb_len;\n\n    if (rtcp_xr->common.pt != RTCP_XR)\n\treturn;\n\n    pkt_len = pj_ntohs((pj_uint16_t)rtcp_xr->common.length);\n\n    if ((pkt_len + 1) > (size / 4))\n\treturn;\n\n    /* Parse report rpt_types */\n    while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)\n    {\t\n\trb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);\n\n\t/* Just skip any block with length == 0 (no report content) */\n\tif (rb_len) {\n\t    switch (rb_hdr->bt) {\n\t\tcase BT_RR_TIME:\n\t\t    rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*) rb_hdr;\n\t\t    break;\n\t\tcase BT_DLRR:\n\t\t    rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*) rb_hdr;\n\t\t    break;\n\t\tcase BT_STATS:\n\t\t    rb_stats = (pjmedia_rtcp_xr_rb_stats*) rb_hdr;\n\t\t    break;\n\t\tcase BT_VOIP_METRICS:\n\t\t    rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*) rb_hdr;\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n\trb_hdr = (pjmedia_rtcp_xr_rb_header*)\n\t\t ((pj_int32_t*)rb_hdr + rb_len + 1);\n    }\n\n    /* Receiving RR Time */\n    if (rb_rr_time) {\n\t/* Save LRR from NTP timestamp of the RR time block report */\n\tsess->rx_lrr = ((pj_ntohl(rb_rr_time->ntp_sec) & 0x0000FFFF) << 16) | \n\t\t       ((pj_ntohl(rb_rr_time->ntp_frac) >> 16) & 0xFFFF);\n\n\t/* Calculate RR arrival time for DLRR */\n\tpj_get_timestamp(&sess->rx_lrr_time);\n\n\tTRACE_((sess->name, \"Rx RTCP SR: ntp_ts=%p\", sess->rx_lrr,\n\t       (pj_uint32_t)(sess->rx_lrr_time.u64*65536/\n\t\t\t     sess->rtcp_session->ts_freq.u64)));\n    }\n\n    /* Receiving DLRR */\n    if (rb_dlrr) {\n\tpj_uint32_t lrr, now, dlrr;\n\tpj_uint64_t eedelay;\n\tpjmedia_rtcp_ntp_rec ntp;\n\n\t/* LRR is the middle 32bit of NTP. It has 1/65536 second \n\t * resolution \n\t */\n\tlrr = pj_ntohl(rb_dlrr->item.lrr);\n\n\t/* DLRR is delay since LRR, also in 1/65536 resolution */\n\tdlrr = pj_ntohl(rb_dlrr->item.dlrr);\n\n\t/* Get current time, and convert to 1/65536 resolution */\n\tpjmedia_rtcp_get_ntp_time(sess->rtcp_session, &ntp);\n\tnow = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);\n\n\t/* End-to-end delay is (now-lrr-dlrr) */\n\teedelay = now - lrr - dlrr;\n\n\t/* Convert end to end delay to usec (keeping the calculation in\n         * 64bit space)::\n\t *   sess->ee_delay = (eedelay * 1000) / 65536;\n\t */\n\tif (eedelay < 4294) {\n\t    eedelay = (eedelay * 1000000) >> 16;\n\t} else {\n\t    eedelay = (eedelay * 1000) >> 16;\n\t    eedelay *= 1000;\n\t}\n\n\tTRACE_((sess->name, \"Rx RTCP XR DLRR: lrr=%p, dlrr=%p (%d:%03dms), \"\n\t\t\t   \"now=%p, rtt=%p\",\n\t\tlrr, dlrr, dlrr/65536, (dlrr%65536)*1000/65536,\n\t\tnow, (pj_uint32_t)eedelay));\n\t\n\t/* Only save calculation if \"now\" is greater than lrr, or\n\t * otherwise rtt will be invalid \n\t */\n\tif (now-dlrr >= lrr) {\n\t    unsigned rtt = (pj_uint32_t)eedelay;\n\t    \n\t    /* Check that eedelay value really makes sense. \n\t     * We allow up to 30 seconds RTT!\n\t     */\n\t    if (eedelay <= 30 * 1000 * 1000UL) {\n\t\t/* \"Normalize\" rtt value that is exceptionally high.\n\t\t * For such values, \"normalize\" the rtt to be three times\n\t\t * the average value.\n\t\t */\n\t\tif (rtt>((unsigned)sess->stat.rtt.mean*3) && sess->stat.rtt.n!=0)\n\t\t{\n\t\t    unsigned orig_rtt = rtt;\n\t\t    rtt = (unsigned)sess->stat.rtt.mean*3;\n\t\t    PJ_LOG(5,(sess->name, \n\t\t\t      \"RTT value %d usec is normalized to %d usec\",\n\t\t\t      orig_rtt, rtt));\n\t\t}\n    \t\n\t\tTRACE_((sess->name, \"RTCP RTT is set to %d usec\", rtt));\n\t\tpj_math_stat_update(&sess->stat.rtt, rtt);\n\t    }\n\t} else {\n\t    PJ_LOG(5, (sess->name, \"Internal RTCP NTP clock skew detected: \"\n\t\t\t\t   \"lrr=%p, now=%p, dlrr=%p (%d:%03dms), \"\n\t\t\t\t   \"diff=%d\",\n\t\t\t\t   lrr, now, dlrr, dlrr/65536,\n\t\t\t\t   (dlrr%65536)*1000/65536,\n\t\t\t\t   dlrr-(now-lrr)));\n\t}\n    }\n\n    /* Receiving Statistics Summary */\n    if (rb_stats) {\n\tpj_uint8_t flags = rb_stats->header.specific;\n\n\tpj_bzero(&sess->stat.tx.stat_sum, sizeof(sess->stat.tx.stat_sum));\n\n\t/* Range of packets sequence reported in this blocks */\n\tsess->stat.tx.stat_sum.begin_seq = pj_ntohs(rb_stats->begin_seq);\n\tsess->stat.tx.stat_sum.end_seq   = pj_ntohs(rb_stats->end_seq);\n\n\t/* Get flags of valid fields */\n\tsess->stat.tx.stat_sum.l = (flags & (1 << 7)) != 0;\n\tsess->stat.tx.stat_sum.d = (flags & (1 << 6)) != 0;\n\tsess->stat.tx.stat_sum.j = (flags & (1 << 5)) != 0;\n\tsess->stat.tx.stat_sum.t = (flags & (3 << 3)) != 0;\n\n\t/* Fetch the reports info */\n\tif (sess->stat.tx.stat_sum.l) {\n\t    sess->stat.tx.stat_sum.lost = pj_ntohl(rb_stats->lost);\n\t}\n\n\tif (sess->stat.tx.stat_sum.d) {\n\t    sess->stat.tx.stat_sum.dup = pj_ntohl(rb_stats->dup);\n\t}\n\n\tif (sess->stat.tx.stat_sum.j) {\n\t    sess->stat.tx.stat_sum.jitter.min = pj_ntohl(rb_stats->jitter_min);\n\t    sess->stat.tx.stat_sum.jitter.max = pj_ntohl(rb_stats->jitter_max);\n\t    sess->stat.tx.stat_sum.jitter.mean= pj_ntohl(rb_stats->jitter_mean);\n\t    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.jitter, \n\t\t\t\t    pj_ntohl(rb_stats->jitter_dev));\n\t}\n\n\tif (sess->stat.tx.stat_sum.t) {\n\t    sess->stat.tx.stat_sum.toh.min = rb_stats->toh_min;\n\t    sess->stat.tx.stat_sum.toh.max = rb_stats->toh_max;\n\t    sess->stat.tx.stat_sum.toh.mean= rb_stats->toh_mean;\n\t    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.toh, \n\t\t\t\t    pj_ntohl(rb_stats->toh_dev));\n\t}\n\n\tpj_gettimeofday(&sess->stat.tx.stat_sum.update);\n    }\n\n    /* Receiving VoIP Metrics */\n    if (rb_voip_mtc) {\n\tsess->stat.tx.voip_mtc.loss_rate = rb_voip_mtc->loss_rate;\n\tsess->stat.tx.voip_mtc.discard_rate = rb_voip_mtc->discard_rate;\n\tsess->stat.tx.voip_mtc.burst_den = rb_voip_mtc->burst_den;\n\tsess->stat.tx.voip_mtc.gap_den = rb_voip_mtc->gap_den;\n\tsess->stat.tx.voip_mtc.burst_dur = pj_ntohs(rb_voip_mtc->burst_dur);\n\tsess->stat.tx.voip_mtc.gap_dur = pj_ntohs(rb_voip_mtc->gap_dur);\n\tsess->stat.tx.voip_mtc.rnd_trip_delay = \n\t\t\t\t\tpj_ntohs(rb_voip_mtc->rnd_trip_delay);\n\tsess->stat.tx.voip_mtc.end_sys_delay = \n\t\t\t\t\tpj_ntohs(rb_voip_mtc->end_sys_delay);\n\t/* signal & noise level encoded in two's complement form */\n\tsess->stat.tx.voip_mtc.signal_lvl = (pj_int8_t)\n\t\t\t\t    ((rb_voip_mtc->signal_lvl > 127)?\n\t\t\t\t     ((int)rb_voip_mtc->signal_lvl - 256) : \n\t\t\t\t     rb_voip_mtc->signal_lvl);\n\tsess->stat.tx.voip_mtc.noise_lvl  = (pj_int8_t)\n\t\t\t\t    ((rb_voip_mtc->noise_lvl > 127)?\n\t\t\t\t     ((int)rb_voip_mtc->noise_lvl - 256) : \n\t\t\t\t     rb_voip_mtc->noise_lvl);\n\tsess->stat.tx.voip_mtc.rerl = rb_voip_mtc->rerl;\n\tsess->stat.tx.voip_mtc.gmin = rb_voip_mtc->gmin;\n\tsess->stat.tx.voip_mtc.r_factor = rb_voip_mtc->r_factor;\n\tsess->stat.tx.voip_mtc.ext_r_factor = rb_voip_mtc->ext_r_factor;\n\tsess->stat.tx.voip_mtc.mos_lq = rb_voip_mtc->mos_lq;\n\tsess->stat.tx.voip_mtc.mos_cq = rb_voip_mtc->mos_cq;\n\tsess->stat.tx.voip_mtc.rx_config = rb_voip_mtc->rx_config;\n\tsess->stat.tx.voip_mtc.jb_nom = pj_ntohs(rb_voip_mtc->jb_nom);\n\tsess->stat.tx.voip_mtc.jb_max = pj_ntohs(rb_voip_mtc->jb_max);\n\tsess->stat.tx.voip_mtc.jb_abs_max = pj_ntohs(rb_voip_mtc->jb_abs_max);\n\n\tpj_gettimeofday(&sess->stat.tx.voip_mtc.update);\n    }\n}", "func_hash": 128531615202269817130665554219664776865, "file_name": "rtcp_xr.c", "file_hash": 114410540091951766279707779044798368853, "cwe": ["CWE-125"], "cve": "CVE-2021-43845", "cve_desc": "PJSIP is a free and open source multimedia communication library. In version 2.11.1 and prior, if incoming RTCP XR message contain block, the data field is not checked against the received packet size, potentially resulting in an out-of-bound read access. This affects all users that use PJMEDIA and RTCP XR. A malicious actor can send a RTCP XR message with an invalid packet size.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-43845"}
{"idx": 206123, "project": "radare2", "commit_id": "1dd65336f0f0c351d6ea853efcf73cf9c0030862", "project_url": "https://github.com/radare/radare2", "commit_url": "https://github.com/radareorg/radare2/commit/1dd65336f0f0c351d6ea853efcf73cf9c0030862", "commit_message": "Fix oobread bug in NE parser ##crash\n\n* Reported by @cnitlrt via huntrdev\n* BountyID: 02b4b563-b946-4343-9092-38d1c5cd60c9\n* Reproducer: neoobread", "target": 1, "func": "RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut64 off, int bits, char * file_name) {\n\tRCoreSymCacheElement *result = NULL;\n\tut8 *b = NULL;\n\tRCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\tif (hdr->version != 1) {\n\t\teprintf (\"Unsupported CoreSymbolication cache version (%d)\\n\", hdr->version);\n\t\tgoto beach;\n\t}\n\tif (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) {\n\t\teprintf (\"Corrupted CoreSymbolication header: size out of bounds (0x%x)\\n\", hdr->size);\n\t\tgoto beach;\n\t}\n\tresult = R_NEW0 (RCoreSymCacheElement);\n\tif (!result) {\n\t\tgoto beach;\n\t}\n\tresult->hdr = hdr;\n\tb = malloc (hdr->size);\n\tif (!b) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) {\n\t\tgoto beach;\n\t}\n\tut8 *end = b + hdr->size;\n\tif (file_name) {\n\t\tresult->file_name = file_name;\n\t} else if (hdr->file_name_off) {\n\t\tresult->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end);\n\t}\n\tif (hdr->version_off) {\n\t\tresult->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end);\n\t}\n\tconst size_t word_size = bits / 8;\n\tconst ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;\n\tconst ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;\n\tconst ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size;\n\tconst ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM;\n\tconst ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM;\n\tconst ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO;\n\tconst ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;\n\n\tut64 page_zero_size = 0;\n\tsize_t page_zero_idx = 0;\n\tif (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) {\n\t\tgoto beach;\n\t}\n\tif (hdr->n_segments > 0) {\n\t\tresult->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments);\n\t\tif (!result->segments) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + R_CS_EL_OFF_SEGS;\n\t\tfor (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tseg->paddr = seg->vaddr = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->size = seg->vsize = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->name = str_dup_safe_fixed (b, cursor, 16, end);\n\t\t\tcursor += 16;\n\t\t\tif (!seg->name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!strcmp (seg->name, \"__PAGEZERO\")) {\n\t\t\t\tpage_zero_size = seg->size;\n\t\t\t\tpage_zero_idx = i;\n\t\t\t\tseg->paddr = seg->vaddr = 0;\n\t\t\t\tseg->size = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) {\n\t\t\tif (i == page_zero_idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tif (seg->vaddr < page_zero_size) {\n\t\t\t\tseg->vaddr += page_zero_size;\n\t\t\t}\n\t\t}\n\t}\n\tbool relative_to_strings = false;\n\tut8* string_origin;\n\tif (hdr->n_sections > 0) {\n\t\tresult->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections);\n\t\tif (!result->sections) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_sections;\n\t\tfor (i = 0; i < hdr->n_sections && cursor < end; i++) {\n\t\t\tut8 *sect_start = cursor;\n\t\t\tRCoreSymCacheElementSection *sect = &result->sections[i];\n\t\t\tsect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);\n\t\t\tif (sect->vaddr < page_zero_size) {\n\t\t\t\tsect->vaddr += page_zero_size;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsect->size = r_read_ble (cursor, false, bits);\n\t\t\tcursor += word_size;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 sect_name_off = r_read_ble (cursor, false, bits);\n\t\t\tif (!i && !sect_name_off) {\n\t\t\t\trelative_to_strings = true;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (bits == 32) {\n\t\t\t\tcursor += word_size;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : sect_start;\n\t\t\tsect->name = str_dup_safe (b, string_origin + (size_t)sect_name_off, end);\n\t\t}\n\t}\n\tif (hdr->n_symbols) {\n\t\tresult->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols);\n\t\tif (!result->symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_symbols;\n\t\tfor (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &result->symbols[i];\n\t\t\tsym->paddr = r_read_le32 (cursor);\n\t\t\tsym->size = r_read_le32 (cursor + 0x4);\n\t\t\tsym->unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tsym->unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!sym->name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!sym->mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t}\n\t}\n\tif (hdr->n_lined_symbols) {\n\t\tresult->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols);\n\t\tif (!result->lined_symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_lined_symbols;\n\t\tfor (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) {\n\t\t\tRCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i];\n\t\t\tlsym->sym.paddr = r_read_le32 (cursor);\n\t\t\tlsym->sym.size = r_read_le32 (cursor + 0x4);\n\t\t\tlsym->sym.unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tlsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 0x18);\n\t\t\tlsym->flc.line = r_read_le32 (cursor + 0x1c);\n\t\t\tlsym->flc.col = r_read_le32 (cursor + 0x20);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!lsym->sym.name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!lsym->sym.mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!lsym->flc.file) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc);\n\t\t}\n\t}\n\tif (hdr->n_line_info) {\n\t\tresult->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info);\n\t\tif (!result->line_info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_line_info;\n\t\tfor (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) {\n\t\t\tRCoreSymCacheElementLineInfo *info = &result->line_info[i];\n\t\t\tinfo->paddr = r_read_le32 (cursor);\n\t\t\tinfo->size = r_read_le32 (cursor + 4);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 8);\n\t\t\tinfo->flc.line = r_read_le32 (cursor + 0xc);\n\t\t\tinfo->flc.col = r_read_le32 (cursor + 0x10);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tinfo->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!info->flc.file) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LINFO;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc);\n\t\t}\n\t}\n\n\t/*\n\t * TODO:\n\t * Figure out the meaning of the 2 arrays of hdr->n_symbols\n\t * 32-bit integers located at the end of line info.\n\t * Those are the last info before the strings at the end.\n\t */\n\nbeach:\n\tfree (b);\n\treturn result;\n}", "func_hash": 16589241951305056155975579949452135068, "file_name": "coresymbolication.c", "file_hash": 336642943996368171234145432703040386493, "cwe": ["CWE-787"], "cve": "CVE-2022-1383", "cve_desc": "Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.8. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1383"}
{"idx": 221134, "project": "gpac", "commit_id": "a69b567b8c95c72f9560c873c5ab348be058f340", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340", "commit_message": "fixed #1895", "target": 0, "func": "GF_VPConfig *gf_odf_vp_cfg_new()\n{\n\tGF_VPConfig *cfg;\n\tGF_SAFEALLOC(cfg, GF_VPConfig);\n\tif (!cfg) return NULL;\n\tcfg->codec_initdata_size = 0;\n\tcfg->codec_initdata = NULL;\n\treturn cfg;\n}", "func_hash": 883592081925156988752475229187092186, "file_name": "descriptors.c", "file_hash": 86476492964393375980272696403064975409, "cwe": ["CWE-415"], "cve": "CVE-2021-40571", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40571"}
{"idx": 219954, "project": "glewlwyd", "commit_id": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "project_url": "https://github.com/babelouest/glewlwyd", "commit_url": "https://github.com/babelouest/glewlwyd/commit/125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "commit_message": "Fix update session when auth fail", "target": 0, "func": "int callback_glewlwyd_set_user_module (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct config_elements * config = (struct config_elements *)user_data;\n  json_t * j_module, * j_module_valid, * j_search_module;\n  \n  j_search_module = get_user_module(config, u_map_get(request->map_url, \"name\"));\n  if (check_result_value(j_search_module, G_OK)) {\n    j_module = ulfius_get_json_body_request(request, NULL);\n    if (j_module != NULL) {\n      json_object_del(j_module, \"enabled\");\n      j_module_valid = is_user_module_valid(config, j_module, 0);\n      if (check_result_value(j_module_valid, G_OK)) {\n        if (set_user_module(config, u_map_get(request->map_url, \"name\"), j_module) != G_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_set_user_module - Error set_user_module\");\n          response->status = 500;\n        } else {\n          y_log_message(Y_LOG_LEVEL_INFO, \"Event - User backend module '%s' updated\", u_map_get(request->map_url, \"name\"));\n        }\n      } else if (check_result_value(j_module_valid, G_ERROR_PARAM)) {\n        if (json_object_get(j_module_valid, \"error\") != NULL) {\n          ulfius_set_json_body_response(response, 400, json_object_get(j_module_valid, \"error\"));\n        } else {\n          response->status = 400;\n        }\n      } else if (!check_result_value(j_module_valid, G_OK)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_set_user_module - Error is_user_module_valid\");\n        response->status = 500;\n      }\n      json_decref(j_module_valid);\n    } else {\n      response->status = 400;\n    }\n    json_decref(j_module);\n  } else if (check_result_value(j_search_module, G_ERROR_NOT_FOUND)) {\n    response->status = 404;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_set_user_module - Error get_user_module\");\n    response->status = 500;\n  }\n  json_decref(j_search_module);\n  return U_CALLBACK_CONTINUE;\n}", "func_hash": 303480116728666070645411092086819999802, "file_name": "webservice.c", "file_hash": 287798817606377336444620654835011177393, "cwe": ["CWE-287"], "cve": "CVE-2021-45379", "cve_desc": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-45379"}
{"idx": 196587, "project": "tensorflow", "commit_id": "4aacb30888638da75023e6601149415b39763d76", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/4aacb30888638da75023e6601149415b39763d76", "commit_message": "Disallow division by zero FPE in `tf.raw_ops.ResourceScatterDiv`\n\nHad to update a test that was broken.\n\nPiperOrigin-RevId: 388516976\nChange-Id: Ic358e6bf0559e011539974d453fc7aa18b427e9c", "target": 1, "func": "  void DoCompute(OpKernelContext* c) {\n    core::RefCountPtr<Var> v;\n    OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v));\n    Tensor* params = v->tensor();\n    const Tensor& indices = c->input(1);\n    const Tensor& updates = c->input(2);\n\n    // Check that rank(updates.shape) = rank(indices.shape + params.shape[1:])\n    OP_REQUIRES(c,\n                updates.dims() == 0 ||\n                    updates.dims() == indices.dims() + params->dims() - 1,\n                errors::InvalidArgument(\n                    \"Must have updates.shape = indices.shape + \"\n                    \"params.shape[1:] or updates.shape = [], got \",\n                    \"updates.shape \", updates.shape().DebugString(),\n                    \", indices.shape \", indices.shape().DebugString(),\n                    \", params.shape \", params->shape().DebugString()));\n\n    // Check that we have enough index space\n    const int64_t N_big = indices.NumElements();\n    OP_REQUIRES(\n        c, N_big <= std::numeric_limits<Index>::max(),\n        errors::InvalidArgument(\"indices has too many elements for \",\n                                DataTypeString(DataTypeToEnum<Index>::v()),\n                                \" indexing: \", N_big, \" > \",\n                                std::numeric_limits<Index>::max()));\n    const Index N = static_cast<Index>(N_big);\n    OP_REQUIRES(\n        c, params->dim_size(0) <= std::numeric_limits<Index>::max(),\n        errors::InvalidArgument(\"params.shape[0] too large for \",\n                                DataTypeString(DataTypeToEnum<Index>::v()),\n                                \" indexing: \", params->dim_size(0), \" > \",\n                                std::numeric_limits<Index>::max()));\n\n    if (N > 0) {\n      auto indices_flat = indices.flat<Index>();\n      auto params_flat = params->flat_outer_dims<T>();\n      if (TensorShapeUtils::IsScalar(updates.shape())) {\n        const auto update = updates.scalar<T>();\n\n        functor::ScatterScalarFunctor<Device, T, Index, op> functor;\n        const Index bad_i = functor(c, c->template eigen_device<Device>(),\n                                    params_flat, update, indices_flat);\n        OP_REQUIRES(c, bad_i < 0,\n                    errors::InvalidArgument(\n                        \"indices\", SliceDebugString(indices.shape(), bad_i),\n                        \" = \", indices_flat(bad_i), \" is not in [0, \",\n                        params->dim_size(0), \")\"));\n      } else {\n        int64_t num_updates = updates.NumElements();\n        OP_REQUIRES(\n            c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()),\n            errors::InvalidArgument(\n                \"The shape of indices (\", indices.shape().DebugString(),\n                \") must be a prefix of the shape of updates (\",\n                updates.shape().DebugString(), \")\"));\n        auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});\n\n        functor::ScatterFunctor<Device, T, Index, op> functor;\n        const Index bad_i = functor(c, c->template eigen_device<Device>(),\n                                    params_flat, updates_flat, indices_flat);\n        OP_REQUIRES(c, bad_i < 0,\n                    errors::InvalidArgument(\n                        \"indices\", SliceDebugString(indices.shape(), bad_i),\n                        \" = \", indices_flat(bad_i), \" is not in [0, \",\n                        params->dim_size(0), \")\"));\n      }\n    }\n  }", "func_hash": 322924980951140877428129021875471736973, "file_name": "resource_variable_ops.cc", "file_hash": 290989719174845979221072798512679804902, "cwe": ["CWE-369"], "cve": "CVE-2021-37642", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.ResourceScatterDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/resource_variable_ops.cc#L865) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit 4aacb30888638da75023e6601149415b39763d76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-37642"}
{"idx": 220848, "project": "tensorflow", "commit_id": "8c6f391a2282684a25cbfec7687bd5d35261a209", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/8c6f391a2282684a25cbfec7687bd5d35261a209", "commit_message": "[lite] Add check for bias_size is zero to avoid division by zero. This shouldn't happen for properly converted models. Just safety check\n\nPiperOrigin-RevId: 416383645\nChange-Id: If8e508bf696ae8ecfb927e69c139a8ccf7fe60cb", "target": 0, "func": "inline int CountLeadingSignBits(T integer_input) {\n  static_assert(std::is_signed<T>::value, \"Only signed integer types handled.\");\n#if defined(__GNUC__) && !defined(__clang__)\n  return integer_input ? __builtin_clrsb(integer_input)\n                       : std::numeric_limits<T>::digits;\n#else\n  using U = typename std::make_unsigned<T>::type;\n  return integer_input >= 0\n             ? CountLeadingZeros(static_cast<U>(integer_input)) - 1\n         : integer_input != std::numeric_limits<T>::min()\n             ? CountLeadingZeros(2 * static_cast<U>(-integer_input) - 1)\n             : 0;\n#endif\n}", "func_hash": 195476752347926842346975746404332617160, "file_name": "common.h", "file_hash": 206010119069068373550820723284960883967, "cwe": ["CWE-369"], "cve": "CVE-2022-23557", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would trigger a division by zero in `BiasAndClamp` implementation. There is no check that the `bias_size` is non zero. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23557"}
{"idx": 221147, "project": "gpac", "commit_id": "a69b567b8c95c72f9560c873c5ab348be058f340", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340", "commit_message": "fixed #1895", "target": 0, "func": "GF_AVCConfig *gf_odf_avc_cfg_new()\n{\n\tGF_AVCConfig *cfg;\n\tGF_SAFEALLOC(cfg, GF_AVCConfig);\n\tif (!cfg) return NULL;\n\tcfg->sequenceParameterSets = gf_list_new();\n\tcfg->pictureParameterSets = gf_list_new();\n\tcfg->AVCLevelIndication = 1;\n\tcfg->chroma_format = 1;\n\tcfg->chroma_bit_depth = 8;\n\tcfg->luma_bit_depth = 8;\n\treturn cfg;\n}", "func_hash": 184082091926478737342063663990812901540, "file_name": "descriptors.c", "file_hash": 86476492964393375980272696403064975409, "cwe": ["CWE-415"], "cve": "CVE-2021-40571", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40571"}
{"idx": 196611, "project": "booth", "commit_id": "35bf0b7b048d715f671eb68974fb6b4af6528c67", "project_url": "https://github.com/ClusterLabs/booth", "commit_url": "https://github.com/ClusterLabs/booth/commit/35bf0b7b048d715f671eb68974fb6b4af6528c67", "commit_message": "Revert \"Refactor: main: substitute is_auth_req macro\"\n\nThis reverts commit da79b8ba28ad4837a0fee13e5f8fb6f89fe0e24c.\n\nauthfile != authkey\n\nSigned-off-by: Jan Friesse <jfriesse@redhat.com>", "target": 1, "func": "static int setup_config(int type)\n{\n\tint rv;\n\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\n\t/* Set \"local\" pointer, ignoring errors. */\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\n\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\n\t/* Per default the PID file name is derived from the\n\t * configuration name. */\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\n\nout:\n\treturn rv;\n}", "func_hash": 170997267947585139967201027163993257008, "file_name": "main.c", "file_hash": 4814718832295442874488153140310945385, "cwe": ["CWE-284"], "cve": "CVE-2022-2553", "cve_desc": "The authfile directive in the booth config file is ignored, preventing use of authentication in communications from node to node. As a result, nodes that do not have the correct authentication key are not prevented from communicating with other nodes in the cluster.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2553"}
{"idx": 139242, "project": "Chrome", "commit_id": "fb83de09f2c986ee91741f3a2776feea0e18e3f6", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/fb83de09f2c986ee91741f3a2776feea0e18e3f6", "commit_message": "None", "target": 0, "func": "void OverlayWindowViews::SetPictureInPictureCustomControls(\n    const std::vector<blink::PictureInPictureControlInfo>& controls) {\n  first_custom_controls_view_.reset();\n  second_custom_controls_view_.reset();\n\n  if (controls.size() > 0)\n    CreateCustomControl(first_custom_controls_view_, controls[0],\n                        ControlPosition::kLeft);\n  if (controls.size() > 1)\n    CreateCustomControl(second_custom_controls_view_, controls[1],\n                        ControlPosition::kRight);\n}\n", "func_hash": 309360453868501288952684750383017377073, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 221694, "project": "e2guardian", "commit_id": "eae46a7e2a57103aadca903c4a24cca94dc502a2", "project_url": "https://github.com/e2guardian/e2guardian", "commit_url": "https://github.com/e2guardian/e2guardian/commit/eae46a7e2a57103aadca903c4a24cca94dc502a2", "commit_message": "Fix bug #707 cert hostnames not being checked\n- only happened when openssl v1.1 is used", "target": 0, "func": "Socket *Socket::accept() {\n    peer_adr_length = sizeof(struct sockaddr_in);\n    s_errno = 0;\n    errno = 0;\n//    int newfd = this->baseAccept((struct sockaddr *)&peer_adr, &peer_adr_length);\n    int newfd = ::accept(sck, (struct sockaddr *) &peer_adr, &peer_adr_length);\n\n    if (newfd > 0) {\n        Socket *s = new Socket(newfd, my_adr, peer_adr);\n        s->setPort(my_port);\n        return s;\n    } else {\n        s_errno = errno;\n        return NULL;\n    }\n}", "func_hash": 231120615862306967661727934831285641865, "file_name": "Socket.cpp", "file_hash": 316707147744091371767800459911917453562, "cwe": ["CWE-295"], "cve": "CVE-2021-44273", "cve_desc": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-44273"}
{"idx": 195039, "project": "tensorflow", "commit_id": "e7f497570abb6b4ae5af4970620cd880e4c0c904", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/e7f497570abb6b4ae5af4970620cd880e4c0c904", "commit_message": "Fix segfault on OOM in Conv2D.\n\nPiperOrigin-RevId: 404655317\nChange-Id: I33588dbd3f5d0fef980e3c908bf5515a9ee09ce7", "target": 1, "func": "  void operator()(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int row_stride, int col_stride,\n                  int row_dilation, int col_dilation, const Padding& padding,\n                  const std::vector<int64_t>& explicit_paddings, Tensor* output,\n                  TensorFormat data_format) {\n    DCHECK(data_format == FORMAT_NHWC)\n        << \"Grouped conv implementation only \"\n           \"supports NHWC tensor format for now.\";\n\n    const int64_t in_depth = input.dim_size(3);\n    const int64_t patch_depth = filter.dim_size(2);\n    const int64_t num_groups = in_depth / patch_depth;\n\n    // Shuffle input/filter tensors to have group as a leading dimension.\n    std::array<int64_t, 5> shuffle({3, 0, 1, 2, 4});\n\n    // Compute pre shuffle dimemnsions.\n    auto pre_shuffle = [&](const Tensor& tensor) -> std::array<int64, 5> {\n      return {tensor.dim_size(0), tensor.dim_size(1), tensor.dim_size(2),\n              num_groups, tensor.dim_size(3) / num_groups};\n    };\n\n    // Compute post shuffle dimemnsions.\n    auto post_shuffle = [&](const Tensor& tensor) -> std::array<int64, 5> {\n      return {num_groups, tensor.dim_size(0), tensor.dim_size(1),\n              tensor.dim_size(2), tensor.dim_size(3) / num_groups};\n    };\n\n    auto& device = ctx->eigen_device<CPUDevice>();\n\n    absl::BlockingCounter shuffles_completed(2);\n    auto on_shuffled = [&]() { shuffles_completed.DecrementCount(); };\n\n    // Shuffle input into temporary tensor.\n    Tensor input_shuffled(input.dtype(), TensorShape(post_shuffle(input)));\n    input_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        input.shaped<T, 5>(pre_shuffle(input)).shuffle(shuffle);\n\n    // Shuffle filter into temporary tensor.\n    Tensor filter_shuffled(filter.dtype(), TensorShape(post_shuffle(filter)));\n    filter_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        filter.shaped<T, 5>(pre_shuffle(filter)).shuffle(shuffle);\n\n    // Wait for the completion of input/filter shuffles.\n    shuffles_completed.Wait();\n\n    // Write group convolution results into temporary output tensor.\n    Tensor output_shuffled(output->dtype(), TensorShape(post_shuffle(*output)));\n\n    for (int64_t i = 0; i < num_groups; ++i) {\n      // TODO(ezhulenev): Run this loop using `parallelFor` (regular parallelFor\n      // will lead to deadlock, SpatialConvolution has to use async Eigen\n      // assignment). This requires small changes to Eigen to support async\n      // exeuction for tensor chipping operation.\n\n      // TODO(ezhulenev): Grouped convolution should also support 1x1 filter\n      // optimization.\n\n      auto input_slice = input_shuffled.tensor<T, 5>().template chip<0>(i);\n      auto filter_slice = filter_shuffled.tensor<T, 5>().template chip<0>(i);\n      auto output_slice = output_shuffled.tensor<T, 5>().template chip<0>(i);\n\n      if (padding == EXPLICIT) {\n        functor::SpatialConvolution<CPUDevice, T>()(\n            ctx->eigen_device<CPUDevice>(), output_slice, input_slice,\n            filter_slice, row_stride, col_stride, row_dilation, col_dilation,\n            static_cast<int>(explicit_paddings[2]),\n            static_cast<int>(explicit_paddings[3]),\n            static_cast<int>(explicit_paddings[4]),\n            static_cast<int>(explicit_paddings[5]));\n      } else {\n        functor::SpatialConvolution<CPUDevice, T>()(\n            ctx->eigen_device<CPUDevice>(), output_slice, input_slice,\n            filter_slice, row_stride, col_stride, row_dilation, col_dilation,\n            BrainPadding2EigenPadding(padding));\n      }\n    }\n\n    // Shuffle temporary output back into pre-shuffled shape.\n    std::array<int64_t, 5> rev_shuffle({1, 2, 3, 0, 4});\n    output->shaped<T, 5>(pre_shuffle(*output)).device(device) =\n        output_shuffled.tensor<T, 5>().shuffle(rev_shuffle);\n  }", "func_hash": 257618220779157714024325768166416151732, "file_name": "conv_ops.cc", "file_hash": 252300068611383622428481854806618645318, "cwe": ["CWE-354"], "cve": "CVE-2021-41206", "cve_desc": "TensorFlow is an open source platform for machine learning. In affected versions several TensorFlow operations are missing validation for the shapes of the tensor arguments involved in the call. Depending on the API, this can result in undefined behavior and segfault or `CHECK`-fail related crashes but in some scenarios writes and reads from heap populated arrays are also possible. We have discovered these issues internally via tooling while working on improving/testing GPU op determinism. As such, we don't have reproducers and there will be multiple fixes for these issues. These fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41206"}
{"idx": 90127, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual void DisconnectFromWirelessNetwork(const WirelessNetwork* network) {}\n", "func_hash": 266455875333630270384089647731569112707, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 202889, "project": "linux", "commit_id": "ebe48d368e97d007bfeb76fcb065d6cfc4c96645", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/ebe48d368e97d007bfeb76fcb065d6cfc4c96645", "commit_message": "esp: Fix possible buffer overflow in ESP transformation\n\nThe maximum message size that can be send is bigger than\nthe  maximum site that skb_page_frag_refill can allocate.\nSo it is possible to write beyond the allocated buffer.\n\nFix this by doing a fallback to COW in that case.\n\nv2:\n\nAvoid get get_order() costs as suggested by Linus Torvalds.\n\nFixes: cac2661c53f3 (\"esp4: Avoid skb_cow_data whenever possible\")\nFixes: 03e2a30f6a27 (\"esp6: Avoid skb_cow_data whenever possible\")\nReported-by: valis <sec@valis.email>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>", "target": 1, "func": "int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\n\tif (x->encap) {\n\t\tint err = esp6_output_encap(x, skb, esp);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\n\t\t\tesp->inplace = false;\n\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\n\t\t\tspin_lock_bh(&x->lock);\n\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\n\t\t\ttail = page_address(page) + pfrag->offset;\n\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\n\t\t\tspin_unlock_bh(&x->lock);\n\n\t\t\tnfrags++;\n\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\n\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\n\nout:\n\treturn nfrags;\n}", "func_hash": 288301041182247062764395753908590668676, "file_name": "esp6.c", "file_hash": 297879342136766332467148715516497305667, "cwe": ["CWE-787"], "cve": "CVE-2022-27666", "cve_desc": "A heap buffer overflow flaw was found in IPsec ESP transformation code in net/ipv4/esp4.c and net/ipv6/esp6.c. This flaw allows a local attacker with a normal user privilege to overwrite kernel heap objects and may cause a local privilege escalation threat.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-27666"}
{"idx": 139253, "project": "Chrome", "commit_id": "fb83de09f2c986ee91741f3a2776feea0e18e3f6", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/fb83de09f2c986ee91741f3a2776feea0e18e3f6", "commit_message": "None", "target": 0, "func": "void OverlayWindowViews::UpdatePlayPauseControlsSize() {\n  UpdateButtonSize();\n  play_pause_controls_view_->SetSize(button_size_);\n  play_pause_controls_view_->SetImage(\n      views::Button::STATE_NORMAL,\n      gfx::CreateVectorIcon(vector_icons::kPlayArrowIcon,\n                            button_size_.width() / 2, kControlIconColor));\n  gfx::ImageSkia pause_icon = gfx::CreateVectorIcon(\n      vector_icons::kPauseIcon, button_size_.width() / 2, kControlIconColor);\n  play_pause_controls_view_->SetToggledImage(views::Button::STATE_NORMAL,\n                                             &pause_icon);\n  const gfx::ImageSkia play_pause_background = gfx::CreateVectorIcon(\n      kPictureInPictureControlBackgroundIcon, button_size_.width(), kBgColor);\n  play_pause_controls_view_->SetBackgroundImage(\n      kBgColor, &play_pause_background, &play_pause_background);\n}\n", "func_hash": 320629130648991479275117593830291594941, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 221673, "project": "e2guardian", "commit_id": "eae46a7e2a57103aadca903c4a24cca94dc502a2", "project_url": "https://github.com/e2guardian/e2guardian", "commit_url": "https://github.com/e2guardian/e2guardian/commit/eae46a7e2a57103aadca903c4a24cca94dc502a2", "commit_message": "Fix bug #707 cert hostnames not being checked\n- only happened when openssl v1.1 is used", "target": 0, "func": "bool Socket::writeChunk( char *buffout, int len, int timeout){\n    std::stringstream stm;\n    stm << std::hex << len;\n    std::string hexs (stm.str());\n    //int lw;\n    hexs += \"\\r\\n\";\n#ifdef NETDEBUG\n    std::cerr << thread_id << \"writeChunk  size=\" << hexs << std::endl;\n#endif\n    if(writeString(hexs.c_str()) && writeToSocket(buffout,len,0,timeout) && writeString(\"\\r\\n\"))\n        return true;\n    return false;\n};", "func_hash": 275731893685660091746826864724044576625, "file_name": "Socket.cpp", "file_hash": 316707147744091371767800459911917453562, "cwe": ["CWE-295"], "cve": "CVE-2021-44273", "cve_desc": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-44273"}
{"idx": 101665, "project": "Chrome", "commit_id": "2bfb2b8299e2fb6a432390a93a99a85fed1d29c9", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/2bfb2b8299e2fb6a432390a93a99a85fed1d29c9", "commit_message": "None", "target": 0, "func": "void WebProcessProxy::didBecomeUnresponsive(ResponsivenessTimer*)\n{\n    Vector<RefPtr<WebPageProxy> > pages;\n    copyValuesToVector(m_pageMap, pages);\n    for (size_t i = 0, size = pages.size(); i < size; ++i)\n        pages[i]->processDidBecomeUnresponsive();\n}\n", "func_hash": 72512893183559041724818864933901039404, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 196893, "project": "envoy", "commit_id": "e9f936d85dc1edc34fabd0a1725ec180f2316353", "project_url": "https://github.com/istio/envoy", "commit_url": "https://github.com/envoyproxy/envoy/commit/e9f936d85dc1edc34fabd0a1725ec180f2316353", "commit_message": "CVE-2022-21654\n\ntls allows re-use when some cert validation settings have changed\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>", "target": 1, "func": "void DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                                    uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                                    unsigned hash_length) {\n  int rc;\n\n  // Hash all the settings that affect whether the server will allow/accept\n  // the client connection. This ensures that the client is always validated against\n  // the correct settings, even if session resumption across different listeners\n  // is enabled.\n  if (ca_cert_ != nullptr) {\n    rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,\n                   fmt::format(\"invalid SHA256 hash length {}\", hash_length));\n\n    rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_hash_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_spki_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n}", "func_hash": 140411723524972581248505271605198365196, "file_name": "default_validator.cc", "file_hash": 12469299547216327731154844869138538271, "cwe": ["CWE-362"], "cve": "CVE-2022-21654", "cve_desc": "Envoy is an open source edge and service proxy, designed for cloud-native applications. Envoy's tls allows re-use when some cert validation settings have changed from their default configuration. The only workaround for this issue is to ensure that default tls settings are used. Users are advised to upgrade.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-21654"}
{"idx": 219989, "project": "glewlwyd", "commit_id": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "project_url": "https://github.com/babelouest/glewlwyd", "commit_url": "https://github.com/babelouest/glewlwyd/commit/125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "commit_message": "Fix update session when auth fail", "target": 0, "func": "int callback_glewlwyd_get_user_middleware_module_list (const struct _u_request * request, struct _u_response * response, void * user_middleware_data) {\n  UNUSED(request);\n  struct config_elements * config = (struct config_elements *)user_middleware_data;\n  json_t * j_module;\n  \n  j_module = get_user_middleware_module_list(config);\n  if (check_result_value(j_module, G_OK)) {\n    ulfius_set_json_body_response(response, 200, json_object_get(j_module, \"module\"));\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_get_user_middleware_module_list - Error get_user_middleware_module_list\");\n    response->status = 500;\n  }\n  json_decref(j_module);\n  return U_CALLBACK_CONTINUE;\n}", "func_hash": 117262274946527407993973213716602839394, "file_name": "webservice.c", "file_hash": 287798817606377336444620654835011177393, "cwe": ["CWE-287"], "cve": "CVE-2021-45379", "cve_desc": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-45379"}
{"idx": 200895, "project": "vim", "commit_id": "d6c67629ed05aae436164eec474832daf8ba7420", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/d6c67629ed05aae436164eec474832daf8ba7420", "commit_message": "patch 9.0.0260: using freed memory when using 'quickfixtextfunc' recursively\n\nProblem:    Using freed memory when using 'quickfixtextfunc' recursively.\nSolution:   Do not allow for recursion.", "target": 1, "func": "call_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n{\n    callback_T\t*cb = &qftf_cb;\n    list_T\t*qftf_list = NULL;\n\n    // If 'quickfixtextfunc' is set, then use the user-supplied function to get\n    // the text to display. Use the local value of 'quickfixtextfunc' if it is\n    // set.\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n\tcb = &qfl->qf_qftf_cb;\n    if (cb->cb_name != NULL)\n    {\n\ttypval_T\targs[1];\n\tdict_T\t\t*d;\n\ttypval_T\trettv;\n\n\t// create the dict argument\n\tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\t    return NULL;\n\tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\tdict_add_number(d, \"winid\", (long)qf_winid);\n\tdict_add_number(d, \"id\", (long)qfl->qf_id);\n\tdict_add_number(d, \"start_idx\", start_idx);\n\tdict_add_number(d, \"end_idx\", end_idx);\n\t++d->dv_refcount;\n\targs[0].v_type = VAR_DICT;\n\targs[0].vval.v_dict = d;\n\n\tqftf_list = NULL;\n\tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n\t{\n\t    if (rettv.v_type == VAR_LIST)\n\t    {\n\t\tqftf_list = rettv.vval.v_list;\n\t\tqftf_list->lv_refcount++;\n\t    }\n\t    clear_tv(&rettv);\n\t}\n\tdict_unref(d);\n    }\n\n    return qftf_list;\n}", "func_hash": 339333086271181560510428879683096773754, "file_name": "None", "file_hash": null, "cwe": ["CWE-703"], "cve": "CVE-2022-2982", "cve_desc": "Use After Free in GitHub repository vim/vim prior to 9.0.0260.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2982"}
{"idx": 90169, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  static void ParseSystem(SystemInfo* system,\n      EthernetNetwork** ethernet,\n      WifiNetworkVector* wifi_networks,\n      CellularNetworkVector* cellular_networks,\n      WifiNetworkVector* remembered_wifi_networks) {\n    DVLOG(1) << \"ParseSystem:\";\n    DCHECK(!(*ethernet));\n    for (int i = 0; i < system->service_size; i++) {\n      const ServiceInfo* service = system->GetServiceInfo(i);\n      DVLOG(1) << \"  (\" << service->type << \") \" << service->name\n               << \" mode=\" << service->mode\n               << \" state=\" << service->state\n               << \" sec=\" << service->security\n               << \" req=\" << service->passphrase_required\n               << \" pass=\" << service->passphrase\n               << \" id=\" << service->identity\n               << \" certpath=\" << service->cert_path\n               << \" str=\" << service->strength\n               << \" fav=\" << service->favorite\n               << \" auto=\" << service->auto_connect\n               << \" is_active=\" << service->is_active\n               << \" error=\" << service->error;\n      if (service->type == TYPE_ETHERNET)\n        (*ethernet) = new EthernetNetwork(service);\n      else if (service->type == TYPE_WIFI) {\n        wifi_networks->push_back(new WifiNetwork(service));\n      } else if (service->type == TYPE_CELLULAR) {\n        cellular_networks->push_back(new CellularNetwork(service));\n      }\n    }\n\n    if (!(*ethernet))\n      (*ethernet) = new EthernetNetwork();\n\n    DVLOG(1) << \"Remembered networks:\";\n    for (int i = 0; i < system->remembered_service_size; i++) {\n      const ServiceInfo* service = system->GetRememberedServiceInfo(i);\n      if (service->auto_connect) {\n        DVLOG(1) << \"  (\" << service->type << \") \" << service->name\n                 << \" mode=\" << service->mode\n                 << \" sec=\" << service->security\n                 << \" pass=\" << service->passphrase\n                 << \" id=\" << service->identity\n                 << \" certpath=\" << service->cert_path\n                 << \" auto=\" << service->auto_connect;\n        if (service->type == TYPE_WIFI) {\n          remembered_wifi_networks->push_back(new WifiNetwork(service));\n        }\n      }\n    }\n  }\n", "func_hash": 139591473638713483225834677538000176518, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 216905, "project": "server", "commit_id": "0dec71ca53729bd1a565bdc800e64008b44ffa48", "project_url": "https://github.com/MariaDB/server", "commit_url": "https://github.com/MariaDB/server/commit/0dec71ca53729bd1a565bdc800e64008b44ffa48", "commit_message": "MDEV-26350: select_lex->ref_pointer_array.size() % 5 == 0\n\nDue to an integer overflow an invalid size of ref_pointer_array could be\nallocated.\n\nUsing size_t allows this continue. Allocation failures are\nhandled gracefully if the value is too big.\n\nThanks to Zuming Jiang for the bug report and fuzzing MariaDB.\n\nReviewer: Sanja", "target": 1, "func": "bool st_select_lex::setup_ref_array(THD *thd, uint order_group_num)\n{\n\n  if (!((options & SELECT_DISTINCT) && !group_list.elements))\n    hidden_bit_fields= 0;\n\n  // find_order_in_list() may need some extra space, so multiply by two.\n  order_group_num*= 2;\n\n  /*\n    We have to create array in prepared statement memory if it is a\n    prepared statement\n  */\n  Query_arena *arena= thd->stmt_arena;\n  const uint n_elems= (n_sum_items +\n                       n_child_sum_items +\n                       item_list.elements +\n                       select_n_reserved +\n                       select_n_having_items +\n                       select_n_where_fields +\n                       order_group_num +\n                       hidden_bit_fields +\n                       fields_in_window_functions) * 5;\n  if (!ref_pointer_array.is_null())\n  {\n    /*\n      We need to take 'n_sum_items' into account when allocating the array,\n      and this may actually increase during the optimization phase due to\n      MIN/MAX rewrite in Item_in_subselect::single_value_transformer.\n      In the usual case we can reuse the array from the prepare phase.\n      If we need a bigger array, we must allocate a new one.\n     */\n    if (ref_pointer_array.size() >= n_elems)\n      return false;\n   }\n  Item **array= static_cast<Item**>(arena->alloc(sizeof(Item*) * n_elems));\n  if (array != NULL)\n    ref_pointer_array= Ref_ptr_array(array, n_elems);\n\n  return array == NULL;\n}", "func_hash": 309407912499220915425041537374642075868, "file_name": "None", "file_hash": null, "cwe": ["CWE-190"], "cve": "CVE-2021-46667", "cve_desc": "MariaDB before 10.6.5 has a sql_lex.cc integer overflow, leading to an application crash.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-46667"}
{"idx": 210271, "project": "vim", "commit_id": "6669de1b235843968e88844ca6d3c8dec4b01a9e", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/6669de1b235843968e88844ca6d3c8dec4b01a9e", "commit_message": "patch 9.0.0240: crash when using \":mkspell\" with an empty .dic file\n\nProblem:    Crash when using \":mkspell\" with an empty .dic file.\nSolution:   Check for an empty word tree.", "target": 1, "func": "sug_filltree(spellinfo_T *spin, slang_T *slang)\n{\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\ttword[MAXWLEN];\n    char_u\ttsalword[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    unsigned\twords_done = 0;\n    int\t\twordcount[MAXWLEN];\n\n    // We use si_foldroot for the soundfolded trie.\n    spin->si_foldroot = wordtree_alloc(spin);\n    if (spin->si_foldroot == NULL)\n\treturn FAIL;\n\n    // let tree_add_word() know we're adding to the soundfolded tree\n    spin->si_sugtree = TRUE;\n\n    /*\n     * Go through the whole case-folded tree, soundfold each word and put it\n     * in the trie.\n     */\n    byts = slang->sl_fbyts;\n    idxs = slang->sl_fidxs;\n\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    // Done all bytes at this node, go up one level.\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\n\t    --depth;\n\t    line_breakcheck();\n\t}\n\telse\n\t{\n\n\t    // Do one more byte at this node.\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\t// Sound-fold the word.\n\t\ttword[depth] = NUL;\n\t\tspell_soundfold(slang, tword, TRUE, tsalword);\n\n\t\t// We use the \"flags\" field for the MSB of the wordnr,\n\t\t// \"region\" for the LSB of the wordnr.\n\t\tif (tree_add_word(spin, tsalword, spin->si_foldroot,\n\t\t\t\twords_done >> 16, words_done & 0xffff,\n\t\t\t\t\t\t\t   0) == FAIL)\n\t\t    return FAIL;\n\n\t\t++words_done;\n\t\t++wordcount[depth];\n\n\t\t// Reset the block count each time to avoid compression\n\t\t// kicking in.\n\t\tspin->si_blocks_cnt = 0;\n\n\t\t// Skip over any other NUL bytes (same word with different\n\t\t// flags).  But don't go over the end.\n\t\twhile (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Normal char, go one level deeper.\n\t\ttword[depth++] = c;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n\n    smsg(_(\"Total number of words: %d\"), words_done);\n\n    return OK;\n}", "func_hash": 207388436213910008407743050781298909937, "file_name": "spellfile.c", "file_hash": 273224760850620955394187294241739462394, "cwe": ["CWE-787"], "cve": "CVE-2022-2923", "cve_desc": "NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0240.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2923"}
{"idx": 221498, "project": "flatpak", "commit_id": "89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "commit_message": "run: Add cross-references for some other seccomp syscall filters\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "target": 0, "func": "add_ld_so_conf (FlatpakBwrap *bwrap,\n                GError      **error)\n{\n  const char *contents =\n    \"include /run/flatpak/ld.so.conf.d/app-*.conf\\n\"\n    \"include /app/etc/ld.so.conf\\n\"\n    \"/app/lib\\n\"\n    \"include /run/flatpak/ld.so.conf.d/runtime-*.conf\\n\";\n\n  return flatpak_bwrap_add_args_data (bwrap, \"ld-so-conf\",\n                                      contents, -1, \"/etc/ld.so.conf\", error);\n}", "func_hash": 9527227245265731809315967386756650300, "file_name": "flatpak-run.c", "file_hash": 32398709380082441128978861691951488575, "cwe": ["CWE-20"], "cve": "CVE-2021-41133", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41133"}
{"idx": 215073, "project": "linux", "commit_id": "24f6008564183aa120d07c03d9289519c2fe02af", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/24f6008564183aa120d07c03d9289519c2fe02af", "commit_message": "cgroup-v1: Require capabilities to set release_agent\n\nThe cgroup release_agent is called with call_usermodehelper.  The function\ncall_usermodehelper starts the release_agent with a full set fo capabilities.\nTherefore require capabilities when setting the release_agaent.\n\nReported-by: Tabitha Sable <tabitha.c.sable@gmail.com>\nTested-by: Tabitha Sable <tabitha.c.sable@gmail.com>\nFixes: 81a6a5cdd2c5 (\"Task Control Groups: automatic userspace notification of idle cgroups\")\nCc: stable@vger.kernel.org # v2.6.24+\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\nSigned-off-by: Tejun Heo <tj@kernel.org>", "target": 1, "func": "static ssize_t cgroup_release_agent_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\n\tBUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\tspin_lock(&release_agent_path_lock);\n\tstrlcpy(cgrp->root->release_agent_path, strstrip(buf),\n\t\tsizeof(cgrp->root->release_agent_path));\n\tspin_unlock(&release_agent_path_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn nbytes;\n}", "func_hash": 62903931031364372249216035169426622389, "file_name": "cgroup-v1.c", "file_hash": 159693224935670518088988394061249784059, "cwe": ["CWE-269"], "cve": "CVE-2022-0492", "cve_desc": "A vulnerability was found in the Linux kernel\u2019s cgroup_release_agent_write in the kernel/cgroup/cgroup-v1.c function. This flaw, under certain circumstances, allows the use of the cgroups v1 release_agent feature to escalate privileges and bypass the namespace isolation unexpectedly.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0492"}
{"idx": 221483, "project": "flatpak", "commit_id": "89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "commit_message": "run: Add cross-references for some other seccomp syscall filters\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "target": 0, "func": "flatpak_run_apply_env_default (FlatpakBwrap *bwrap, gboolean use_ld_so_cache)\n{\n  bwrap->envp = apply_exports (bwrap->envp, default_exports, G_N_ELEMENTS (default_exports));\n\n  if (!use_ld_so_cache)\n    bwrap->envp = apply_exports (bwrap->envp, no_ld_so_cache_exports, G_N_ELEMENTS (no_ld_so_cache_exports));\n}", "func_hash": 165126031178003105609905550863820772938, "file_name": "flatpak-run.c", "file_hash": 32398709380082441128978861691951488575, "cwe": ["CWE-20"], "cve": "CVE-2021-41133", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41133"}
{"idx": 204073, "project": "shapelib", "commit_id": "c75b9281a5b9452d92e1682bdfe6019a13ed819f", "project_url": "https://github.com/OSGeo/shapelib", "commit_url": "https://github.com/OSGeo/shapelib/commit/c75b9281a5b9452d92e1682bdfe6019a13ed819f", "commit_message": "Remove double free() in contrib/shpsrt, issue #39\n\nThis fixes issue #39", "target": 1, "func": "static char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n\n  free(copy);\n\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n\n  return result;\n}", "func_hash": 154440466975385336432510777562091378708, "file_name": "shpsort.c", "file_hash": 43221346953143953382565106661243368341, "cwe": ["CWE-415"], "cve": "CVE-2022-0699", "cve_desc": "A double-free condition exists in contrib/shpsort.c of shapelib 1.5.0 and older releases. This issue may allow an attacker to cause a denial of service or have other unspecified impact via control over malloc.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0699"}
{"idx": 219972, "project": "glewlwyd", "commit_id": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "project_url": "https://github.com/babelouest/glewlwyd", "commit_url": "https://github.com/babelouest/glewlwyd/commit/125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "commit_message": "Fix update session when auth fail", "target": 0, "func": "int callback_glewlwyd_server_configuration (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  UNUSED(request);\n  \n  json_t * json_body = json_pack(\"{ssssssss}\", \n                                 \"api_prefix\", \n                                 ((struct config_elements *)user_data)->api_prefix,\n                                 \"admin_scope\",\n                                 ((struct config_elements *)user_data)->admin_scope,\n                                 \"profile_scope\",\n                                 ((struct config_elements *)user_data)->profile_scope,\n                                 \"delete_profile\",\n                                 ((struct config_elements *)user_data)->delete_profile==GLEWLWYD_PROFILE_DELETE_UNAUTHORIZED?\"no\":\"yes\");\n  ulfius_set_json_body_response(response, 200, json_body);\n  json_decref(json_body);\n  return U_CALLBACK_CONTINUE;\n}", "func_hash": 286299898050157253895478906360842182396, "file_name": "webservice.c", "file_hash": 287798817606377336444620654835011177393, "cwe": ["CWE-287"], "cve": "CVE-2021-45379", "cve_desc": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-45379"}
{"idx": 219991, "project": "glewlwyd", "commit_id": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "project_url": "https://github.com/babelouest/glewlwyd", "commit_url": "https://github.com/babelouest/glewlwyd/commit/125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "commit_message": "Fix update session when auth fail", "target": 0, "func": "int callback_glewlwyd_delete_scope (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct config_elements * config = (struct config_elements *)user_data;\n  json_t * j_search_scope;\n  \n  j_search_scope = get_scope(config, u_map_get(request->map_url, \"scope\"));\n  if (check_result_value(j_search_scope, G_OK)) {\n    if (delete_scope(config, u_map_get(request->map_url, \"scope\")) != G_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_delete_scope - Error delete_scope\");\n      response->status = 500;\n    } else {\n      y_log_message(Y_LOG_LEVEL_INFO, \"Event - Scope '%s' removed\", u_map_get(request->map_url, \"scope\"));\n    }\n  } else if (check_result_value(j_search_scope, G_ERROR_NOT_FOUND)) {\n    response->status = 404;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_delete_scope - Error get_scope\");\n    response->status = 500;\n  }\n  json_decref(j_search_scope);\n  return U_CALLBACK_CONTINUE;\n}", "func_hash": 120753631967747165445026281757495297899, "file_name": "webservice.c", "file_hash": 287798817606377336444620654835011177393, "cwe": ["CWE-287"], "cve": "CVE-2021-45379", "cve_desc": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-45379"}
{"idx": 221180, "project": "gpac", "commit_id": "a69b567b8c95c72f9560c873c5ab348be058f340", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340", "commit_message": "fixed #1895", "target": 0, "func": "GF_Descriptor *gf_odf_new_tx3g()\n{\n\tGF_TextSampleDescriptor *newDesc = (GF_TextSampleDescriptor*) gf_malloc(sizeof(GF_TextSampleDescriptor));\n\tif (!newDesc) return NULL;\n\tmemset(newDesc, 0, sizeof(GF_TextSampleDescriptor));\n\tnewDesc->tag = GF_ODF_TX3G_TAG;\n\treturn (GF_Descriptor *) newDesc;\n}", "func_hash": 9079237779020476439107984027115237731, "file_name": "descriptors.c", "file_hash": 86476492964393375980272696403064975409, "cwe": ["CWE-415"], "cve": "CVE-2021-40571", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40571"}
{"idx": 197593, "project": "njs", "commit_id": "ad48705bf1f04b4221a5f5b07715ac48b3160d53", "project_url": "https://github.com/nginx/njs", "commit_url": "https://github.com/nginx/njs/commit/ad48705bf1f04b4221a5f5b07715ac48b3160d53", "commit_message": "Fixed frame allocation from an awaited frame.\n\nnjs_function_frame_save() is used to save the awaited frame when \"await\"\ninstruction is encountered. The saving was done as a memcpy() of\nexisting runtime frame.\n\nnjs_function_frame_alloc() is used to alloc a new function frame, this\nfunction tries to use a spare preallocated memory from the previous\nframe first.  Previously, this function might result in \"use-after-free\"\nwhen invoked from a restored frame saved with njs_function_frame_save().\nBecause njs_function_frame_save() left pointers to the spare memory of\nthe original frame which may be already free when saved frame is\nrestored.\n\nThe fix is to erase fields for the spare memory from the saved frame.\n\nThis closes #469 issue on Github.", "target": 1, "func": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n\n    native = &frame->native;\n\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n\n    function = active->function;\n\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n\n\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n\n    /* Move all arguments. */\n\n    p = native->arguments;\n    local = native->local + function->args_offset;\n\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n\n        *local++ = p++;\n    }\n\n    return NJS_OK;\n}", "func_hash": 163196677430813133926152837345587363595, "file_name": "njs_function.c", "file_hash": 84952023387586829721392975850477495397, "cwe": ["CWE-416"], "cve": "CVE-2022-27007", "cve_desc": "nginx njs 0.7.2 is affected suffers from Use-after-free in njs_function_frame_alloc() when it try to invoke from a restored frame saved with njs_function_frame_save().", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-27007"}
{"idx": 218994, "project": "tensorflow", "commit_id": "240655511cd3e701155f944a972db71b6c0b1bb6", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/240655511cd3e701155f944a972db71b6c0b1bb6", "commit_message": "Eliminate `CHECK`-fails from `IsSimplifiableReshape` via `MakeShape(<invalid shape>)`\n\nPiperOrigin-RevId: 409166738\nChange-Id: I7f0a3590b8acae3f3e3e2fe636e1f5ef285693cf", "target": 0, "func": "void ConstantFolding::RemoveRedundantVariableUpdates(\n    GraphProperties* properties, GraphDef* optimized_graph, NodeDef* node) {\n  static const absl::flat_hash_set<string>* kVariableReadOps =\n      new absl::flat_hash_set<string>{\"AssignAddVariableOp\",\n                                      \"AssignSubVariableOp\",\n                                      \"AssignAdd\",\n                                      \"AssignSub\",\n                                      \"ScatterAdd\",\n                                      \"ScatterSub\",\n                                      \"ScatterMul\",\n                                      \"ScatterDiv\",\n                                      \"ScatterNdAdd\",\n                                      \"ScatterNdSub\",\n                                      \"ScatterNdMul\",\n                                      \"ScatterNdDiv\",\n                                      \"ResourceScatterAdd\",\n                                      \"ResourceScatterSub\",\n                                      \"ResourceScatterMul\",\n                                      \"ResourceScatterDiv\",\n                                      \"ResourceScatterNdAdd\",\n                                      \"ResourceScatterNdSub\",\n                                      \"ResourceScatterNdMul\",\n                                      \"ResourceScatterNdDiv\"};\n  if (kVariableReadOps == nullptr ||\n      kVariableReadOps->find(node->op()) == kVariableReadOps->end())\n    return;\n  const int value_index = absl::StrContains(node->op(), \"Scatter\") ? 2 : 1;\n  const NodeDef* delta_node = node_map_->GetNode(node->input(value_index));\n  if (delta_node == nullptr) return;\n  const bool is_add_or_sub = absl::StrContains(node->op(), \"Add\") ||\n                             absl::StrContains(node->op(), \"Sub\");\n  if ((is_add_or_sub && IsZeros(*delta_node)) ||\n      (!is_add_or_sub && IsOnes(*delta_node))) {\n    VLOG(1) << \"Removing redundant variable update: \" << node->DebugString();\n    if (absl::StrContains(node->op(), \"Variable\") ||\n        absl::StrContains(node->op(), \"Resource\")) {\n      ReplaceOperationWithNoOp(node, properties, optimized_graph);\n    } else {\n      ReplaceOperationWithIdentity(0 /* input_to_forward */, *properties, node,\n                                   optimized_graph);\n    }\n  }\n}", "func_hash": 200443025383723882799913259251295717351, "file_name": "constant_folding.cc", "file_hash": 221573695858123615640237954647315751120, "cwe": ["CWE-617"], "cve": "CVE-2022-23581", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The Grappler optimizer in TensorFlow can be used to cause a denial of service by altering a `SavedModel` such that `IsSimplifiableReshape` would trigger `CHECK` failures. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23581"}
{"idx": 195720, "project": "mvfst", "commit_id": "a67083ff4b8dcbb7ee2839da6338032030d712b0", "project_url": "https://github.com/facebookincubator/mvfst", "commit_url": "https://github.com/facebookincubator/mvfst/commit/a67083ff4b8dcbb7ee2839da6338032030d712b0", "commit_message": "Close connection if we derive an extra 1-rtt write cipher\n\nSummary: Fixes CVE-2021-24029\n\nReviewed By: mjoras, lnicco\n\nDifferential Revision: D26613890\n\nfbshipit-source-id: 19bb2be2c731808144e1a074ece313fba11f1945", "target": 1, "func": "void updateHandshakeState(QuicServerConnectionState& conn) {\n  // Zero RTT read cipher is available after chlo is processed with the\n  // condition that early data attempt is accepted.\n  auto handshakeLayer = conn.serverHandshakeLayer;\n  auto zeroRttReadCipher = handshakeLayer->getZeroRttReadCipher();\n  auto zeroRttHeaderCipher = handshakeLayer->getZeroRttReadHeaderCipher();\n  // One RTT write cipher is available at Fizz layer after chlo is processed.\n  // However, the cipher is only exported to QUIC if early data attempt is\n  // accepted. Otherwise, the cipher will be available after cfin is\n  // processed.\n  auto oneRttWriteCipher = handshakeLayer->getOneRttWriteCipher();\n  // One RTT read cipher is available after cfin is processed.\n  auto oneRttReadCipher = handshakeLayer->getOneRttReadCipher();\n\n  auto oneRttWriteHeaderCipher = handshakeLayer->getOneRttWriteHeaderCipher();\n  auto oneRttReadHeaderCipher = handshakeLayer->getOneRttReadHeaderCipher();\n\n  if (zeroRttReadCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedZeroRttReadCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 0-rtt read cipher\");\n    conn.readCodec->setZeroRttReadCipher(std::move(zeroRttReadCipher));\n  }\n  if (zeroRttHeaderCipher) {\n    conn.readCodec->setZeroRttHeaderCipher(std::move(zeroRttHeaderCipher));\n  }\n  if (oneRttWriteHeaderCipher) {\n    conn.oneRttWriteHeaderCipher = std::move(oneRttWriteHeaderCipher);\n  }\n  if (oneRttReadHeaderCipher) {\n    conn.readCodec->setOneRttHeaderCipher(std::move(oneRttReadHeaderCipher));\n  }\n\n  if (oneRttWriteCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedOneRttWriteCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 1-rtt write cipher\");\n    CHECK(!conn.oneRttWriteCipher.get());\n    conn.oneRttWriteCipher = std::move(oneRttWriteCipher);\n\n    updatePacingOnKeyEstablished(conn);\n\n    // We negotiate the transport parameters whenever we have the 1-RTT write\n    // keys available.\n    auto clientParams = handshakeLayer->getClientTransportParams();\n    if (!clientParams) {\n      throw QuicTransportException(\n          \"No client transport params\",\n          TransportErrorCode::TRANSPORT_PARAMETER_ERROR);\n    }\n    processClientInitialParams(conn, std::move(*clientParams));\n  }\n  if (oneRttReadCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedOneRttReadCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 1-rtt read cipher\");\n    // Clear limit because CFIN is received at this point\n    conn.writableBytesLimit = folly::none;\n    conn.readCodec->setOneRttReadCipher(std::move(oneRttReadCipher));\n  }\n  auto handshakeReadCipher = handshakeLayer->getHandshakeReadCipher();\n  auto handshakeReadHeaderCipher =\n      handshakeLayer->getHandshakeReadHeaderCipher();\n  if (handshakeReadCipher) {\n    CHECK(handshakeReadHeaderCipher);\n    conn.readCodec->setHandshakeReadCipher(std::move(handshakeReadCipher));\n    conn.readCodec->setHandshakeHeaderCipher(\n        std::move(handshakeReadHeaderCipher));\n  }\n  if (handshakeLayer->isHandshakeDone()) {\n    CHECK(conn.oneRttWriteCipher);\n    if (conn.version != QuicVersion::MVFST_D24 && !conn.sentHandshakeDone) {\n      sendSimpleFrame(conn, HandshakeDoneFrame());\n      conn.sentHandshakeDone = true;\n    }\n  }\n}", "func_hash": 43735419078414129480912957086830640484, "file_name": "ServerStateMachine.cpp", "file_hash": 9223824505720776904271246874049398430, "cwe": ["CWE-703"], "cve": "CVE-2021-24029", "cve_desc": "A packet of death scenario is possible in mvfst via a specially crafted message during a QUIC session, which causes a crash via a failed assertion. Per QUIC specification, this particular message should be treated as a connection error. This issue affects mvfst versions prior to commit a67083ff4b8dcbb7ee2839da6338032030d712b0 and proxygen versions prior to v2021.03.15.00.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-24029"}
{"idx": 90753, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  void DidDeleteOriginData(QuotaStatusCode status) {\n    DCHECK_GT(remaining_clients_, 0);\n\n    if (status != kQuotaStatusOk)\n      ++error_count_;\n\n    if (--remaining_clients_ == 0)\n      CallCompleted();\n  }\n", "func_hash": 74424777116610544739453975505352142615, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 218815, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static MagickBooleanType ReadPSDMergedImage(const ImageInfo *image_info,\n  Image* image,const PSDInfo* psd_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    *sizes;\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  ssize_t\n    i;\n\n  compression=(PSDCompressionType) ReadBlobMSBShort(image);\n  image->compression=ConvertPSDCompression(compression);\n\n  if (compression != Raw && compression != RLE)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        TypeWarning,\"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      return(MagickFalse);\n    }\n\n  sizes=(MagickOffsetType *) NULL;\n  if (compression == RLE)\n    {\n      sizes=ReadPSDRLESizes(image,psd_info,image->rows*psd_info->channels);\n      if (sizes == (MagickOffsetType *) NULL)\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n    }\n\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) psd_info->channels; i++)\n  {\n    ssize_t\n      type;\n\n    type=i;\n    if ((type == 1) && (psd_info->channels == 2))\n      type=-1;\n\n    if (compression == RLE)\n      status=ReadPSDChannelRLE(image,psd_info,type,sizes+(i*image->rows),\n        exception);\n    else\n      status=ReadPSDChannelRaw(image,psd_info->channels,type,exception);\n\n    if (status != MagickFalse)\n      status=SetImageProgress(image,LoadImagesTag,(MagickOffsetType) i,\n        psd_info->channels);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if ((status != MagickFalse) && (image->colorspace == CMYKColorspace))\n    status=NegateImage(image,MagickFalse);\n\n  if (status != MagickFalse)\n    status=CorrectPSDAlphaBlend(image_info,image,exception);\n\n  sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n\n  return(status);\n}", "func_hash": 294253529949137804054220558065118737390, "file_name": "psd.c", "file_hash": 226732625250511916284298083592366716300, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 222499, "project": "tensorflow", "commit_id": "3d89911481ba6ebe8c88c1c0b595412121e6c645", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/3d89911481ba6ebe8c88c1c0b595412121e6c645", "commit_message": "Eliminate `CHECK`-fail from `function.cc`.\n\nPiperOrigin-RevId: 409414744\nChange-Id: Ic854e12ab2edb88b165d32e2d632c4ee654d71ad", "target": 0, "func": "string GetFunctionResourceInputDevice(\n    const Tensor& input, const int arg_index, const FunctionDef& function_def,\n    absl::flat_hash_map<string, std::vector<string>>* composite_devices) {\n  const auto& handles = input.flat<ResourceHandle>();\n  const ResourceHandle& handle0 = handles(0);\n  string composite_device;\n  auto iter = function_def.arg_attr().find(arg_index);\n  if (iter != function_def.arg_attr().end()) {\n    auto arg_attr = iter->second.attr().find(\"_composite_device\");\n    if (arg_attr != iter->second.attr().end()) {\n      composite_device = arg_attr->second.s();\n    }\n  }\n  if (!composite_device.empty()) {\n    if (composite_devices->find(composite_device) == composite_devices->end()) {\n      for (int i = 0; i < handles.size(); ++i) {\n        (*composite_devices)[composite_device].push_back(handles(i).device());\n      }\n    }\n    return composite_device;\n  } else {\n    return handle0.device();\n  }\n}", "func_hash": 313446711918936241788632172462414196119, "file_name": "function.cc", "file_hash": 275755455359751936167516531130081059449, "cwe": ["CWE-617"], "cve": "CVE-2022-23586", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that assertions in `function.cc` would be falsified and crash the Python interpreter. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23586"}
{"idx": 222511, "project": "tensorflow", "commit_id": "3d89911481ba6ebe8c88c1c0b595412121e6c645", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/3d89911481ba6ebe8c88c1c0b595412121e6c645", "commit_message": "Eliminate `CHECK`-fail from `function.cc`.\n\nPiperOrigin-RevId: 409414744\nChange-Id: Ic854e12ab2edb88b165d32e2d632c4ee654d71ad", "target": 0, "func": "const FunctionDef* FunctionLibraryDefinition::GetAttrImpl(\n    const NodeDef& ndef) const {\n  if (ndef.op() != kGradientOp) {\n    // If 'ndef' calls a function and the function's def has the attr,\n    // returns it.\n    return Find(ndef.op());\n  }\n\n  // If ndef is SymbolicGradient[f=Foo], we use Foo's gradient or\n  // Foo's attributes.\n  const NameAttrList* forward_func_attrs;\n  if (!TryGetNodeAttr(ndef, kFuncAttr, &forward_func_attrs)) {\n    return nullptr;\n  }\n  const string& func_name = forward_func_attrs->name();\n  {\n    tf_shared_lock l(mu_);\n    const string& grad_name = FindGradientHelper(func_name);\n    // If 'func' has a user-defined gradient function, uses the grad\n    // function's attrs to see if noinline is specified. Otherwise,\n    // uses func's attrs.\n    if (!grad_name.empty()) {\n      if (const auto helper = FindHelper(grad_name)) {\n        return &(helper->fdef);\n      } else {\n        return nullptr;\n      }\n    }\n    if (const auto helper = FindHelper(func_name)) {\n      return &(helper->fdef);\n    } else {\n      return nullptr;\n    }\n  }\n}", "func_hash": 327048412374987476606115012331908611092, "file_name": "function.cc", "file_hash": 275755455359751936167516531130081059449, "cwe": ["CWE-617"], "cve": "CVE-2022-23586", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that assertions in `function.cc` would be falsified and crash the Python interpreter. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23586"}
{"idx": 220839, "project": "tensorflow", "commit_id": "8c6f391a2282684a25cbfec7687bd5d35261a209", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/8c6f391a2282684a25cbfec7687bd5d35261a209", "commit_message": "[lite] Add check for bias_size is zero to avoid division by zero. This shouldn't happen for properly converted models. Just safety check\n\nPiperOrigin-RevId: 416383645\nChange-Id: If8e508bf696ae8ecfb927e69c139a8ccf7fe60cb", "target": 0, "func": "void optimized_ops_prefetch_write_l1_keep(const T* ptr) {\n#ifdef __GNUC__\n  // builtin offered by GCC-compatible compilers including clang\n  __builtin_prefetch(ptr, /* 1 means write */ 1, /* 3 means high locality */ 3);\n#else\n  (void)ptr;\n#endif\n}", "func_hash": 335492403279245020974247764118686459292, "file_name": "common.h", "file_hash": 206010119069068373550820723284960883967, "cwe": ["CWE-369"], "cve": "CVE-2022-23557", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would trigger a division by zero in `BiasAndClamp` implementation. There is no check that the `bias_size` is non zero. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23557"}
{"idx": 210887, "project": "qemu", "commit_id": "1caff0340f49c93d535c6558a5138d20d475315c", "project_url": "https://github.com/bonzini/qemu", "commit_url": "https://git.qemu.org/?p=qemu.git;a=commit;h=1caff0340f49c93d535c6558a5138d20d475315c", "commit_message": "e1000: switch to use qemu_receive_packet() for loopback\n\nThis patch switches to use qemu_receive_packet() which can detect\nreentrancy and return early.\n\nThis is intended to address CVE-2021-3416.\n\nCc: Prasad J Pandit <ppandit@redhat.com>\nCc: qemu-stable@nongnu.org\nReviewed-by: Philippe Mathieu-Daud\u00e9 <philmd@redhat.com>\nSigned-off-by: Jason Wang <jasowang@redhat.com>", "target": 1, "func": "e1000_send_packet(E1000State *s, const uint8_t *buf, int size)\n{\n    static const int PTCregs[6] = { PTC64, PTC127, PTC255, PTC511,\n                                    PTC1023, PTC1522 };\n\n    NetClientState *nc = qemu_get_queue(s->nic);\n    if (s->phy_reg[PHY_CTRL] & MII_CR_LOOPBACK) {\n        nc->info->receive(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n    inc_tx_bcast_or_mcast_count(s, buf);\n    e1000x_increase_size_stats(s->mac_reg, PTCregs, size);\n}", "func_hash": 230013883840968138268073793174320435209, "file_name": "e1000.c", "file_hash": 176409209781362413917058775514144703306, "cwe": ["CWE-835"], "cve": "CVE-2021-3416", "cve_desc": "A potential stack overflow via infinite loop issue was found in various NIC emulators of QEMU in versions up to and including 5.2.0. The issue occurs in loopback mode of a NIC wherein reentrant DMA checks get bypassed. A guest user/process may use this flaw to consume CPU cycles or crash the QEMU process on the host resulting in DoS scenario.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3416"}
{"idx": 220830, "project": "tensorflow", "commit_id": "8c6f391a2282684a25cbfec7687bd5d35261a209", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/8c6f391a2282684a25cbfec7687bd5d35261a209", "commit_message": "[lite] Add check for bias_size is zero to avoid division by zero. This shouldn't happen for properly converted models. Just safety check\n\nPiperOrigin-RevId: 416383645\nChange-Id: If8e508bf696ae8ecfb927e69c139a8ccf7fe60cb", "target": 0, "func": "inline int32_t MultiplyByQuantizedMultiplier(int32_t x,\n                                             int32_t quantized_multiplier,\n                                             int shift) {\n  TFLITE_DCHECK(quantized_multiplier >= 0);\n  TFLITE_DCHECK(shift >= -31 && shift <= 30);\n\n  const int64_t total_shift = 31 - shift;\n  const int64_t round = static_cast<int64_t>(1) << (total_shift - 1);\n  int64_t result = x * static_cast<int64_t>(quantized_multiplier) + round;\n  result = result >> total_shift;\n\n  TFLITE_DCHECK(result >= std::numeric_limits<int32_t>::min() &&\n                result <= std::numeric_limits<int32_t>::max());\n  return static_cast<int32_t>(result);\n}", "func_hash": 136773084967392616146537741227969047882, "file_name": "common.h", "file_hash": 206010119069068373550820723284960883967, "cwe": ["CWE-369"], "cve": "CVE-2022-23557", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would trigger a division by zero in `BiasAndClamp` implementation. There is no check that the `bias_size` is non zero. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23557"}
{"idx": 218792, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static ssize_t DecodePSDPixels(const size_t number_compact_pixels,\n  const unsigned char *compact_pixels,const ssize_t depth,\n  const size_t number_pixels,unsigned char *pixels)\n{\n#define CheckNumberCompactPixels \\\n  if (packets == 0) \\\n    return(i); \\\n  packets--\n\n#define CheckNumberPixels(count) \\\n  if (((ssize_t) i + count) > (ssize_t) number_pixels) \\\n    return(i); \\\n  i+=count\n\n  int\n    pixel;\n\n  ssize_t\n    i,\n    j;\n\n  size_t\n    length;\n\n  ssize_t\n    packets;\n\n  packets=(ssize_t) number_compact_pixels;\n  for (i=0; (packets > 1) && (i < (ssize_t) number_pixels); )\n  {\n    packets--;\n    length=(size_t) (*compact_pixels++);\n    if (length == 128)\n      continue;\n    if (length > 128)\n      {\n        length=256-length+1;\n        CheckNumberCompactPixels;\n        pixel=(*compact_pixels++);\n        for (j=0; j < (ssize_t) length; j++)\n        {\n          switch (depth)\n          {\n            case 1:\n            {\n              CheckNumberPixels(8);\n              *pixels++=(pixel >> 7) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 6) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 5) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 4) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 3) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 2) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 1) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 0) & 0x01 ? 0U : 255U;\n              break;\n            }\n            case 2:\n            {\n              CheckNumberPixels(4);\n              *pixels++=(unsigned char) ((pixel >> 6) & 0x03);\n              *pixels++=(unsigned char) ((pixel >> 4) & 0x03);\n              *pixels++=(unsigned char) ((pixel >> 2) & 0x03);\n              *pixels++=(unsigned char) ((pixel & 0x03) & 0x03);\n              break;\n            }\n            case 4:\n            {\n              CheckNumberPixels(2);\n              *pixels++=(unsigned char) ((pixel >> 4) & 0xff);\n              *pixels++=(unsigned char) ((pixel & 0x0f) & 0xff);\n              break;\n            }\n            default:\n            {\n              CheckNumberPixels(1);\n              *pixels++=(unsigned char) pixel;\n              break;\n            }\n          }\n        }\n        continue;\n      }\n    length++;\n    for (j=0; j < (ssize_t) length; j++)\n    {\n      CheckNumberCompactPixels;\n      switch (depth)\n      {\n        case 1:\n        {\n          CheckNumberPixels(8);\n          *pixels++=(*compact_pixels >> 7) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 6) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 5) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 4) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 3) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 2) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 1) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 0) & 0x01 ? 0U : 255U;\n          break;\n        }\n        case 2:\n        {\n          CheckNumberPixels(4);\n          *pixels++=(*compact_pixels >> 6) & 0x03;\n          *pixels++=(*compact_pixels >> 4) & 0x03;\n          *pixels++=(*compact_pixels >> 2) & 0x03;\n          *pixels++=(*compact_pixels & 0x03) & 0x03;\n          break;\n        }\n        case 4:\n        {\n          CheckNumberPixels(2);\n          *pixels++=(*compact_pixels >> 4) & 0xff;\n          *pixels++=(*compact_pixels & 0x0f) & 0xff;\n          break;\n        }\n        default:\n        {\n          CheckNumberPixels(1);\n          *pixels++=(*compact_pixels);\n          break;\n        }\n      }\n      compact_pixels++;\n    }\n  }\n  return(i);\n}", "func_hash": 241760556345587017617785150289217130169, "file_name": "psd.c", "file_hash": 226732625250511916284298083592366716300, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 220189, "project": "tensorflow", "commit_id": "c99d98cd189839dcf51aee94e7437b54b31f8abd", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/c99d98cd189839dcf51aee94e7437b54b31f8abd", "commit_message": "Handle invalid inputs instead of crashing.\n\nPiperOrigin-RevId: 409549744\nChange-Id: I7f5935b34b53f7e426a5462fcc027bdbf5dcda24", "target": 0, "func": "const OpDef& Node::op_def() const { return *props_->op_def; }", "func_hash": 117405320604299960701568011411506967029, "file_name": "graph.cc", "file_hash": 172099243927919341591512227523808328051, "cwe": ["CWE-125"], "cve": "CVE-2022-23592", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. TensorFlow's type inference can cause a heap out of bounds read as the bounds checking is done in a `DCHECK` (which is a no-op during production). An attacker can control the `input_idx` variable such that `ix` would be larger than the number of values in `node_t.args`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23592"}
{"idx": 218750, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static MagickBooleanType ReadPSDChannelZip(Image *image,const size_t channels,\n  const ssize_t type,const PSDCompressionType compression,\n  const size_t compact_size,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  unsigned char\n    *p;\n\n  size_t\n    count,\n    length,\n    packet_size,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  z_stream\n    stream;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is ZIP compressed\");\n\n  if ((MagickSizeType) compact_size > GetBlobSize(image))\n    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(compact_size,\n    sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  packet_size=GetPSDPacketSize(image);\n  row_size=image->columns*packet_size;\n  count=image->rows*row_size;\n\n  pixels=(unsigned char *) AcquireQuantumMemory(count,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    {\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  if (ReadBlob(image,compact_size,compact_pixels) != (ssize_t) compact_size)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n    }\n\n  memset(&stream,0,sizeof(stream));\n  stream.data_type=Z_BINARY;\n  stream.next_in=(Bytef *)compact_pixels;\n  stream.avail_in=(uInt) compact_size;\n  stream.next_out=(Bytef *)pixels;\n  stream.avail_out=(uInt) count;\n\n  if (inflateInit(&stream) == Z_OK)\n    {\n      int\n        ret;\n\n      while (stream.avail_out > 0)\n      {\n        ret=inflate(&stream,Z_SYNC_FLUSH);\n        if ((ret != Z_OK) && (ret != Z_STREAM_END))\n          {\n            (void) inflateEnd(&stream);\n            compact_pixels=(unsigned char *) RelinquishMagickMemory(\n              compact_pixels);\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            return(MagickFalse);\n          }\n        if (ret == Z_STREAM_END)\n          break;\n      }\n      (void) inflateEnd(&stream);\n    }\n\n  if (compression == ZipWithPrediction)\n  {\n     p=pixels;\n     while (count > 0)\n     {\n       length=image->columns;\n       while (--length)\n       {\n         if (packet_size == 2)\n           {\n             p[2]+=p[0]+((p[1]+p[3]) >> 8);\n             p[3]+=p[1];\n           }\n         else\n          *(p+1)+=*p;\n         p+=packet_size;\n       }\n       p+=packet_size;\n       count-=row_size;\n     }\n  }\n\n  status=MagickTrue;\n  p=pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=ReadPSDChannelPixels(image,channels,y,type,p,exception);\n    if (status == MagickFalse)\n      break;\n\n    p+=row_size;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}", "func_hash": 278771513550213027225790387170812880777, "file_name": "psd.c", "file_hash": 226732625250511916284298083592366716300, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 220399, "project": "mruby", "commit_id": "27d1e0132a0804581dca28df042e7047fd27eaa8", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8", "commit_message": "array.c: fix `mrb_ary_shift_m` initialization bug.\n\nThe `ARY_PTR` and `ARY_LEN` may be modified in `mrb_get_args`.", "target": 0, "func": "ary_replace(mrb_state *mrb, struct RArray *a, struct RArray *b)\n{\n  mrb_int len = ARY_LEN(b);\n\n  ary_modify_check(mrb, a);\n  if (a == b) return;\n  if (ARY_SHARED_P(a)) {\n    mrb_ary_decref(mrb, a->as.heap.aux.shared);\n    a->as.heap.aux.capa = 0;\n    a->as.heap.len = 0;\n    a->as.heap.ptr = NULL;\n    ARY_UNSET_SHARED_FLAG(a);\n  }\n  if (ARY_SHARED_P(b)) {\n  shared_b:\n    if (ARY_EMBED_P(a)) {\n      ARY_UNSET_EMBED_FLAG(a);\n    }\n    else {\n      mrb_free(mrb, a->as.heap.ptr);\n    }\n    a->as.heap.ptr = b->as.heap.ptr;\n    a->as.heap.len = len;\n    a->as.heap.aux.shared = b->as.heap.aux.shared;\n    a->as.heap.aux.shared->refcnt++;\n    ARY_SET_SHARED_FLAG(a);\n    mrb_write_barrier(mrb, (struct RBasic*)a);\n    return;\n  }\n  if (!mrb_frozen_p(b) && len > ARY_REPLACE_SHARED_MIN) {\n    ary_make_shared(mrb, b);\n    goto shared_b;\n  }\n  if (ARY_CAPA(a) < len)\n    ary_expand_capa(mrb, a, len);\n  array_copy(ARY_PTR(a), ARY_PTR(b), len);\n  mrb_write_barrier(mrb, (struct RBasic*)a);\n  ARY_SET_LEN(a, len);\n}", "func_hash": 57203599215708279030571847204974539815, "file_name": "array.c", "file_hash": 295526445825727607536544634773604768998, "cwe": ["CWE-476"], "cve": "CVE-2021-4188", "cve_desc": "mruby is vulnerable to NULL Pointer Dereference", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4188"}
{"idx": 216027, "project": "tar", "commit_id": "cb07844454d8cc9fb21f53ace75975f91185a120", "project_url": "http://git.savannah.gnu.org/cgit/tar", "commit_url": "http://git.savannah.gnu.org/cgit/tar.git/commit/?id=cb07844454d8cc9fb21f53ace75975f91185a120", "commit_message": "Fix possible NULL dereference (savannah bug #55369)\n\n* src/sparse.c (pax_decode_header): Check return from find_next_block.", "target": 1, "func": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n      \n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           b = find_next_block ();                                 \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n      blk = find_next_block ();\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n\n  return true;\n}", "func_hash": 160355660991121839913024673798590735910, "file_name": "None", "file_hash": null, "cwe": ["CWE-476"], "cve": "CVE-2019-9923", "cve_desc": "pax_decode_header in sparse.c in GNU Tar before 1.32 had a NULL pointer dereference when parsing certain archives that have malformed extended headers.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-9923"}
{"idx": 90197, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "static std::string WrapWithTD(std::string text) {\n  return \"<td>\" + text + \"</td>\";\n}\n", "func_hash": 279042938259629419465158688971741419146, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 204351, "project": "squirrel", "commit_id": "23a0620658714b996d20da3d4dd1a0dcf9b0bd98", "project_url": "https://github.com/albertodemichelis/squirrel", "commit_url": "https://github.com/albertodemichelis/squirrel/commit/23a0620658714b996d20da3d4dd1a0dcf9b0bd98", "commit_message": "check max member count in class", "target": 1, "func": "bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n{\n    SQObjectPtr temp;\n    bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n    if(_locked && !belongs_to_static_table)\n        return false; //the class already has an instance so cannot be modified\n    if(_members->Get(key,temp) && _isfield(temp)) //overrides the default value\n    {\n        _defaultvalues[_member_idx(temp)].val = val;\n        return true;\n    }\n    if(belongs_to_static_table) {\n        SQInteger mmidx;\n        if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n            (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n            _metamethods[mmidx] = val;\n        }\n        else {\n            SQObjectPtr theval = val;\n            if(_base && sq_type(val) == OT_CLOSURE) {\n                theval = _closure(val)->Clone();\n                _closure(theval)->_base = _base;\n                __ObjAddRef(_base); //ref for the closure\n            }\n            if(sq_type(temp) == OT_NULL) {\n                bool isconstructor;\n                SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                if(isconstructor) {\n                    _constructoridx = (SQInteger)_methods.size();\n                }\n                SQClassMember m;\n                m.val = theval;\n                _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                _methods.push_back(m);\n            }\n            else {\n                _methods[_member_idx(temp)].val = theval;\n            }\n        }\n        return true;\n    }\n    SQClassMember m;\n    m.val = val;\n    _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n    _defaultvalues.push_back(m);\n    return true;\n}", "func_hash": 269872855469648419079058130898644045027, "file_name": "sqclass.cpp", "file_hash": 75131817582394814638781750834830258905, "cwe": ["CWE-125"], "cve": "CVE-2021-41556", "cve_desc": "sqclass.cpp in Squirrel through 2.2.5 and 3.x through 3.1 allows an out-of-bounds read (in the core interpreter) that can lead to Code Execution. If a victim executes an attacker-controlled squirrel script, it is possible for the attacker to break out of the squirrel script sandbox even if all dangerous functionality such as File System functions has been disabled. An attacker might abuse this bug to target (for example) Cloud services that allow customization via SquirrelScripts, or distribute malware through video games that embed a Squirrel Engine.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41556"}
{"idx": 163835, "project": "Chrome", "commit_id": "6d067124e87295721c62a77f0610e4b37f6098ad", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/6d067124e87295721c62a77f0610e4b37f6098ad", "commit_message": "None", "target": 0, "func": "v8::Handle<v8::Value> V8ThrowException::createDOMException(v8::Isolate* isolate, int ec, const String& sanitizedMessage, const String& unsanitizedMessage, const v8::Handle<v8::Object>& creationContext)\n{\n    if (ec <= 0 || v8::V8::IsExecutionTerminating())\n        return v8Undefined();\n\n    ASSERT(ec == SecurityError || unsanitizedMessage.isEmpty());\n\n    if (ec == V8GeneralError)\n        return V8ThrowException::createGeneralError(isolate, sanitizedMessage);\n    if (ec == V8TypeError)\n        return V8ThrowException::createTypeError(isolate, sanitizedMessage);\n    if (ec == V8RangeError)\n        return V8ThrowException::createRangeError(isolate, sanitizedMessage);\n    if (ec == V8SyntaxError)\n        return V8ThrowException::createSyntaxError(isolate, sanitizedMessage);\n     if (ec == V8ReferenceError)\n         return V8ThrowException::createReferenceError(isolate, sanitizedMessage);\n \n    v8::Handle<v8::Object> sanitizedCreationContext = creationContext;\n\n    // FIXME: Is the current context always the right choice?\n    Frame* frame = toFrameIfNotDetached(creationContext->CreationContext());\n    if (!frame || !BindingSecurity::shouldAllowAccessToFrame(isolate, frame, DoNotReportSecurityError))\n        sanitizedCreationContext = isolate->GetCurrentContext()->Global();\n\n\n     RefPtrWillBeRawPtr<DOMException> domException = DOMException::create(ec, sanitizedMessage, unsanitizedMessage);\n    v8::Handle<v8::Value> exception = toV8(domException.get(), sanitizedCreationContext, isolate);\n \n     if (exception.IsEmpty())\n         return v8Undefined();\n\n    v8::Handle<v8::Value> error = v8::Exception::Error(v8String(isolate, domException->message()));\n    ASSERT(!error.IsEmpty());\n    ASSERT(exception->IsObject());\n    exception->ToObject(isolate)->SetAccessor(v8AtomicString(isolate, \"stack\"), domExceptionStackGetter, domExceptionStackSetter, error);\n    V8HiddenValue::setHiddenValue(isolate, exception->ToObject(isolate), V8HiddenValue::error(isolate), error);\n\n    return exception;\n}\n", "func_hash": 168935182956535440218897240793107318772, "file_name": "None", "file_hash": null, "cwe": [], "cve": "CVE-2015-1210", "cve_desc": "", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1210"}
{"idx": 207826, "project": "linux", "commit_id": "86cdf8e38792545161dbe3350a7eced558ba4d15", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=86cdf8e38792545161dbe3350a7eced558ba4d15", "commit_message": "NFC: reorganize the functions in nci_request\n\nThere is a possible data race as shown below:\n\nthread-A in nci_request()       | thread-B in nci_close_device()\n                                | mutex_lock(&ndev->req_lock);\ntest_bit(NCI_UP, &ndev->flags); |\n...                             | test_and_clear_bit(NCI_UP, &ndev->flags)\nmutex_lock(&ndev->req_lock);    |\n                                |\n\nThis race will allow __nci_request() to be awaked while the device is\ngetting removed.\n\nSimilar to commit e2cb6b891ad2 (\"bluetooth: eliminate the potential race\ncondition when removing the HCI controller\"). this patch alters the\nfunction sequence in nci_request() to prevent the data races between the\nnci_close_device().\n\nSigned-off-by: Lin Ma <linma@zju.edu.cn>\nFixes: 6a2968aaf50c (\"NFC: basic NCI protocol implementation\")\nLink: https://lore.kernel.org/r/20211115145600.8320-1-linma@zju.edu.cn\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>", "target": 1, "func": "inline int nci_request(struct nci_dev *ndev,\n\t\t       void (*req)(struct nci_dev *ndev,\n\t\t\t\t   const void *opt),\n\t\t       const void *opt, __u32 timeout)\n{\n\tint rc;\n\n\tif (!test_bit(NCI_UP, &ndev->flags))\n\t\treturn -ENETDOWN;\n\n\t/* Serialize all requests */\n\tmutex_lock(&ndev->req_lock);\n\trc = __nci_request(ndev, req, opt, timeout);\n\tmutex_unlock(&ndev->req_lock);\n\n\treturn rc;\n}", "func_hash": 328667325881342771806241825725142687855, "file_name": "core.c", "file_hash": 106507480268607342820842798939602712781, "cwe": ["CWE-362"], "cve": "CVE-2021-4202", "cve_desc": "A use-after-free flaw was found in nci_request in net/nfc/nci/core.c in NFC Controller Interface (NCI) in the Linux kernel. This flaw could allow a local attacker with user privileges to cause a data race problem while the device is getting removed, leading to a privilege escalation problem.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4202"}
{"idx": 210700, "project": "squashfs-tools", "commit_id": "79b5a555058eef4e1e7ff220c344d39f8cd09646", "project_url": "https://github.com/plougher/squashfs-tools", "commit_url": "https://github.com/plougher/squashfs-tools/commit/79b5a555058eef4e1e7ff220c344d39f8cd09646", "commit_message": "Unsquashfs: fix write outside destination directory exploit\n\nAn issue on Github (https://github.com/plougher/squashfs-tools/issues/72)\nshows how some specially crafted Squashfs filesystems containing\ninvalid file names (with '/' and ..) can cause Unsquashfs to write\nfiles outside of the destination directory.\n\nThis commit fixes this exploit by checking all names for\nvalidity.\n\nIn doing so I have also added checks for '.' and for names that\nare shorter than they should be (names in the file system should\nnot have '\\0' terminators).\n\nSigned-off-by: Phillip Lougher <phillip@squashfs.org.uk>", "target": 1, "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n\tlong long start;\n\tint bytes;\n\tint dir_count, size;\n\tstruct dir_ent *new_dir;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = 0;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 0)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\t\t\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\tbytes = lookup_entry(directory_table_hash, start);\n\tif(bytes == -1)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %d not \"\n\t\t\t\"found!\\n\", block_start);\n\n\tbytes += (*i)->offset;\n\tsize = (*i)->data + bytes;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_2 sdirh;\n\t\t\tmemcpy(&sdirh, directory_table + bytes, sizeof(sdirh));\n\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n\t\t} else\n\t\t\tmemcpy(&dirh, directory_table + bytes, sizeof(dirh));\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n\t\t\t\tmemcpy(&sdire, directory_table + bytes,\n\t\t\t\t\tsizeof(sdire));\n\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n\t\t\t} else\n\t\t\t\tmemcpy(dire, directory_table + bytes,\n\t\t\t\t\tsizeof(*dire));\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tmemcpy(dire->name, directory_table + bytes,\n\t\t\t\tdire->size + 1);\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n\t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n\t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n\t\t\t\tif(new_dir == NULL)\n\t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n\t\t\t\t\t\t\"realloc failed!\\n\");\n\t\t\t\tdir->dirs = new_dir;\n\t\t\t}\n\t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n\t\t\tdir->dirs[dir->dir_count].start_block =\n\t\t\t\tdirh.start_block;\n\t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n\t\t\tdir->dirs[dir->dir_count].type = dire->type;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tfree(dir->dirs);\n\tfree(dir);\n\treturn NULL;\n}", "func_hash": 337353141626678057542635238119408606270, "file_name": "None", "file_hash": null, "cwe": ["CWE-22"], "cve": "CVE-2021-40153", "cve_desc": "squashfs_opendir in unsquash-1.c in Squashfs-Tools 4.5 stores the filename in the directory entry; this is then used by unsquashfs to create the new file during the unsquash. The filename is not validated for traversal outside of the destination directory, and thus allows writing to locations outside of the destination.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40153"}
{"idx": 211102, "project": "file-roller", "commit_id": "b147281293a8307808475e102a14857055f81631", "project_url": "https://git.gnome.org/browse/file-roller", "commit_url": "https://git.gnome.org/browse/file-roller/commit/?id=b147281293a8307808475e102a14857055f81631", "commit_message": "libarchive: sanitize filenames before extracting", "target": 1, "func": "extract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\ta = archive_read_new ();\n\tarchive_read_support_filter_all (a);\n\tarchive_read_support_format_all (a);\n\tarchive_read_open (a, load_data, load_data_open, load_data_read, load_data_close);\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\tfile = g_file_get_child (extract_data->destination, _g_path_get_relative_basename (fullpath, extract_data->base_dir, extract_data->junk_paths));\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif (extract_data->skip_older || ! extract_data->overwrite) {\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_error_free (local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (g_file_make_directory_with_parents (parent, cancellable, &load_data->error)) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar  *link_fullpath;\n\t\t\t\tGFile *link_file;\n\t\t\t\tchar  *oldname;\n\t\t\t\tchar  *newname;\n\t\t\t\tint    r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, _g_path_get_relative_basename (link_fullpath, extract_data->base_dir, extract_data->junk_paths));\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &offset)) == ARCHIVE_OK) {\n\t\t\t\t\tif (g_output_stream_write (ostream, buffer, buffer_size, cancellable, &load_data->error) == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, buffer_size);\n\t\t\t\t}\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}", "func_hash": 300010717892074286523463178152343343072, "file_name": "None", "file_hash": null, "cwe": ["CWE-22"], "cve": "CVE-2013-4668", "cve_desc": "Directory traversal vulnerability in File Roller 3.6.x before 3.6.4, 3.8.x before 3.8.3, and 3.9.x before 3.9.3, when libarchive is used, allows remote attackers to create arbitrary files via a crafted archive that is not properly handled in a \"Keep directory structure\" action, related to fr-archive-libarchive.c and fr-window.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4668"}
{"idx": 90158, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "bool WifiNetwork::IsCertificateLoaded() const {\n  static const std::string settings_string(\"SETTINGS:\");\n  static const std::string pkcs11_key(\"key_id\");\n  if (cert_path_.find(settings_string) == 0) {\n    std::string::size_type idx = cert_path_.find(pkcs11_key);\n    if (idx != std::string::npos)\n      idx = cert_path_.find_first_not_of(kWhitespaceASCII,\n                                         idx + pkcs11_key.length());\n    if (idx != std::string::npos && cert_path_[idx] == '=')\n      return true;\n  }\n  return false;\n}\n", "func_hash": 132690335736935728948742779437175557994, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90896, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "ClientUsageTracker* UsageTracker::GetClientTracker(QuotaClient::ID client_id) {\n  ClientTrackerMap::iterator found = client_tracker_map_.find(client_id);\n  if (found != client_tracker_map_.end())\n    return found->second;\n  return NULL;\n}\n", "func_hash": 127767815215264003280520421988700710247, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90772, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "void QuotaManager::GetGlobalUsage(\n    StorageType type,\n    GlobalUsageCallback* callback) {\n  LazyInitialize();\n  GetUsageTracker(type)->GetGlobalUsage(callback);\n}\n", "func_hash": 191323255900110242792556979411512288875, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90817, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  QuotaDatabase* database() const { return database_; }\n", "func_hash": 171367258689438156806698316335434850053, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 219906, "project": "gpac", "commit_id": "ad18ece95fa064efc0995c4ab2c985f77fb166ec", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/ad18ece95fa064efc0995c4ab2c985f77fb166ec", "commit_message": "fixed #1904", "target": 0, "func": "GF_Err gf_isom_rtp_set_time_sequence_offset(GF_ISOFile *the_file, u32 trackNumber, u32 HintDescriptionIndex, u32 SequenceNumberOffset)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *hdesc;\n\tu32 i, count;\n\tGF_SeqOffHintEntryBox *ent;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\t//OK, create a new HintSampleDesc\n\thdesc = (GF_HintSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, HintDescriptionIndex - 1);\n\tif (!hdesc) return GF_BAD_PARAM;\n\tcount = gf_list_count(hdesc->child_boxes);\n\n\tfor (i=0; i< count; i++) {\n\t\tent = (GF_SeqOffHintEntryBox *)gf_list_get(hdesc->child_boxes, i);\n\t\tif (ent->type == GF_ISOM_BOX_TYPE_SNRO) {\n\t\t\tent->SeqOffset = SequenceNumberOffset;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//we have to create a new entry...\n\tent = (GF_SeqOffHintEntryBox *) gf_isom_box_new_parent(&hdesc->child_boxes, GF_ISOM_BOX_TYPE_SNRO);\n\tif (!ent) return GF_OUT_OF_MEM;\n\tent->SeqOffset = SequenceNumberOffset;\n\treturn GF_OK;\n}", "func_hash": 181931963058872642836845170978047733337, "file_name": "hint_track.c", "file_hash": 28976036322661795345788739460485147148, "cwe": ["CWE-476"], "cve": "CVE-2021-40576", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability in the gf_isom_get_payt_count function in hint_track.c, which allows attackers to cause a denial of service.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40576"}
{"idx": 218826, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static void XSetMatteColor(Display *display,const XWindowInfo *window_info,\n  const MagickStatusType raised)\n{\n  if (window_info->depth == 1)\n    {\n      /*\n        Monochrome window.\n      */\n      if (raised)\n        (void) XSetForeground(display,window_info->widget_context,\n          XWhitePixel(display,window_info->screen));\n      else\n        (void) XSetForeground(display,window_info->widget_context,\n          XBlackPixel(display,window_info->screen));\n    }\n  else\n    if (raised)\n      (void) XSetForeground(display,window_info->widget_context,\n        window_info->pixel_info->matte_color.pixel);\n    else\n      (void) XSetForeground(display,window_info->widget_context,\n        window_info->pixel_info->depth_color.pixel);\n}", "func_hash": 32137050615397731234685756673547579668, "file_name": "widget.c", "file_hash": 31318598747823313517201273606802259325, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 220207, "project": "tensorflow", "commit_id": "c99d98cd189839dcf51aee94e7437b54b31f8abd", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/c99d98cd189839dcf51aee94e7437b54b31f8abd", "commit_message": "Handle invalid inputs instead of crashing.\n\nPiperOrigin-RevId: 409549744\nChange-Id: I7f5935b34b53f7e426a5462fcc027bdbf5dcda24", "target": 0, "func": "void Node::Initialize(int id, int cost_id,\n                      std::shared_ptr<NodeProperties> props,\n                      Node::NodeClass node_class) {\n  DCHECK_EQ(id_, -1);\n  DCHECK(in_edges_.empty());\n  DCHECK(out_edges_.empty());\n  id_ = id;\n  cost_id_ = cost_id;\n\n  props_ = std::move(props);\n  class_ = node_class;\n}", "func_hash": 248122321044314356389262794157730140085, "file_name": "graph.cc", "file_hash": 172099243927919341591512227523808328051, "cwe": ["CWE-125"], "cve": "CVE-2022-23592", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. TensorFlow's type inference can cause a heap out of bounds read as the bounds checking is done in a `DCHECK` (which is a no-op during production). An attacker can control the `input_idx` variable such that `ix` would be larger than the number of values in `node_t.args`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23592"}
{"idx": 219044, "project": "tensorflow", "commit_id": "240655511cd3e701155f944a972db71b6c0b1bb6", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/240655511cd3e701155f944a972db71b6c0b1bb6", "commit_message": "Eliminate `CHECK`-fails from `IsSimplifiableReshape` via `MakeShape(<invalid shape>)`\n\nPiperOrigin-RevId: 409166738\nChange-Id: I7f0a3590b8acae3f3e3e2fe636e1f5ef285693cf", "target": 0, "func": "Status ConstantFolding::SimplifyNode(NodeDef* node, GraphDef* optimized_graph,\n                                     GraphProperties* properties) {\n  bool graph_modified_cached = graph_modified_;\n  graph_modified_ = false;\n\n  bool use_shape_info = properties->has_properties();\n  RETURN_IF_MODIFIED(RemoveSplitOrSplitV(*properties, optimized_graph, node));\n  RETURN_IF_ERROR_OR_MODIFIED(RemoveShuffleOrTranspose(\n      *properties, use_shape_info, optimized_graph, node));\n  RETURN_IF_MODIFIED(\n      RemoveRandomShuffle(*properties, use_shape_info, optimized_graph, node));\n  RETURN_IF_ERROR_OR_MODIFIED(\n      RemoveReverse(*properties, use_shape_info, optimized_graph, node));\n  RETURN_IF_ERROR_OR_MODIFIED(\n      SimplifySlice(*properties, use_shape_info, optimized_graph, node));\n  RETURN_IF_ERROR_OR_MODIFIED(\n      SimplifyStridedSlice(*properties, use_shape_info, optimized_graph, node));\n  RETURN_IF_ERROR_OR_MODIFIED(\n      SimplifyTile(*properties, use_shape_info, optimized_graph, node));\n  RETURN_IF_ERROR_OR_MODIFIED(\n      SimplifyPad(*properties, use_shape_info, optimized_graph, node));\n  RETURN_IF_MODIFIED(\n      SimplifySqueeze(*properties, use_shape_info, optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(SimplifyPack(optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(MoveConstantsPastEnter(optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(SimplifySwitch(optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      SimplifyReduction(optimized_graph, *properties, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      SimplifyReshape(*properties, use_shape_info, node));\n  RETURN_IF_ERROR_OR_MODIFIED(SimplifyArithmeticOperations(\n      *properties, use_shape_info, optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(ReduceDivToReciprocalMul(optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      ConstantPushDown(properties, optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      MulConvPushDown(optimized_graph, node, *properties));\n  SET_AND_RETURN_IF_MODIFIED(PartialConstPropThroughIdentityN(node));\n  SET_AND_RETURN_IF_MODIFIED(\n      PartialAssocOpConstFolding(optimized_graph, properties, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      MergeConcat(use_shape_info, properties, optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      PartialConcatConstFolding(optimized_graph, properties, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      ConstantPushDownBiasAdd(properties, optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(SimplifyCase(optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      SimplifySelect(*properties, optimized_graph, node));\n  RETURN_IF_MODIFIED(\n      RemoveRedundantVariableUpdates(properties, optimized_graph, node));\n\n  graph_modified_ = graph_modified_cached;\n  return Status::OK();\n}", "func_hash": 152365500003103935740051819091631486618, "file_name": "constant_folding.cc", "file_hash": 221573695858123615640237954647315751120, "cwe": ["CWE-617"], "cve": "CVE-2022-23581", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The Grappler optimizer in TensorFlow can be used to cause a denial of service by altering a `SavedModel` such that `IsSimplifiableReshape` would trigger `CHECK` failures. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23581"}
{"idx": 220389, "project": "mruby", "commit_id": "27d1e0132a0804581dca28df042e7047fd27eaa8", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8", "commit_message": "array.c: fix `mrb_ary_shift_m` initialization bug.\n\nThe `ARY_PTR` and `ARY_LEN` may be modified in `mrb_get_args`.", "target": 0, "func": "mrb_ary_clear(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n\n  ary_modify(mrb, a);\n  if (ARY_SHARED_P(a)) {\n    mrb_ary_decref(mrb, a->as.heap.aux.shared);\n    ARY_UNSET_SHARED_FLAG(a);\n  }\n  else if (!ARY_EMBED_P(a)){\n    mrb_free(mrb, a->as.heap.ptr);\n  }\n  if (MRB_ARY_EMBED_LEN_MAX > 0) {\n    ARY_SET_EMBED_LEN(a, 0);\n  }\n  else {\n    a->as.heap.ptr = NULL;\n    a->as.heap.aux.capa = 0;\n    ARY_SET_LEN(a, 0);\n  }\n  return self;\n}", "func_hash": 167070430258100010066407137177714279043, "file_name": "array.c", "file_hash": 295526445825727607536544634773604768998, "cwe": ["CWE-476"], "cve": "CVE-2021-4188", "cve_desc": "mruby is vulnerable to NULL Pointer Dereference", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4188"}
{"idx": 220416, "project": "mruby", "commit_id": "27d1e0132a0804581dca28df042e7047fd27eaa8", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8", "commit_message": "array.c: fix `mrb_ary_shift_m` initialization bug.\n\nThe `ARY_PTR` and `ARY_LEN` may be modified in `mrb_get_args`.", "target": 0, "func": "mrb_ary_eq(mrb_state *mrb, mrb_value ary1)\n{\n  mrb_value ary2 = mrb_get_arg1(mrb);\n\n  mrb->c->ci->mid = 0;\n  if (mrb_obj_equal(mrb, ary1, ary2)) return mrb_true_value();\n  if (!mrb_array_p(ary2)) {\n    return mrb_false_value();\n  }\n  if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return mrb_false_value();\n\n  return ary2;\n}", "func_hash": 105503070746107567694532782420047900731, "file_name": "array.c", "file_hash": 295526445825727607536544634773604768998, "cwe": ["CWE-476"], "cve": "CVE-2021-4188", "cve_desc": "mruby is vulnerable to NULL Pointer Dereference", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4188"}
{"idx": 196328, "project": "vim", "commit_id": "409510c588b1eec1ae33511ae97a21eb8e110895", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/409510c588b1eec1ae33511ae97a21eb8e110895", "commit_message": "patch 8.2.5050: using freed memory when searching for pattern in path\n\nProblem:    Using freed memory when searching for pattern in path.\nSolution:   Make a copy of the line.", "target": 1, "func": "find_pattern_in_path(\n    char_u\t*ptr,\t\t// pointer to search pattern\n    int\t\tdir UNUSED,\t// direction of expansion\n    int\t\tlen,\t\t// length of search pattern\n    int\t\twhole,\t\t// match whole words only\n    int\t\tskip_comments,\t// don't match inside comments\n    int\t\ttype,\t\t// Type of search; are we looking for a type?\n\t\t\t\t// a macro?\n    long\tcount,\n    int\t\taction,\t\t// What to do when we find it\n    linenr_T\tstart_lnum,\t// first line to start searching\n    linenr_T\tend_lnum)\t// last line for searching\n{\n    SearchedFile *files;\t\t// Stack of included files\n    SearchedFile *bigger;\t\t// When we need more space\n    int\t\tmax_path_depth = 50;\n    long\tmatch_count = 1;\n\n    char_u\t*pat;\n    char_u\t*new_fname;\n    char_u\t*curr_fname = curbuf->b_fname;\n    char_u\t*prev_fname = NULL;\n    linenr_T\tlnum;\n    int\t\tdepth;\n    int\t\tdepth_displayed;\t// For type==CHECK_PATH\n    int\t\told_files;\n    int\t\talready_searched;\n    char_u\t*file_line;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\tsave_char;\n    int\t\tdefine_matched;\n    regmatch_T\tregmatch;\n    regmatch_T\tincl_regmatch;\n    regmatch_T\tdef_regmatch;\n    int\t\tmatched = FALSE;\n    int\t\tdid_show = FALSE;\n    int\t\tfound = FALSE;\n    int\t\ti;\n    char_u\t*already = NULL;\n    char_u\t*startp = NULL;\n    char_u\t*inc_opt = NULL;\n#if defined(FEAT_QUICKFIX)\n    win_T\t*curwin_save = NULL;\n#endif\n\n    regmatch.regprog = NULL;\n    incl_regmatch.regprog = NULL;\n    def_regmatch.regprog = NULL;\n\n    file_line = alloc(LSIZE);\n    if (file_line == NULL)\n\treturn;\n\n    if (type != CHECK_PATH && type != FIND_DEFINE\n\t    // when CONT_SOL is set compare \"ptr\" with the beginning of the\n\t    // line is faster than quote_meta/regcomp/regexec \"ptr\" -- Acevedo\n\t    && !compl_status_sol())\n    {\n\tpat = alloc(len + 5);\n\tif (pat == NULL)\n\t    goto fpip_end;\n\tsprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", len, ptr);\n\t// ignore case according to p_ic, p_scs and pat\n\tregmatch.rm_ic = ignorecase(pat);\n\tregmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);\n\tvim_free(pat);\n\tif (regmatch.regprog == NULL)\n\t    goto fpip_end;\n    }\n    inc_opt = (*curbuf->b_p_inc == NUL) ? p_inc : curbuf->b_p_inc;\n    if (*inc_opt != NUL)\n    {\n\tincl_regmatch.regprog = vim_regcomp(inc_opt,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (incl_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tincl_regmatch.rm_ic = FALSE;\t// don't ignore case in incl. pat.\n    }\n    if (type == FIND_DEFINE && (*curbuf->b_p_def != NUL || *p_def != NUL))\n    {\n\tdef_regmatch.regprog = vim_regcomp(*curbuf->b_p_def == NUL\n\t\t\t   ? p_def : curbuf->b_p_def,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (def_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tdef_regmatch.rm_ic = FALSE;\t// don't ignore case in define pat.\n    }\n    files = lalloc_clear(max_path_depth * sizeof(SearchedFile), TRUE);\n    if (files == NULL)\n\tgoto fpip_end;\n    old_files = max_path_depth;\n    depth = depth_displayed = -1;\n\n    lnum = start_lnum;\n    if (end_lnum > curbuf->b_ml.ml_line_count)\n\tend_lnum = curbuf->b_ml.ml_line_count;\n    if (lnum > end_lnum)\t\t// do at least one line\n\tlnum = end_lnum;\n    line = ml_get(lnum);\n\n    for (;;)\n    {\n\tif (incl_regmatch.regprog != NULL\n\t\t&& vim_regexec(&incl_regmatch, line, (colnr_T)0))\n\t{\n\t    char_u *p_fname = (curr_fname == curbuf->b_fname)\n\t\t\t\t\t      ? curbuf->b_ffname : curr_fname;\n\n\t    if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t// Use text from '\\zs' to '\\ze' (or end) of 'include'.\n\t\tnew_fname = find_file_name_in_path(incl_regmatch.startp[0],\n\t\t       (int)(incl_regmatch.endp[0] - incl_regmatch.startp[0]),\n\t\t\t\t FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname);\n\t    else\n\t\t// Use text after match with 'include'.\n\t\tnew_fname = file_name_in_line(incl_regmatch.endp[0], 0,\n\t\t\t     FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);\n\t    already_searched = FALSE;\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Check whether we have already searched in this file\n\t\tfor (i = 0;; i++)\n\t\t{\n\t\t    if (i == depth + 1)\n\t\t\ti = old_files;\n\t\t    if (i == max_path_depth)\n\t\t\tbreak;\n\t\t    if (fullpathcmp(new_fname, files[i].name, TRUE, TRUE)\n\t\t\t\t\t\t\t\t    & FPC_SAME)\n\t\t    {\n\t\t\tif (type != CHECK_PATH\n\t\t\t\t&& action == ACTION_SHOW_ALL\n\t\t\t\t&& files[i].matched)\n\t\t\t{\n\t\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\t\t    if (!got_int)\t    // don't display if 'q'\n\t\t\t\t\t\t    // typed at \"--more--\"\n\t\t\t\t\t\t    // message\n\t\t\t    {\n\t\t\t\tmsg_home_replace_hl(new_fname);\n\t\t\t\tmsg_puts(_(\" (includes previously listed match)\"));\n\t\t\t\tprev_fname = NULL;\n\t\t\t    }\n\t\t\t}\n\t\t\tVIM_CLEAR(new_fname);\n\t\t\talready_searched = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (type == CHECK_PATH && (action == ACTION_SHOW_ALL\n\t\t\t\t || (new_fname == NULL && !already_searched)))\n\t    {\n\t\tif (did_show)\n\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\telse\n\t\t{\n\t\t    gotocmdline(TRUE);\t    // cursor at status line\n\t\t    msg_puts_title(_(\"--- Included files \"));\n\t\t    if (action != ACTION_SHOW_ALL)\n\t\t\tmsg_puts_title(_(\"not found \"));\n\t\t    msg_puts_title(_(\"in path ---\\n\"));\n\t\t}\n\t\tdid_show = TRUE;\n\t\twhile (depth_displayed < depth && !got_int)\n\t\t{\n\t\t    ++depth_displayed;\n\t\t    for (i = 0; i < depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    msg_home_replace(files[depth_displayed].name);\n\t\t    msg_puts(\" -->\\n\");\n\t\t}\n\t\tif (!got_int)\t\t    // don't display if 'q' typed\n\t\t\t\t\t    // for \"--more--\" message\n\t\t{\n\t\t    for (i = 0; i <= depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    if (new_fname != NULL)\n\t\t    {\n\t\t\t// using \"new_fname\" is more reliable, e.g., when\n\t\t\t// 'includeexpr' is set.\n\t\t\tmsg_outtrans_attr(new_fname, HL_ATTR(HLF_D));\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/*\n\t\t\t * Isolate the file name.\n\t\t\t * Include the surrounding \"\" or <> if present.\n\t\t\t */\n\t\t\tif (inc_opt != NULL\n\t\t\t\t   && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t\t{\n\t\t\t    // pattern contains \\zs, use the match\n\t\t\t    p = incl_regmatch.startp[0];\n\t\t\t    i = (int)(incl_regmatch.endp[0]\n\t\t\t\t\t\t   - incl_regmatch.startp[0]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // find the file name after the end of the match\n\t\t\t    for (p = incl_regmatch.endp[0];\n\t\t\t\t\t\t  *p && !vim_isfilec(*p); p++)\n\t\t\t\t;\n\t\t\t    for (i = 0; vim_isfilec(p[i]); i++)\n\t\t\t\t;\n\t\t\t}\n\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t    // Nothing found, use the rest of the line.\n\t\t\t    p = incl_regmatch.endp[0];\n\t\t\t    i = (int)STRLEN(p);\n\t\t\t}\n\t\t\t// Avoid checking before the start of the line, can\n\t\t\t// happen if \\zs appears in the regexp.\n\t\t\telse if (p > line)\n\t\t\t{\n\t\t\t    if (p[-1] == '\"' || p[-1] == '<')\n\t\t\t    {\n\t\t\t\t--p;\n\t\t\t\t++i;\n\t\t\t    }\n\t\t\t    if (p[i] == '\"' || p[i] == '>')\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tsave_char = p[i];\n\t\t\tp[i] = NUL;\n\t\t\tmsg_outtrans_attr(p, HL_ATTR(HLF_D));\n\t\t\tp[i] = save_char;\n\t\t    }\n\n\t\t    if (new_fname == NULL && action == ACTION_SHOW_ALL)\n\t\t    {\n\t\t\tif (already_searched)\n\t\t\t    msg_puts(_(\"  (Already listed)\"));\n\t\t\telse\n\t\t\t    msg_puts(_(\"  NOT FOUND\"));\n\t\t    }\n\t\t}\n\t\tout_flush();\t    // output each line directly\n\t    }\n\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Push the new file onto the file stack\n\t\tif (depth + 1 == old_files)\n\t\t{\n\t\t    bigger = ALLOC_MULT(SearchedFile, max_path_depth * 2);\n\t\t    if (bigger != NULL)\n\t\t    {\n\t\t\tfor (i = 0; i <= depth; i++)\n\t\t\t    bigger[i] = files[i];\n\t\t\tfor (i = depth + 1; i < old_files + max_path_depth; i++)\n\t\t\t{\n\t\t\t    bigger[i].fp = NULL;\n\t\t\t    bigger[i].name = NULL;\n\t\t\t    bigger[i].lnum = 0;\n\t\t\t    bigger[i].matched = FALSE;\n\t\t\t}\n\t\t\tfor (i = old_files; i < max_path_depth; i++)\n\t\t\t    bigger[i + max_path_depth] = files[i];\n\t\t\told_files += max_path_depth;\n\t\t\tmax_path_depth *= 2;\n\t\t\tvim_free(files);\n\t\t\tfiles = bigger;\n\t\t    }\n\t\t}\n\t\tif ((files[depth + 1].fp = mch_fopen((char *)new_fname, \"r\"))\n\t\t\t\t\t\t\t\t    == NULL)\n\t\t    vim_free(new_fname);\n\t\telse\n\t\t{\n\t\t    if (++depth == old_files)\n\t\t    {\n\t\t\t/*\n\t\t\t * lalloc() for 'bigger' must have failed above.  We\n\t\t\t * will forget one of our already visited files now.\n\t\t\t */\n\t\t\tvim_free(files[old_files].name);\n\t\t\t++old_files;\n\t\t    }\n\t\t    files[depth].name = curr_fname = new_fname;\n\t\t    files[depth].lnum = 0;\n\t\t    files[depth].matched = FALSE;\n\t\t    if (action == ACTION_EXPAND)\n\t\t    {\n\t\t\tmsg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\t\t\tvim_snprintf((char*)IObuff, IOSIZE,\n\t\t\t\t_(\"Scanning included file: %s\"),\n\t\t\t\t(char *)new_fname);\n\t\t\tmsg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n\t\t    }\n\t\t    else if (p_verbose >= 5)\n\t\t    {\n\t\t\tverbose_enter();\n\t\t\tsmsg(_(\"Searching included file %s\"),\n\t\t\t\t\t\t\t   (char *)new_fname);\n\t\t\tverbose_leave();\n\t\t    }\n\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Check if the line is a define (type == FIND_DEFINE)\n\t     */\n\t    p = line;\nsearch_line:\n\t    define_matched = FALSE;\n\t    if (def_regmatch.regprog != NULL\n\t\t\t      && vim_regexec(&def_regmatch, line, (colnr_T)0))\n\t    {\n\t\t/*\n\t\t * Pattern must be first identifier after 'define', so skip\n\t\t * to that position before checking for match of pattern.  Also\n\t\t * don't let it match beyond the end of this identifier.\n\t\t */\n\t\tp = def_regmatch.endp[0];\n\t\twhile (*p && !vim_iswordc(*p))\n\t\t    p++;\n\t\tdefine_matched = TRUE;\n\t    }\n\n\t    /*\n\t     * Look for a match.  Don't do this if we are looking for a\n\t     * define and this line didn't match define_prog above.\n\t     */\n\t    if (def_regmatch.regprog == NULL || define_matched)\n\t    {\n\t\tif (define_matched || compl_status_sol())\n\t\t{\n\t\t    // compare the first \"len\" chars from \"ptr\"\n\t\t    startp = skipwhite(p);\n\t\t    if (p_ic)\n\t\t\tmatched = !MB_STRNICMP(startp, ptr, len);\n\t\t    else\n\t\t\tmatched = !STRNCMP(startp, ptr, len);\n\t\t    if (matched && define_matched && whole\n\t\t\t\t\t\t  && vim_iswordc(startp[len]))\n\t\t\tmatched = FALSE;\n\t\t}\n\t\telse if (regmatch.regprog != NULL\n\t\t\t && vim_regexec(&regmatch, line, (colnr_T)(p - line)))\n\t\t{\n\t\t    matched = TRUE;\n\t\t    startp = regmatch.startp[0];\n\t\t    /*\n\t\t     * Check if the line is not a comment line (unless we are\n\t\t     * looking for a define).  A line starting with \"# define\"\n\t\t     * is not considered to be a comment line.\n\t\t     */\n\t\t    if (!define_matched && skip_comments)\n\t\t    {\n\t\t\tif ((*line != '#' ||\n\t\t\t\tSTRNCMP(skipwhite(line + 1), \"define\", 6) != 0)\n\t\t\t\t&& get_leader_len(line, NULL, FALSE, TRUE))\n\t\t\t    matched = FALSE;\n\n\t\t\t/*\n\t\t\t * Also check for a \"/ *\" or \"/ /\" before the match.\n\t\t\t * Skips lines like \"int backwards;  / * normal index\n\t\t\t * * /\" when looking for \"normal\".\n\t\t\t * Note: Doesn't skip \"/ *\" in comments.\n\t\t\t */\n\t\t\tp = skipwhite(line);\n\t\t\tif (matched\n\t\t\t\t|| (p[0] == '/' && p[1] == '*') || p[0] == '*')\n\t\t\t    for (p = line; *p && p < startp; ++p)\n\t\t\t    {\n\t\t\t\tif (matched\n\t\t\t\t\t&& p[0] == '/'\n\t\t\t\t\t&& (p[1] == '*' || p[1] == '/'))\n\t\t\t\t{\n\t\t\t\t    matched = FALSE;\n\t\t\t\t    // After \"//\" all text is comment\n\t\t\t\t    if (p[1] == '/')\n\t\t\t\t\tbreak;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t\telse if (!matched && p[0] == '*' && p[1] == '/')\n\t\t\t\t{\n\t\t\t\t    // Can find match after \"* /\".\n\t\t\t\t    matched = TRUE;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t    }\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (matched)\n\t{\n\t    if (action == ACTION_EXPAND)\n\t    {\n\t\tint\tcont_s_ipos = FALSE;\n\t\tint\tadd_r;\n\t\tchar_u\t*aux;\n\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum)\n\t\t    break;\n\t\tfound = TRUE;\n\t\taux = p = startp;\n\t\tif (compl_status_adding())\n\t\t{\n\t\t    p += ins_compl_len();\n\t\t    if (vim_iswordp(p))\n\t\t\tgoto exit_matched;\n\t\t    p = find_word_start(p);\n\t\t}\n\t\tp = find_word_end(p);\n\t\ti = (int)(p - aux);\n\n\t\tif (compl_status_adding() && i == ins_compl_len())\n\t\t{\n\t\t    // IOSIZE > compl_length, so the STRNCPY works\n\t\t    STRNCPY(IObuff, aux, i);\n\n\t\t    // Get the next line: when \"depth\" < 0  from the current\n\t\t    // buffer, otherwise from the included file.  Jump to\n\t\t    // exit_matched when past the last line.\n\t\t    if (depth < 0)\n\t\t    {\n\t\t\tif (lnum >= end_lnum)\n\t\t\t    goto exit_matched;\n\t\t\tline = ml_get(++lnum);\n\t\t    }\n\t\t    else if (vim_fgets(line = file_line,\n\t\t\t\t\t\t      LSIZE, files[depth].fp))\n\t\t\tgoto exit_matched;\n\n\t\t    // we read a line, set \"already\" to check this \"line\" later\n\t\t    // if depth >= 0 we'll increase files[depth].lnum far\n\t\t    // below  -- Acevedo\n\t\t    already = aux = p = skipwhite(line);\n\t\t    p = find_word_start(p);\n\t\t    p = find_word_end(p);\n\t\t    if (p > aux)\n\t\t    {\n\t\t\tif (*aux != ')' && IObuff[i-1] != TAB)\n\t\t\t{\n\t\t\t    if (IObuff[i-1] != ' ')\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t    // IObuf =~ \"\\(\\k\\|\\i\\).* \", thus i >= 2\n\t\t\t    if (p_js\n\t\t\t\t&& (IObuff[i-2] == '.'\n\t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL\n\t\t\t\t\t&& (IObuff[i-2] == '?'\n\t\t\t\t\t    || IObuff[i-2] == '!'))))\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t}\n\t\t\t// copy as much as possible of the new word\n\t\t\tif (p - aux >= IOSIZE - i)\n\t\t\t    p = aux + IOSIZE - i - 1;\n\t\t\tSTRNCPY(IObuff + i, aux, p - aux);\n\t\t\ti += (int)(p - aux);\n\t\t\tcont_s_ipos = TRUE;\n\t\t    }\n\t\t    IObuff[i] = NUL;\n\t\t    aux = IObuff;\n\n\t\t    if (i == ins_compl_len())\n\t\t\tgoto exit_matched;\n\t\t}\n\n\t\tadd_r = ins_compl_add_infercase(aux, i, p_ic,\n\t\t\tcurr_fname == curbuf->b_fname ? NULL : curr_fname,\n\t\t\tdir, cont_s_ipos);\n\t\tif (add_r == OK)\n\t\t    // if dir was BACKWARD then honor it just once\n\t\t    dir = FORWARD;\n\t\telse if (add_r == FAIL)\n\t\t    break;\n\t    }\n\t    else if (action == ACTION_SHOW_ALL)\n\t    {\n\t\tfound = TRUE;\n\t\tif (!did_show)\n\t\t    gotocmdline(TRUE);\t\t// cursor at status line\n\t\tif (curr_fname != prev_fname)\n\t\t{\n\t\t    if (did_show)\n\t\t\tmsg_putchar('\\n');\t// cursor below last one\n\t\t    if (!got_int)\t\t// don't display if 'q' typed\n\t\t\t\t\t\t// at \"--more--\" message\n\t\t\tmsg_home_replace_hl(curr_fname);\n\t\t    prev_fname = curr_fname;\n\t\t}\n\t\tdid_show = TRUE;\n\t\tif (!got_int)\n\t\t    show_pat_in_path(line, type, TRUE, action,\n\t\t\t    (depth == -1) ? NULL : files[depth].fp,\n\t\t\t    (depth == -1) ? &lnum : &files[depth].lnum,\n\t\t\t    match_count++);\n\n\t\t// Set matched flag for this file and all the ones that\n\t\t// include it\n\t\tfor (i = 0; i <= depth; ++i)\n\t\t    files[i].matched = TRUE;\n\t    }\n\t    else if (--count <= 0)\n\t    {\n\t\tfound = TRUE;\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum\n#if defined(FEAT_QUICKFIX)\n\t\t\t\t\t\t      && g_do_tagpreview == 0\n#endif\n\t\t\t\t\t\t      )\n\t\t    emsg(_(e_match_is_on_current_line));\n\t\telse if (action == ACTION_SHOW)\n\t\t{\n\t\t    show_pat_in_path(line, type, did_show, action,\n\t\t\t(depth == -1) ? NULL : files[depth].fp,\n\t\t\t(depth == -1) ? &lnum : &files[depth].lnum, 1L);\n\t\t    did_show = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n#if defined(FEAT_QUICKFIX)\n\t\t    // \":psearch\" uses the preview window\n\t\t    if (g_do_tagpreview != 0)\n\t\t    {\n\t\t\tcurwin_save = curwin;\n\t\t\tprepare_tagpreview(TRUE, TRUE, FALSE);\n\t\t    }\n#endif\n\t\t    if (action == ACTION_SPLIT)\n\t\t    {\n\t\t\tif (win_split(0, 0) == FAIL)\n\t\t\t    break;\n\t\t\tRESET_BINDING(curwin);\n\t\t    }\n\t\t    if (depth == -1)\n\t\t    {\n\t\t\t// match in current file\n#if defined(FEAT_QUICKFIX)\n\t\t\tif (g_do_tagpreview != 0)\n\t\t\t{\n\t\t\t    if (!win_valid(curwin_save))\n\t\t\t\tbreak;\n\t\t\t    if (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t   curwin_save->w_buffer->b_fnum, NULL,\n\t\t\t\t\t\t     NULL, TRUE, lnum, FALSE)))\n\t\t\t\tbreak;\t// failed to jump to file\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    setpcmark();\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tcheck_cursor();\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t0, files[depth].name, NULL, TRUE,\n\t\t\t\t\t\t    files[depth].lnum, FALSE)))\n\t\t\t    break;\t// failed to jump to file\n\t\t\t// autocommands may have changed the lnum, we don't\n\t\t\t// want that here\n\t\t\tcurwin->w_cursor.lnum = files[depth].lnum;\n\t\t    }\n\t\t}\n\t\tif (action != ACTION_SHOW)\n\t\t{\n\t\t    curwin->w_cursor.col = (colnr_T)(startp - line);\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t}\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0\n\t\t\t   && curwin != curwin_save && win_valid(curwin_save))\n\t\t{\n\t\t    // Return cursor to where we were\n\t\t    validate_cursor();\n\t\t    redraw_later(VALID);\n\t\t    win_enter(curwin_save, TRUE);\n\t\t}\n# ifdef FEAT_PROP_POPUP\n\t\telse if (WIN_IS_POPUP(curwin))\n\t\t    // can't keep focus in popup window\n\t\t    win_enter(firstwin, TRUE);\n# endif\n#endif\n\t\tbreak;\n\t    }\nexit_matched:\n\t    matched = FALSE;\n\t    // look for other matches in the rest of the line if we\n\t    // are not at the end of it already\n\t    if (def_regmatch.regprog == NULL\n\t\t    && action == ACTION_EXPAND\n\t\t    && !compl_status_sol()\n\t\t    && *startp != NUL\n\t\t    && *(p = startp + mb_ptr2len(startp)) != NUL)\n\t\tgoto search_line;\n\t}\n\tline_breakcheck();\n\tif (action == ACTION_EXPAND)\n\t    ins_compl_check_keys(30, FALSE);\n\tif (got_int || ins_compl_interrupted())\n\t    break;\n\n\t/*\n\t * Read the next line.  When reading an included file and encountering\n\t * end-of-file, close the file and continue in the file that included\n\t * it.\n\t */\n\twhile (depth >= 0 && !already\n\t\t&& vim_fgets(line = file_line, LSIZE, files[depth].fp))\n\t{\n\t    fclose(files[depth].fp);\n\t    --old_files;\n\t    files[old_files].name = files[depth].name;\n\t    files[old_files].matched = files[depth].matched;\n\t    --depth;\n\t    curr_fname = (depth == -1) ? curbuf->b_fname\n\t\t\t\t       : files[depth].name;\n\t    if (depth < depth_displayed)\n\t\tdepth_displayed = depth;\n\t}\n\tif (depth >= 0)\t\t// we could read the line\n\t{\n\t    files[depth].lnum++;\n\t    // Remove any CR and LF from the line.\n\t    i = (int)STRLEN(line);\n\t    if (i > 0 && line[i - 1] == '\\n')\n\t\tline[--i] = NUL;\n\t    if (i > 0 && line[i - 1] == '\\r')\n\t\tline[--i] = NUL;\n\t}\n\telse if (!already)\n\t{\n\t    if (++lnum > end_lnum)\n\t\tbreak;\n\t    line = ml_get(lnum);\n\t}\n\talready = NULL;\n    }\n    // End of big for (;;) loop.\n\n    // Close any files that are still open.\n    for (i = 0; i <= depth; i++)\n    {\n\tfclose(files[i].fp);\n\tvim_free(files[i].name);\n    }\n    for (i = old_files; i < max_path_depth; i++)\n\tvim_free(files[i].name);\n    vim_free(files);\n\n    if (type == CHECK_PATH)\n    {\n\tif (!did_show)\n\t{\n\t    if (action != ACTION_SHOW_ALL)\n\t\tmsg(_(\"All included files were found\"));\n\t    else\n\t\tmsg(_(\"No included files\"));\n\t}\n    }\n    else if (!found && action != ACTION_EXPAND)\n    {\n\tif (got_int || ins_compl_interrupted())\n\t    emsg(_(e_interrupted));\n\telse if (type == FIND_DEFINE)\n\t    emsg(_(e_couldnt_find_definition));\n\telse\n\t    emsg(_(e_couldnt_find_pattern));\n    }\n    if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)\n\tmsg_end();\n\nfpip_end:\n    vim_free(file_line);\n    vim_regfree(regmatch.regprog);\n    vim_regfree(incl_regmatch.regprog);\n    vim_regfree(def_regmatch.regprog);\n}", "func_hash": 123923862521809134964983633516065480238, "file_name": "search.c", "file_hash": 229512534202460810065416633781657256150, "cwe": ["CWE-416"], "cve": "CVE-2022-1968", "cve_desc": "Use After Free in GitHub repository vim/vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1968"}
{"idx": 219961, "project": "glewlwyd", "commit_id": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "project_url": "https://github.com/babelouest/glewlwyd", "commit_url": "https://github.com/babelouest/glewlwyd/commit/125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "commit_message": "Fix update session when auth fail", "target": 0, "func": "int callback_404_if_necessary (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  UNUSED(user_data);\n  if (!request->callback_position) {\n    response->status = 404;\n  }\n  return U_CALLBACK_COMPLETE;\n}", "func_hash": 228079793893643089117449138501797677358, "file_name": "webservice.c", "file_hash": 287798817606377336444620654835011177393, "cwe": ["CWE-287"], "cve": "CVE-2021-45379", "cve_desc": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-45379"}
{"idx": 216949, "project": "server", "commit_id": "5ba77222e9fe7af8ff403816b5338b18b342053c", "project_url": "https://github.com/MariaDB/server", "commit_url": "https://github.com/MariaDB/server/commit/5ba77222e9fe7af8ff403816b5338b18b342053c", "commit_message": "MDEV-21028 Server crashes in Query_arena::set_query_arena upon SELECT from view\n\nif the view has algorithm=temptable it is not updatable,\nso DEFAULT() for its fields is meaningless,\nand thus it's NULL or 0/'' for NOT NULL columns.", "target": 1, "func": "Field *create_tmp_field_from_field(THD *thd, Field *org_field,\n                                   const char *name, TABLE *table,\n                                   Item_field *item)\n{\n  Field *new_field;\n\n  new_field= org_field->make_new_field(thd->mem_root, table,\n                                       table == org_field->table);\n  if (new_field)\n  {\n    new_field->init(table);\n    new_field->orig_table= org_field->orig_table;\n    if (item)\n      item->result_field= new_field;\n    else\n      new_field->field_name= name;\n    new_field->flags|= (org_field->flags & NO_DEFAULT_VALUE_FLAG);\n    if (org_field->maybe_null() || (item && item->maybe_null))\n      new_field->flags&= ~NOT_NULL_FLAG;\t// Because of outer join\n    if (org_field->type() == MYSQL_TYPE_VAR_STRING ||\n        org_field->type() == MYSQL_TYPE_VARCHAR)\n      table->s->db_create_options|= HA_OPTION_PACK_RECORD;\n    else if (org_field->type() == FIELD_TYPE_DOUBLE)\n      ((Field_double *) new_field)->not_fixed= TRUE;\n    new_field->vcol_info= 0;\n    new_field->cond_selectivity= 1.0;\n    new_field->next_equal_field= NULL;\n    new_field->option_list= NULL;\n    new_field->option_struct= NULL;\n  }\n  return new_field;\n}", "func_hash": 75060030531434597775371308590962756715, "file_name": "None", "file_hash": null, "cwe": ["CWE-89"], "cve": "CVE-2022-27386", "cve_desc": "MariaDB Server v10.7 and below was discovered to contain a segmentation fault via the component sql/sql_class.cc.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-27386"}
{"idx": 220815, "project": "tensorflow", "commit_id": "8c6f391a2282684a25cbfec7687bd5d35261a209", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/8c6f391a2282684a25cbfec7687bd5d35261a209", "commit_message": "[lite] Add check for bias_size is zero to avoid division by zero. This shouldn't happen for properly converted models. Just safety check\n\nPiperOrigin-RevId: 416383645\nChange-Id: If8e508bf696ae8ecfb927e69c139a8ccf7fe60cb", "target": 0, "func": "constexpr int lut_size() {\n  static_assert(std::is_same<LutInT, int8_t>::value ||\n                    std::is_same<LutInT, int16_t>::value,\n                \"Only LUTs with int8 or int16 inputs are supported.\");\n  return std::is_same<LutInT, int8_t>::value ? 256 : 513;\n}", "func_hash": 241548465335031173229306051114259284502, "file_name": "common.h", "file_hash": 206010119069068373550820723284960883967, "cwe": ["CWE-369"], "cve": "CVE-2022-23557", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would trigger a division by zero in `BiasAndClamp` implementation. There is no check that the `bias_size` is non zero. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23557"}
{"idx": 212688, "project": "linux", "commit_id": "d5bb334a8e171b262e48f378bd2096c0ea458265", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d5bb334a8e171b262e48f378bd2096c0ea458265", "commit_message": "Bluetooth: Align minimum encryption key size for LE and BR/EDR connections\n\nThe minimum encryption key size for LE connections is 56 bits and to\nalign LE with BR/EDR, enforce 56 bits of minimum encryption key size for\nBR/EDR connections as well.\n\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>\nSigned-off-by: Johan Hedberg <johan.hedberg@intel.com>\nCc: stable@vger.kernel.org", "target": 1, "func": "int hci_conn_check_link_mode(struct hci_conn *conn)\n{\n\tBT_DBG(\"hcon %p\", conn);\n\n\t/* In Secure Connections Only mode, it is required that Secure\n\t * Connections is used and the link is encrypted with AES-CCM\n\t * using a P-256 authenticated combination key.\n\t */\n\tif (hci_dev_test_flag(conn->hdev, HCI_SC_ONLY)) {\n\t\tif (!hci_conn_sc_enabled(conn) ||\n\t\t    !test_bit(HCI_CONN_AES_CCM, &conn->flags) ||\n\t\t    conn->key_type != HCI_LK_AUTH_COMBINATION_P256)\n\t\t\treturn 0;\n\t}\n\n\tif (hci_conn_ssp_enabled(conn) &&\n\t    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))\n\t\treturn 0;\n\n\treturn 1;\n}", "func_hash": 183603807446933705900061551904731609798, "file_name": "hci_conn.c", "file_hash": 287060261318003868124392211429031377199, "cwe": ["CWE-327"], "cve": "CVE-2019-9506", "cve_desc": "The Bluetooth BR/EDR specification up to and including version 5.1 permits sufficiently low encryption key length and does not prevent an attacker from influencing the key length negotiation. This allows practical brute-force attacks (aka \"KNOB\") that can decrypt traffic and inject arbitrary ciphertext without the victim noticing.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-9506"}
{"idx": 221130, "project": "gpac", "commit_id": "a69b567b8c95c72f9560c873c5ab348be058f340", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340", "commit_message": "fixed #1895", "target": 0, "func": "GF_Err gf_odf_ac3_config_parse(u8 *dsi, u32 dsi_len, Bool is_ec3, GF_AC3Config *cfg)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tif (!cfg || !dsi) return GF_BAD_PARAM;\n\tbs = gf_bs_new(dsi, dsi_len, GF_BITSTREAM_READ);\n\te = gf_odf_ac3_config_parse_bs(bs, is_ec3, cfg);\n\tgf_bs_del(bs);\n\treturn e;\n}", "func_hash": 128135411382207720911084877738167234309, "file_name": "descriptors.c", "file_hash": 86476492964393375980272696403064975409, "cwe": ["CWE-415"], "cve": "CVE-2021-40571", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40571"}
{"idx": 199834, "project": "vim", "commit_id": "f12129f1714f7d2301935bb21d896609bdac221c", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/f12129f1714f7d2301935bb21d896609bdac221c", "commit_message": "patch 9.0.0020: with some completion reading past end of string\n\nProblem:    With some completion reading past end of string.\nSolution:   Check the length of the string.", "target": 1, "func": "ins_compl_stop(int c, int prev_mode, int retval)\n{\n    char_u\t*ptr;\n    int\t\twant_cindent;\n\n    // Get here when we have finished typing a sequence of ^N and\n    // ^P or other completion characters in CTRL-X mode.  Free up\n    // memory that was used, and make sure we can redo the insert.\n    if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E)\n    {\n\t// If any of the original typed text has been changed, eg when\n\t// ignorecase is set, we must add back-spaces to the redo\n\t// buffer.  We add as few as necessary to delete just the part\n\t// of the original text that has changed.\n\t// When using the longest match, edited the match or used\n\t// CTRL-E then don't use the current match.\n\tif (compl_curr_match != NULL && compl_used_match && c != Ctrl_E)\n\t    ptr = compl_curr_match->cp_str;\n\telse\n\t    ptr = NULL;\n\tins_compl_fixRedoBufForLeader(ptr);\n    }\n\n    want_cindent = (get_can_cindent() && cindent_on());\n\n    // When completing whole lines: fix indent for 'cindent'.\n    // Otherwise, break line if it's too long.\n    if (compl_cont_mode == CTRL_X_WHOLE_LINE)\n    {\n\t// re-indent the current line\n\tif (want_cindent)\n\t{\n\t    do_c_expr_indent();\n\t    want_cindent = FALSE;\t// don't do it again\n\t}\n    }\n    else\n    {\n\tint prev_col = curwin->w_cursor.col;\n\n\t// put the cursor on the last char, for 'tw' formatting\n\tif (prev_col > 0)\n\t    dec_cursor();\n\t// only format when something was inserted\n\tif (!arrow_used && !ins_need_undo_get() && c != Ctrl_E)\n\t    insertchar(NUL, 0, -1);\n\tif (prev_col > 0\n\t\t&& ml_get_curline()[curwin->w_cursor.col] != NUL)\n\t    inc_cursor();\n    }\n\n    // If the popup menu is displayed pressing CTRL-Y means accepting\n    // the selection without inserting anything.  When\n    // compl_enter_selects is set the Enter key does the same.\n    if ((c == Ctrl_Y || (compl_enter_selects\n\t\t    && (c == CAR || c == K_KENTER || c == NL)))\n\t    && pum_visible())\n\tretval = TRUE;\n\n    // CTRL-E means completion is Ended, go back to the typed text.\n    // but only do this, if the Popup is still visible\n    if (c == Ctrl_E)\n    {\n\tins_compl_delete();\n\tif (compl_leader != NULL)\n\t    ins_bytes(compl_leader + get_compl_len());\n\telse if (compl_first_match != NULL)\n\t    ins_bytes(compl_orig_text + get_compl_len());\n\tretval = TRUE;\n    }\n\n    auto_format(FALSE, TRUE);\n\n    // Trigger the CompleteDonePre event to give scripts a chance to\n    // act upon the completion before clearing the info, and restore\n    // ctrl_x_mode, so that complete_info() can be used.\n    ctrl_x_mode = prev_mode;\n    ins_apply_autocmds(EVENT_COMPLETEDONEPRE);\n\n    ins_compl_free();\n    compl_started = FALSE;\n    compl_matches = 0;\n    if (!shortmess(SHM_COMPLETIONMENU))\n\tmsg_clr_cmdline();\t// necessary for \"noshowmode\"\n    ctrl_x_mode = CTRL_X_NORMAL;\n    compl_enter_selects = FALSE;\n    if (edit_submode != NULL)\n    {\n\tedit_submode = NULL;\n\tshowmode();\n    }\n\n#ifdef FEAT_CMDWIN\n    if (c == Ctrl_C && cmdwin_type != 0)\n\t// Avoid the popup menu remains displayed when leaving the\n\t// command line window.\n\tupdate_screen(0);\n#endif\n    // Indent now if a key was typed that is in 'cinkeys'.\n    if (want_cindent && in_cinkeys(KEY_COMPLETE, ' ', inindent(0)))\n\tdo_c_expr_indent();\n    // Trigger the CompleteDone event to give scripts a chance to act\n    // upon the end of completion.\n    ins_apply_autocmds(EVENT_COMPLETEDONE);\n\n    return retval;\n}", "func_hash": 319633245097677404453951244574334910213, "file_name": "insexpand.c", "file_hash": 292997256287164132386360145530649653298, "cwe": ["CWE-125"], "cve": "CVE-2022-2286", "cve_desc": "Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-2286"}
