{"idx": 220163, "project": "tensorflow", "commit_id": "ab51e5b813573dc9f51efa335aebcf2994125ee9", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/ab51e5b813573dc9f51efa335aebcf2994125ee9", "commit_message": "Prevent memory leak in decoding PNG images.\n\nPiperOrigin-RevId: 409300653\nChange-Id: I6182124c545989cef80cefd439b659095920763b", "target": 0, "func": "void DecodeImageV2Op::DecodeBMP(const uint8* input, const int row_size,\n                                uint8* const output, const int width,\n                                const int height, const int output_channels,\n                                const int input_channels, bool top_down) {\n  for (int i = 0; i < height; i++) {\n    int src_pos;\n    int dst_pos;\n\n    for (int j = 0; j < width; j++) {\n      if (!top_down) {\n        src_pos = ((height - 1 - i) * row_size) + j * input_channels;\n      } else {\n        src_pos = i * row_size + j * input_channels;\n      }\n\n      dst_pos = (i * width + j) * output_channels;\n\n      switch (input_channels) {\n        case 1:\n          output[dst_pos] = input[src_pos];\n          // Set 2nd and 3rd channels if user requested for 3 or 4 channels.\n          // Repeat 1st channel's value.\n          if (output_channels == 3 || output_channels == 4) {\n            output[dst_pos + 1] = input[src_pos];\n            output[dst_pos + 2] = input[src_pos];\n          }\n          // Set 4th channel (alpha) to maximum value if user requested for\n          // 4 channels.\n          if (output_channels == 4) {\n            output[dst_pos + 3] = UINT8_MAX;\n          }\n          break;\n        case 3:\n          // BGR -> RGB\n          output[dst_pos] = input[src_pos + 2];\n          output[dst_pos + 1] = input[src_pos + 1];\n          output[dst_pos + 2] = input[src_pos];\n          // Set 4th channel (alpha) to maximum value if the user requested for\n          // 4 channels and the input image has 3 channels only.\n          if (output_channels == 4) {\n            output[dst_pos + 3] = UINT8_MAX;\n          }\n          break;\n        case 4:\n          // BGRA -> RGBA\n          output[dst_pos] = input[src_pos + 2];\n          output[dst_pos + 1] = input[src_pos + 1];\n          output[dst_pos + 2] = input[src_pos];\n          // Set 4th channel only if the user requested for 4 channels. If not,\n          // then user requested 3 channels; skip this step.\n          if (output_channels == 4) {\n            output[dst_pos + 3] = input[src_pos + 3];\n          }\n          break;\n        default:\n          LOG(FATAL) << \"Unexpected number of channels: \" << input_channels;\n          break;\n      }\n    }\n  }\n}", "func_hash": 309175657452815640759126829221529246538, "file_name": "decode_image_op.cc", "file_hash": 250371192243587827698671199962137663449, "cwe": ["CWE-401"], "cve": "CVE-2022-23585", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. When decoding PNG images TensorFlow can produce a memory leak if the image is invalid. After calling `png::CommonInitDecode(..., &decode)`, the `decode` value contains allocated buffers which can only be freed by calling `png::CommonFreeDecode(&decode)`. However, several error case in the function implementation invoke the `OP_REQUIRES` macro which immediately terminates the execution of the function, without allowing for the memory free to occur. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23585"}
{"idx": 210091, "project": "cifs-utils", "commit_id": "48a654e2e763fce24c22e1b9c695b42804bbdd4a", "project_url": "https://github.com/piastry/cifs-utils", "commit_url": "https://git.samba.org/cifs-utils.git/?p=cifs-utils.git;a=commit;h=48a654e2e763fce24c22e1b9c695b42804bbdd4a", "commit_message": "CVE-2020-14342: mount.cifs: fix shell command injection\n\nA bug has been reported recently for the mount.cifs utility which is\npart of the cifs-utils package. The tool has a shell injection issue\nwhere one can embed shell commands via the username mount option. Those\ncommands will be run via popen() in the context of the user calling\nmount.\n\nThe bug requires cifs-utils to be built with --with-systemd (enabled\nby default if supported).\n\nA quick test to check if the mount.cifs binary is vulnerable is to look\nfor popen() calls like so:\n\n    $ nm mount.cifs | grep popen\n    U popen@@GLIBC_2.2.5\n\nIf the user is allowed to run mount.cifs via sudo, he can obtain a root\nshell.\n\n    sudo mount.cifs -o username='`sh`' //1 /mnt\n\nIf mount.cifs has the setuid bit, the command will still be run as the\ncalling user (no privilege escalation).\n\nThe bug was introduced in June 2012 with commit 4e264031d0da7d3f2\n(\"mount.cifs: Use systemd's mechanism for getting password, if\npresent.\").\n\nAffected versions:\n  cifs-utils-5.6\n  cifs-utils-5.7\n  cifs-utils-5.8\n  cifs-utils-5.9\n  cifs-utils-6.0\n  cifs-utils-6.1\n  cifs-utils-6.2\n  cifs-utils-6.3\n  cifs-utils-6.4\n  cifs-utils-6.5\n  cifs-utils-6.6\n  cifs-utils-6.7\n  cifs-utils-6.8\n  cifs-utils-6.9\n  cifs-utils-6.10\n\nBug: https://bugzilla.samba.org/show_bug.cgi?id=14442\nReported-by: Vadim Lebedev <vadim@mbdsys.com>\n\nSigned-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>\nSigned-off-by: Aurelien Aptel <aaptel@suse.com>", "target": 1, "func": "get_password(const char *prompt, char *input, int capacity)\n{\n#ifdef ENABLE_SYSTEMD\n\tint is_systemd_running;\n\tstruct stat a, b;\n\n\t/* We simply test whether the systemd cgroup hierarchy is\n\t * mounted */\n\tis_systemd_running = (lstat(\"/sys/fs/cgroup\", &a) == 0)\n\t\t&& (lstat(\"/sys/fs/cgroup/systemd\", &b) == 0)\n\t\t&& (a.st_dev != b.st_dev);\n\n\tif (is_systemd_running) {\n\t\tchar *cmd, *ret;\n\t\tFILE *ask_pass_fp = NULL;\n\n\t\tcmd = ret = NULL;\n\t\tif (asprintf(&cmd, \"systemd-ask-password \\\"%s\\\"\", prompt) >= 0) {\n\t\t\task_pass_fp = popen (cmd, \"re\");\n\t\t\tfree (cmd);\n\t\t}\n\n\t\tif (ask_pass_fp) {\n\t\t\tret = fgets(input, capacity, ask_pass_fp);\n\t\t\tpclose(ask_pass_fp);\n\t\t}\n\n\t\tif (ret) {\n\t\t\tint len = strlen(input);\n\t\t\tif (input[len - 1] == '\\n')\n\t\t\t\tinput[len - 1] = '\\0';\n\t\t\treturn input;\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * Falling back to getpass(..)\n\t * getpass is obsolete, but there's apparently nothing that replaces it\n\t */\n\tchar *tmp_pass = getpass(prompt);\n\tif (!tmp_pass)\n\t\treturn NULL;\n\n\tstrncpy(input, tmp_pass, capacity - 1);\n\tinput[capacity - 1] = '\\0';\n\n\t/* zero-out the static buffer */\n\tmemset(tmp_pass, 0, strlen(tmp_pass));\n\n\treturn input;\n}", "func_hash": 49726646058997289689007700081936917981, "file_name": "None", "file_hash": null, "cwe": ["CWE-78"], "cve": "CVE-2020-14342", "cve_desc": "It was found that cifs-utils' mount.cifs was invoking a shell when requesting the Samba password, which could be used to inject arbitrary commands. An attacker able to invoke mount.cifs with special permission, such as via sudo rules, could use this flaw to escalate their privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-14342"}
{"idx": 220844, "project": "tensorflow", "commit_id": "8c6f391a2282684a25cbfec7687bd5d35261a209", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/8c6f391a2282684a25cbfec7687bd5d35261a209", "commit_message": "[lite] Add check for bias_size is zero to avoid division by zero. This shouldn't happen for properly converted models. Just safety check\n\nPiperOrigin-RevId: 416383645\nChange-Id: If8e508bf696ae8ecfb927e69c139a8ccf7fe60cb", "target": 0, "func": "inline Integer FloorLog2(Integer n) {\n  static_assert(std::is_integral<Integer>::value, \"\");\n  static_assert(std::is_signed<Integer>::value, \"\");\n  static_assert(sizeof(Integer) == 4 || sizeof(Integer) == 8, \"\");\n  TFLITE_CHECK_GT(n, 0);\n  if (sizeof(Integer) == 4) {\n    return 30 - CountLeadingSignBits(n);\n  } else {\n    return 62 - CountLeadingSignBits(n);\n  }\n}", "func_hash": 104729263019054901487997175501689472206, "file_name": "common.h", "file_hash": 206010119069068373550820723284960883967, "cwe": ["CWE-369"], "cve": "CVE-2022-23557", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would trigger a division by zero in `BiasAndClamp` implementation. There is no check that the `bias_size` is non zero. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23557"}
{"idx": 90143, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual std::string GetHtmlInfo(int refresh) { return std::string(); }\n", "func_hash": 66925089768019925140231724655329202898, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 220227, "project": "tensorflow", "commit_id": "c99d98cd189839dcf51aee94e7437b54b31f8abd", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/c99d98cd189839dcf51aee94e7437b54b31f8abd", "commit_message": "Handle invalid inputs instead of crashing.\n\nPiperOrigin-RevId: 409549744\nChange-Id: I7f5935b34b53f7e426a5462fcc027bdbf5dcda24", "target": 0, "func": "Node* Graph::CopyNode(const Node* node) {\n  DCHECK(!node->IsSource());\n  DCHECK(!node->IsSink());\n  Node* copy = AllocateNode(node->props_, node, node->class_);\n  copy->set_assigned_device_name(node->assigned_device_name());\n\n  // Since the OpDef of a function may be owned by the Graph that owns 'node',\n  // relookup the OpDef in the target graph. If it differs, then clone the\n  // node properties with the updated OpDef.\n  const OpDef* op_def;\n  TF_CHECK_OK(ops_.LookUpOpDef(node->type_string(), &op_def));\n  if (op_def != node->props_->op_def) {\n    copy->MaybeCopyOnWrite();\n    copy->props_->op_def = op_def;\n  }\n  copy->SetStackTrace(node->GetStackTrace());\n\n  return copy;\n}", "func_hash": 149136125650165221576886376883217955787, "file_name": "graph.cc", "file_hash": 172099243927919341591512227523808328051, "cwe": ["CWE-125"], "cve": "CVE-2022-23592", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. TensorFlow's type inference can cause a heap out of bounds read as the bounds checking is done in a `DCHECK` (which is a no-op during production). An attacker can control the `input_idx` variable such that `ix` would be larger than the number of values in `node_t.args`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23592"}
{"idx": 212927, "project": "qemu", "commit_id": "8c92060d3c0248bd4d515719a35922cd2391b9b4", "project_url": "https://github.com/bonzini/qemu", "commit_url": "https://git.qemu.org/?p=qemu.git;a=commit;h=8c92060d3c0248bd4d515719a35922cd2391b9b4", "commit_message": "sungem: switch to use qemu_receive_packet() for loopback\n\nThis patch switches to use qemu_receive_packet() which can detect\nreentrancy and return early.\n\nThis is intended to address CVE-2021-3416.\n\nCc: Prasad J Pandit <ppandit@redhat.com>\nCc: qemu-stable@nongnu.org\nReviewed-by: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nReviewed-by: Philippe Mathieu-Daud\u00e9 <philmd@redhat.com>\nReviewed-by: Alistair Francis <alistair.francis@wdc.com>\nSigned-off-by: Jason Wang <jasowang@redhat.com>", "target": 1, "func": "static void sungem_send_packet(SunGEMState *s, const uint8_t *buf,\n                               int size)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n\n    if (s->macregs[MAC_XIFCFG >> 2] & MAC_XIFCFG_LBCK) {\n        nc->info->receive(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n}", "func_hash": 112948077964204681005351426202657971698, "file_name": "sungem.c", "file_hash": 256783431250079747313896805247705613463, "cwe": ["CWE-835"], "cve": "CVE-2021-3416", "cve_desc": "A potential stack overflow via infinite loop issue was found in various NIC emulators of QEMU in versions up to and including 5.2.0. The issue occurs in loopback mode of a NIC wherein reentrant DMA checks get bypassed. A guest user/process may use this flaw to consume CPU cycles or crash the QEMU process on the host resulting in DoS scenario.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3416"}
{"idx": 219044, "project": "tensorflow", "commit_id": "240655511cd3e701155f944a972db71b6c0b1bb6", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/240655511cd3e701155f944a972db71b6c0b1bb6", "commit_message": "Eliminate `CHECK`-fails from `IsSimplifiableReshape` via `MakeShape(<invalid shape>)`\n\nPiperOrigin-RevId: 409166738\nChange-Id: I7f0a3590b8acae3f3e3e2fe636e1f5ef285693cf", "target": 0, "func": "Status ConstantFolding::SimplifyNode(NodeDef* node, GraphDef* optimized_graph,\n                                     GraphProperties* properties) {\n  bool graph_modified_cached = graph_modified_;\n  graph_modified_ = false;\n\n  bool use_shape_info = properties->has_properties();\n  RETURN_IF_MODIFIED(RemoveSplitOrSplitV(*properties, optimized_graph, node));\n  RETURN_IF_ERROR_OR_MODIFIED(RemoveShuffleOrTranspose(\n      *properties, use_shape_info, optimized_graph, node));\n  RETURN_IF_MODIFIED(\n      RemoveRandomShuffle(*properties, use_shape_info, optimized_graph, node));\n  RETURN_IF_ERROR_OR_MODIFIED(\n      RemoveReverse(*properties, use_shape_info, optimized_graph, node));\n  RETURN_IF_ERROR_OR_MODIFIED(\n      SimplifySlice(*properties, use_shape_info, optimized_graph, node));\n  RETURN_IF_ERROR_OR_MODIFIED(\n      SimplifyStridedSlice(*properties, use_shape_info, optimized_graph, node));\n  RETURN_IF_ERROR_OR_MODIFIED(\n      SimplifyTile(*properties, use_shape_info, optimized_graph, node));\n  RETURN_IF_ERROR_OR_MODIFIED(\n      SimplifyPad(*properties, use_shape_info, optimized_graph, node));\n  RETURN_IF_MODIFIED(\n      SimplifySqueeze(*properties, use_shape_info, optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(SimplifyPack(optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(MoveConstantsPastEnter(optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(SimplifySwitch(optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      SimplifyReduction(optimized_graph, *properties, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      SimplifyReshape(*properties, use_shape_info, node));\n  RETURN_IF_ERROR_OR_MODIFIED(SimplifyArithmeticOperations(\n      *properties, use_shape_info, optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(ReduceDivToReciprocalMul(optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      ConstantPushDown(properties, optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      MulConvPushDown(optimized_graph, node, *properties));\n  SET_AND_RETURN_IF_MODIFIED(PartialConstPropThroughIdentityN(node));\n  SET_AND_RETURN_IF_MODIFIED(\n      PartialAssocOpConstFolding(optimized_graph, properties, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      MergeConcat(use_shape_info, properties, optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      PartialConcatConstFolding(optimized_graph, properties, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      ConstantPushDownBiasAdd(properties, optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(SimplifyCase(optimized_graph, node));\n  SET_AND_RETURN_IF_MODIFIED(\n      SimplifySelect(*properties, optimized_graph, node));\n  RETURN_IF_MODIFIED(\n      RemoveRedundantVariableUpdates(properties, optimized_graph, node));\n\n  graph_modified_ = graph_modified_cached;\n  return Status::OK();\n}", "func_hash": 152365500003103935740051819091631486618, "file_name": "constant_folding.cc", "file_hash": 221573695858123615640237954647315751120, "cwe": ["CWE-617"], "cve": "CVE-2022-23581", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The Grappler optimizer in TensorFlow can be used to cause a denial of service by altering a `SavedModel` such that `IsSimplifiableReshape` would trigger `CHECK` failures. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23581"}
{"idx": 198499, "project": "micro-ecc", "commit_id": "1b5f5cea5145c96dd8791b9b2c41424fc74c2172", "project_url": "https://github.com/kmackay/micro-ecc", "commit_url": "https://github.com/kmackay/micro-ecc/commit/1b5f5cea5145c96dd8791b9b2c41424fc74c2172", "commit_message": "Fix for #168", "target": 1, "func": "static int uECC_sign_with_k(const uint8_t *private_key,\n                            const uint8_t *message_hash,\n                            unsigned hash_size,\n                            uECC_word_t *k,\n                            uint8_t *signature,\n                            uECC_Curve curve) {\n\n    uECC_word_t tmp[uECC_MAX_WORDS];\n    uECC_word_t s[uECC_MAX_WORDS];\n    uECC_word_t *k2[2] = {tmp, s};\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *p = (uECC_word_t *)signature;\n#else\n    uECC_word_t p[uECC_MAX_WORDS * 2];\n#endif\n    uECC_word_t carry;\n    wordcount_t num_words = curve->num_words;\n    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n    bitcount_t num_n_bits = curve->num_n_bits;\n\n    /* Make sure 0 < k < curve_n */\n    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {\n        return 0;\n    }\n\n    carry = regularize_k(k, tmp, s, curve);\n    EccPoint_mult(p, curve->G, k2[!carry], 0, num_n_bits + 1, curve);\n    if (uECC_vli_isZero(p, num_words)) {\n        return 0;\n    }\n\n    /* If an RNG function was specified, get a random number\n       to prevent side channel analysis of k. */\n    if (!g_rng_function) {\n        uECC_vli_clear(tmp, num_n_words);\n        tmp[0] = 1;\n    } else if (!uECC_generate_random_int(tmp, curve->n, num_n_words)) {\n        return 0;\n    }\n\n    /* Prevent side channel analysis of uECC_vli_modInv() to determine\n       bits of k / the private key by premultiplying by a random number */\n    uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k' = rand * k */\n    uECC_vli_modInv(k, k, curve->n, num_n_words);       /* k = 1 / k' */\n    uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k = 1 / k */\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n    uECC_vli_nativeToBytes(signature, curve->num_bytes, p); /* store r */\n#endif\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) tmp, private_key, BITS_TO_BYTES(curve->num_n_bits));\n#else\n    uECC_vli_bytesToNative(tmp, private_key, BITS_TO_BYTES(curve->num_n_bits)); /* tmp = d */\n#endif\n\n    s[num_n_words - 1] = 0;\n    uECC_vli_set(s, p, num_words);\n    uECC_vli_modMult(s, tmp, s, curve->n, num_n_words); /* s = r*d */\n\n    bits2int(tmp, message_hash, hash_size, curve);\n    uECC_vli_modAdd(s, tmp, s, curve->n, num_n_words); /* s = e + r*d */\n    uECC_vli_modMult(s, s, k, curve->n, num_n_words);  /* s = (e + r*d) / k */\n    if (uECC_vli_numBits(s, num_n_words) > (bitcount_t)curve->num_bytes * 8) {\n        return 0;\n    }\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) signature + curve->num_bytes, (uint8_t *) s, curve->num_bytes);\n#else\n    uECC_vli_nativeToBytes(signature + curve->num_bytes, curve->num_bytes, s);\n#endif    \n    return 1;\n}", "func_hash": 250707445511654521220716932779019293116, "file_name": "uECC.c", "file_hash": 221730154760089899908262595980065132519, "cwe": ["CWE-415"], "cve": "CVE-2020-27209", "cve_desc": "The ECDSA operation of the micro-ecc library 1.0 is vulnerable to simple power analysis attacks which allows an adversary to extract the private ECC key.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-27209"}
{"idx": 177173, "project": "Chrome", "commit_id": "2bfb2b8299e2fb6a432390a93a99a85fed1d29c9", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/2bfb2b8299e2fb6a432390a93a99a85fed1d29c9", "commit_message": "None", "target": 0, "func": "Vector<WebPageProxy*> WebProcessProxy::pages() const\n{\n    Vector<WebPageProxy*> result;\n    copyValuesToVector(m_pageMap, result);\n    return result;\n}\n", "func_hash": 38082877908503068527589053296721164577, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 218760, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "MagickExport void XFontBrowserWidget(Display *display,XWindows *windows,\n  const char *action,char *reply)\n{\n#define BackButtonText  \"Back\"\n#define CancelButtonText  \"Cancel\"\n#define FontnameText  \"Name:\"\n#define FontPatternText  \"Pattern:\"\n#define ResetButtonText  \"Reset\"\n\n  char\n    back_pattern[MaxTextExtent],\n    **fontlist,\n    **listhead,\n    primary_selection[MaxTextExtent],\n    reset_pattern[MaxTextExtent],\n    text[MaxTextExtent];\n\n  int\n    fonts,\n    x,\n    y;\n\n  int\n    i;\n\n  static char\n    glob_pattern[MaxTextExtent] = \"*\";\n\n  static MagickStatusType\n    mask = (MagickStatusType) (CWWidth | CWHeight | CWX | CWY);\n\n  Status\n    status;\n\n  unsigned int\n    height,\n    text_width,\n    visible_fonts,\n    width;\n\n  size_t\n    delay,\n    state;\n\n  XEvent\n    event;\n\n  XFontStruct\n    *font_info;\n\n  XTextProperty\n    window_name;\n\n  XWidgetInfo\n    action_info,\n    back_info,\n    cancel_info,\n    expose_info,\n    list_info,\n    mode_info,\n    north_info,\n    reply_info,\n    reset_info,\n    scroll_info,\n    selection_info,\n    slider_info,\n    south_info,\n    text_info;\n\n  XWindowChanges\n    window_changes;\n\n  /*\n    Get font list and sort in ascending order.\n  */\n  assert(display != (Display *) NULL);\n  assert(windows != (XWindows *) NULL);\n  assert(action != (char *) NULL);\n  assert(reply != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",action);\n  XSetCursorState(display,windows,MagickTrue);\n  XCheckRefreshWindows(display,windows);\n  (void) CopyMagickString(back_pattern,glob_pattern,MaxTextExtent);\n  (void) CopyMagickString(reset_pattern,\"*\",MaxTextExtent);\n  fontlist=XListFonts(display,glob_pattern,32767,&fonts);\n  if (fonts == 0)\n    {\n      /*\n        Pattern failed, obtain all the fonts.\n      */\n      XNoticeWidget(display,windows,\"Unable to obtain fonts names:\",\n        glob_pattern);\n      (void) CopyMagickString(glob_pattern,\"*\",MaxTextExtent);\n      fontlist=XListFonts(display,glob_pattern,32767,&fonts);\n      if (fontlist == (char **) NULL)\n        {\n          XNoticeWidget(display,windows,\"Unable to obtain fonts names:\",\n            glob_pattern);\n          return;\n        }\n    }\n  /*\n    Sort font list in ascending order.\n  */\n  listhead=fontlist;\n  fontlist=(char **) AcquireQuantumMemory((size_t) fonts,sizeof(*fontlist));\n  if (fontlist == (char **) NULL)\n    {\n      XNoticeWidget(display,windows,\"MemoryAllocationFailed\",\n        \"UnableToViewFonts\");\n      return;\n    }\n  for (i=0; i < fonts; i++)\n    fontlist[i]=listhead[i];\n  qsort((void *) fontlist,(size_t) fonts,sizeof(*fontlist),FontCompare);\n  /*\n    Determine Font Browser widget attributes.\n  */\n  font_info=windows->widget.font_info;\n  text_width=0;\n  for (i=0; i < fonts; i++)\n    if (WidgetTextWidth(font_info,fontlist[i]) > text_width)\n      text_width=WidgetTextWidth(font_info,fontlist[i]);\n  width=WidgetTextWidth(font_info,(char *) action);\n  if (WidgetTextWidth(font_info,CancelButtonText) > width)\n    width=WidgetTextWidth(font_info,CancelButtonText);\n  if (WidgetTextWidth(font_info,ResetButtonText) > width)\n    width=WidgetTextWidth(font_info,ResetButtonText);\n  if (WidgetTextWidth(font_info,BackButtonText) > width)\n    width=WidgetTextWidth(font_info,BackButtonText);\n  width+=QuantumMargin;\n  if (WidgetTextWidth(font_info,FontPatternText) > width)\n    width=WidgetTextWidth(font_info,FontPatternText);\n  if (WidgetTextWidth(font_info,FontnameText) > width)\n    width=WidgetTextWidth(font_info,FontnameText);\n  height=(unsigned int) (font_info->ascent+font_info->descent);\n  /*\n    Position Font Browser widget.\n  */\n  windows->widget.width=width+MagickMin((int) text_width,(int) MaxTextWidth)+\n    6*QuantumMargin;\n  windows->widget.min_width=width+MinTextWidth+4*QuantumMargin;\n  if (windows->widget.width < windows->widget.min_width)\n    windows->widget.width=windows->widget.min_width;\n  windows->widget.height=(unsigned int)\n    (((85*height) >> 2)+((13*QuantumMargin) >> 1)+4);\n  windows->widget.min_height=(unsigned int)\n    (((27*height) >> 1)+((13*QuantumMargin) >> 1)+4);\n  if (windows->widget.height < windows->widget.min_height)\n    windows->widget.height=windows->widget.min_height;\n  XConstrainWindowPosition(display,&windows->widget);\n  /*\n    Map Font Browser widget.\n  */\n  (void) CopyMagickString(windows->widget.name,\"Browse and Select a Font\",\n    MaxTextExtent);\n  status=XStringListToTextProperty(&windows->widget.name,1,&window_name);\n  if (status != False)\n    {\n      XSetWMName(display,windows->widget.id,&window_name);\n      XSetWMIconName(display,windows->widget.id,&window_name);\n      (void) XFree((void *) window_name.value);\n    }\n  window_changes.width=(int) windows->widget.width;\n  window_changes.height=(int) windows->widget.height;\n  window_changes.x=windows->widget.x;\n  window_changes.y=windows->widget.y;\n  (void) XReconfigureWMWindow(display,windows->widget.id,\n    windows->widget.screen,mask,&window_changes);\n  (void) XMapRaised(display,windows->widget.id);\n  windows->widget.mapped=MagickFalse;\n  /*\n    Respond to X events.\n  */\n  XGetWidgetInfo((char *) NULL,&slider_info);\n  XGetWidgetInfo((char *) NULL,&north_info);\n  XGetWidgetInfo((char *) NULL,&south_info);\n  XGetWidgetInfo((char *) NULL,&expose_info);\n  XGetWidgetInfo((char *) NULL,&selection_info);\n  visible_fonts=0;\n  delay=SuspendTime << 2;\n  state=UpdateConfigurationState;\n  do\n  {\n    if (state & UpdateConfigurationState)\n      {\n        int\n          id;\n\n        /*\n          Initialize button information.\n        */\n        XGetWidgetInfo(CancelButtonText,&cancel_info);\n        cancel_info.width=width;\n        cancel_info.height=(unsigned int) ((3*height) >> 1);\n        cancel_info.x=(int)\n          (windows->widget.width-cancel_info.width-QuantumMargin-2);\n        cancel_info.y=(int)\n          (windows->widget.height-cancel_info.height-QuantumMargin);\n        XGetWidgetInfo(action,&action_info);\n        action_info.width=width;\n        action_info.height=(unsigned int) ((3*height) >> 1);\n        action_info.x=cancel_info.x-(cancel_info.width+(QuantumMargin >> 1)+\n          (action_info.bevel_width << 1));\n        action_info.y=cancel_info.y;\n        XGetWidgetInfo(BackButtonText,&back_info);\n        back_info.width=width;\n        back_info.height=(unsigned int) ((3*height) >> 1);\n        back_info.x=QuantumMargin;\n        back_info.y=((5*QuantumMargin) >> 1)+height;\n        XGetWidgetInfo(ResetButtonText,&reset_info);\n        reset_info.width=width;\n        reset_info.height=(unsigned int) ((3*height) >> 1);\n        reset_info.x=QuantumMargin;\n        reset_info.y=back_info.y+back_info.height+QuantumMargin;\n        /*\n          Initialize reply information.\n        */\n        XGetWidgetInfo(reply,&reply_info);\n        reply_info.raised=MagickFalse;\n        reply_info.bevel_width--;\n        reply_info.width=windows->widget.width-width-((6*QuantumMargin) >> 1);\n        reply_info.height=height << 1;\n        reply_info.x=(int) (width+(QuantumMargin << 1));\n        reply_info.y=action_info.y-(action_info.height << 1)-QuantumMargin;\n        /*\n          Initialize mode information.\n        */\n        XGetWidgetInfo(reply,&mode_info);\n        mode_info.bevel_width=0;\n        mode_info.width=(unsigned int)\n          (action_info.x-reply_info.x-QuantumMargin);\n        mode_info.height=action_info.height << 1;\n        mode_info.x=reply_info.x;\n        mode_info.y=action_info.y-action_info.height+action_info.bevel_width;\n        /*\n          Initialize scroll information.\n        */\n        XGetWidgetInfo((char *) NULL,&scroll_info);\n        scroll_info.bevel_width--;\n        scroll_info.width=height;\n        scroll_info.height=(unsigned int)\n          (reply_info.y-back_info.y-(QuantumMargin >> 1));\n        scroll_info.x=reply_info.x+(reply_info.width-scroll_info.width);\n        scroll_info.y=back_info.y-reply_info.bevel_width;\n        scroll_info.raised=MagickFalse;\n        scroll_info.trough=MagickTrue;\n        north_info=scroll_info;\n        north_info.raised=MagickTrue;\n        north_info.width-=(north_info.bevel_width << 1);\n        north_info.height=north_info.width-1;\n        north_info.x+=north_info.bevel_width;\n        north_info.y+=north_info.bevel_width;\n        south_info=north_info;\n        south_info.y=scroll_info.y+scroll_info.height-scroll_info.bevel_width-\n          south_info.height;\n        id=slider_info.id;\n        slider_info=north_info;\n        slider_info.id=id;\n        slider_info.width-=2;\n        slider_info.min_y=north_info.y+north_info.height+north_info.bevel_width+\n          slider_info.bevel_width+2;\n        slider_info.height=scroll_info.height-((slider_info.min_y-\n          scroll_info.y+1) << 1)+4;\n        visible_fonts=(unsigned int) (scroll_info.height*\n          PerceptibleReciprocal((double) height+(height >> 3)));\n        if (fonts > (int) visible_fonts)\n          slider_info.height=(visible_fonts*slider_info.height)/fonts;\n        slider_info.max_y=south_info.y-south_info.bevel_width-\n          slider_info.bevel_width-2;\n        slider_info.x=scroll_info.x+slider_info.bevel_width+1;\n        slider_info.y=slider_info.min_y;\n        expose_info=scroll_info;\n        expose_info.y=slider_info.y;\n        /*\n          Initialize list information.\n        */\n        XGetWidgetInfo((char *) NULL,&list_info);\n        list_info.raised=MagickFalse;\n        list_info.bevel_width--;\n        list_info.width=(unsigned int)\n          (scroll_info.x-reply_info.x-(QuantumMargin >> 1));\n        list_info.height=scroll_info.height;\n        list_info.x=reply_info.x;\n        list_info.y=scroll_info.y;\n        if (windows->widget.mapped == MagickFalse)\n          state|=JumpListState;\n        /*\n          Initialize text information.\n        */\n        *text='\\0';\n        XGetWidgetInfo(text,&text_info);\n        text_info.center=MagickFalse;\n        text_info.width=reply_info.width;\n        text_info.height=height;\n        text_info.x=list_info.x-(QuantumMargin >> 1);\n        text_info.y=QuantumMargin;\n        /*\n          Initialize selection information.\n        */\n        XGetWidgetInfo((char *) NULL,&selection_info);\n        selection_info.center=MagickFalse;\n        selection_info.width=list_info.width;\n        selection_info.height=(unsigned int) ((9*height) >> 3);\n        selection_info.x=list_info.x;\n        state&=(~UpdateConfigurationState);\n      }\n    if (state & RedrawWidgetState)\n      {\n        /*\n          Redraw Font Browser window.\n        */\n        x=QuantumMargin;\n        y=text_info.y+((text_info.height-height) >> 1)+font_info->ascent;\n        (void) XDrawString(display,windows->widget.id,\n          windows->widget.annotate_context,x,y,FontPatternText,\n          Extent(FontPatternText));\n        (void) CopyMagickString(text_info.text,glob_pattern,MaxTextExtent);\n        XDrawWidgetText(display,&windows->widget,&text_info);\n        XDrawBeveledButton(display,&windows->widget,&back_info);\n        XDrawBeveledButton(display,&windows->widget,&reset_info);\n        XDrawBeveledMatte(display,&windows->widget,&list_info);\n        XDrawBeveledMatte(display,&windows->widget,&scroll_info);\n        XDrawTriangleNorth(display,&windows->widget,&north_info);\n        XDrawBeveledButton(display,&windows->widget,&slider_info);\n        XDrawTriangleSouth(display,&windows->widget,&south_info);\n        x=QuantumMargin;\n        y=reply_info.y+((reply_info.height-height) >> 1)+font_info->ascent;\n        (void) XDrawString(display,windows->widget.id,\n          windows->widget.annotate_context,x,y,FontnameText,\n          Extent(FontnameText));\n        XDrawBeveledMatte(display,&windows->widget,&reply_info);\n        XDrawMatteText(display,&windows->widget,&reply_info);\n        XDrawBeveledButton(display,&windows->widget,&action_info);\n        XDrawBeveledButton(display,&windows->widget,&cancel_info);\n        XHighlightWidget(display,&windows->widget,BorderOffset,BorderOffset);\n        selection_info.id=(~0);\n        state|=RedrawActionState;\n        state|=RedrawListState;\n        state&=(~RedrawWidgetState);\n      }\n    if (state & UpdateListState)\n      {\n        char\n          **checklist;\n\n        int\n          number_fonts;\n\n        /*\n          Update font list.\n        */\n        checklist=XListFonts(display,glob_pattern,32767,&number_fonts);\n        if (checklist == (char **) NULL)\n          {\n            if ((strchr(glob_pattern,'*') == (char *) NULL) &&\n                (strchr(glob_pattern,'?') == (char *) NULL))\n              {\n                /*\n                  Might be a scaleable font-- exit.\n                */\n                (void) CopyMagickString(reply,glob_pattern,MaxTextExtent);\n                (void) CopyMagickString(glob_pattern,back_pattern,MaxTextExtent);\n                action_info.raised=MagickFalse;\n                XDrawBeveledButton(display,&windows->widget,&action_info);\n                break;\n              }\n            (void) CopyMagickString(glob_pattern,back_pattern,MaxTextExtent);\n            (void) XBell(display,0);\n          }\n        else\n          if (number_fonts == 1)\n            {\n              /*\n                Reply is a single font name-- exit.\n              */\n              (void) CopyMagickString(reply,checklist[0],MaxTextExtent);\n              (void) CopyMagickString(glob_pattern,back_pattern,MaxTextExtent);\n              (void) XFreeFontNames(checklist);\n              action_info.raised=MagickFalse;\n              XDrawBeveledButton(display,&windows->widget,&action_info);\n              break;\n            }\n          else\n            {\n              (void) XFreeFontNames(listhead);\n              fontlist=(char **) RelinquishMagickMemory(fontlist);\n              fontlist=checklist;\n              fonts=number_fonts;\n            }\n        /*\n          Sort font list in ascending order.\n        */\n        listhead=fontlist;\n        fontlist=(char **) AcquireQuantumMemory((size_t) fonts,\n          sizeof(*fontlist));\n        if (fontlist == (char **) NULL)\n          {\n            XNoticeWidget(display,windows,\"MemoryAllocationFailed\",\n              \"UnableToViewFonts\");\n            return;\n          }\n        for (i=0; i < fonts; i++)\n          fontlist[i]=listhead[i];\n        qsort((void *) fontlist,(size_t) fonts,sizeof(*fontlist),FontCompare);\n        slider_info.height=\n          scroll_info.height-((slider_info.min_y-scroll_info.y+1) << 1)+1;\n        if (fonts > (int) visible_fonts)\n          slider_info.height=(visible_fonts*slider_info.height)/fonts;\n        slider_info.max_y=south_info.y-south_info.bevel_width-\n          slider_info.bevel_width-2;\n        slider_info.id=0;\n        slider_info.y=slider_info.min_y;\n        expose_info.y=slider_info.y;\n        selection_info.id=(~0);\n        list_info.id=(~0);\n        state|=RedrawListState;\n        /*\n          Redraw font name & reply.\n        */\n        *reply_info.text='\\0';\n        reply_info.cursor=reply_info.text;\n        (void) CopyMagickString(text_info.text,glob_pattern,MaxTextExtent);\n        XDrawWidgetText(display,&windows->widget,&text_info);\n        XDrawMatteText(display,&windows->widget,&reply_info);\n        XDrawBeveledMatte(display,&windows->widget,&scroll_info);\n        XDrawTriangleNorth(display,&windows->widget,&north_info);\n        XDrawBeveledButton(display,&windows->widget,&slider_info);\n        XDrawTriangleSouth(display,&windows->widget,&south_info);\n        XHighlightWidget(display,&windows->widget,BorderOffset,BorderOffset);\n        state&=(~UpdateListState);\n      }\n    if (state & JumpListState)\n      {\n        /*\n          Jump scroll to match user font.\n        */\n        list_info.id=(~0);\n        for (i=0; i < fonts; i++)\n          if (LocaleCompare(fontlist[i],reply) >= 0)\n            {\n              list_info.id=LocaleCompare(fontlist[i],reply) == 0 ? i : ~0;\n              break;\n            }\n        if ((i < slider_info.id) || (i >= (int) (slider_info.id+visible_fonts)))\n          slider_info.id=i-(visible_fonts >> 1);\n        selection_info.id=(~0);\n        state|=RedrawListState;\n        state&=(~JumpListState);\n      }\n    if (state & RedrawListState)\n      {\n        /*\n          Determine slider id and position.\n        */\n        if (slider_info.id >= (int) (fonts-visible_fonts))\n          slider_info.id=fonts-visible_fonts;\n        if ((slider_info.id < 0) || (fonts <= (int) visible_fonts))\n          slider_info.id=0;\n        slider_info.y=slider_info.min_y;\n        if (fonts > 0)\n          slider_info.y+=\n            slider_info.id*(slider_info.max_y-slider_info.min_y+1)/fonts;\n        if (slider_info.id != selection_info.id)\n          {\n            /*\n              Redraw scroll bar and file names.\n            */\n            selection_info.id=slider_info.id;\n            selection_info.y=list_info.y+(height >> 3)+2;\n            for (i=0; i < (int) visible_fonts; i++)\n            {\n              selection_info.raised=(slider_info.id+i) != list_info.id ?\n                MagickTrue : MagickFalse;\n              selection_info.text=(char *) NULL;\n              if ((slider_info.id+i) < fonts)\n                selection_info.text=fontlist[slider_info.id+i];\n              XDrawWidgetText(display,&windows->widget,&selection_info);\n              selection_info.y+=(int) selection_info.height;\n            }\n            /*\n              Update slider.\n            */\n            if (slider_info.y > expose_info.y)\n              {\n                expose_info.height=(unsigned int) slider_info.y-expose_info.y;\n                expose_info.y=slider_info.y-expose_info.height-\n                  slider_info.bevel_width-1;\n              }\n            else\n              {\n                expose_info.height=(unsigned int) expose_info.y-slider_info.y;\n                expose_info.y=slider_info.y+slider_info.height+\n                  slider_info.bevel_width+1;\n              }\n            XDrawTriangleNorth(display,&windows->widget,&north_info);\n            XDrawMatte(display,&windows->widget,&expose_info);\n            XDrawBeveledButton(display,&windows->widget,&slider_info);\n            XDrawTriangleSouth(display,&windows->widget,&south_info);\n            expose_info.y=slider_info.y;\n          }\n        state&=(~RedrawListState);\n      }\n    if (state & RedrawActionState)\n      {\n        XFontStruct\n          *save_info;\n\n        /*\n          Display the selected font in a drawing area.\n        */\n        save_info=windows->widget.font_info;\n        font_info=XLoadQueryFont(display,reply_info.text);\n        if (font_info != (XFontStruct *) NULL)\n          {\n            windows->widget.font_info=font_info;\n            (void) XSetFont(display,windows->widget.widget_context,\n              font_info->fid);\n          }\n        XDrawBeveledButton(display,&windows->widget,&mode_info);\n        windows->widget.font_info=save_info;\n        if (font_info != (XFontStruct *) NULL)\n          {\n            (void) XSetFont(display,windows->widget.widget_context,\n              windows->widget.font_info->fid);\n            (void) XFreeFont(display,font_info);\n          }\n        XHighlightWidget(display,&windows->widget,BorderOffset,BorderOffset);\n        XDrawMatteText(display,&windows->widget,&reply_info);\n        state&=(~RedrawActionState);\n      }\n    /*\n      Wait for next event.\n    */\n    if (north_info.raised && south_info.raised)\n      (void) XIfEvent(display,&event,XScreenEvent,(char *) windows);\n    else\n      {\n        /*\n          Brief delay before advancing scroll bar.\n        */\n        XDelay(display,delay);\n        delay=SuspendTime;\n        (void) XCheckIfEvent(display,&event,XScreenEvent,(char *) windows);\n        if (north_info.raised == MagickFalse)\n          if (slider_info.id > 0)\n            {\n              /*\n                Move slider up.\n              */\n              slider_info.id--;\n              state|=RedrawListState;\n            }\n        if (south_info.raised == MagickFalse)\n          if (slider_info.id < fonts)\n            {\n              /*\n                Move slider down.\n              */\n              slider_info.id++;\n              state|=RedrawListState;\n            }\n        if (event.type != ButtonRelease)\n          continue;\n      }\n    switch (event.type)\n    {\n      case ButtonPress:\n      {\n        if (MatteIsActive(slider_info,event.xbutton))\n          {\n            /*\n              Track slider.\n            */\n            slider_info.active=MagickTrue;\n            break;\n          }\n        if (MatteIsActive(north_info,event.xbutton))\n          if (slider_info.id > 0)\n            {\n              /*\n                Move slider up.\n              */\n              north_info.raised=MagickFalse;\n              slider_info.id--;\n              state|=RedrawListState;\n              break;\n            }\n        if (MatteIsActive(south_info,event.xbutton))\n          if (slider_info.id < fonts)\n            {\n              /*\n                Move slider down.\n              */\n              south_info.raised=MagickFalse;\n              slider_info.id++;\n              state|=RedrawListState;\n              break;\n            }\n        if (MatteIsActive(scroll_info,event.xbutton))\n          {\n            /*\n              Move slider.\n            */\n            if (event.xbutton.y < slider_info.y)\n              slider_info.id-=(visible_fonts-1);\n            else\n              slider_info.id+=(visible_fonts-1);\n            state|=RedrawListState;\n            break;\n          }\n        if (MatteIsActive(list_info,event.xbutton))\n          {\n            int\n              id;\n\n            /*\n              User pressed list matte.\n            */\n            id=slider_info.id+(event.xbutton.y-(list_info.y+(height >> 1))+1)/\n              selection_info.height;\n            if (id >= (int) fonts)\n              break;\n            (void) CopyMagickString(reply_info.text,fontlist[id],MaxTextExtent);\n            reply_info.highlight=MagickFalse;\n            reply_info.marker=reply_info.text;\n            reply_info.cursor=reply_info.text+Extent(reply_info.text);\n            XDrawMatteText(display,&windows->widget,&reply_info);\n            state|=RedrawActionState;\n            if (id == list_info.id)\n              {\n                (void) CopyMagickString(glob_pattern,reply_info.text,\n                  MaxTextExtent);\n                state|=UpdateListState;\n              }\n            selection_info.id=(~0);\n            list_info.id=id;\n            state|=RedrawListState;\n            break;\n          }\n        if (MatteIsActive(back_info,event.xbutton))\n          {\n            /*\n              User pressed Back button.\n            */\n            back_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&back_info);\n            break;\n          }\n        if (MatteIsActive(reset_info,event.xbutton))\n          {\n            /*\n              User pressed Reset button.\n            */\n            reset_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&reset_info);\n            break;\n          }\n        if (MatteIsActive(action_info,event.xbutton))\n          {\n            /*\n              User pressed action button.\n            */\n            action_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&action_info);\n            break;\n          }\n        if (MatteIsActive(cancel_info,event.xbutton))\n          {\n            /*\n              User pressed Cancel button.\n            */\n            cancel_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&cancel_info);\n            break;\n          }\n        if (MatteIsActive(reply_info,event.xbutton) == MagickFalse)\n          break;\n        if (event.xbutton.button != Button2)\n          {\n            static Time\n              click_time;\n\n            /*\n              Move text cursor to position of button press.\n            */\n            x=event.xbutton.x-reply_info.x-(QuantumMargin >> 2);\n            for (i=1; i <= Extent(reply_info.marker); i++)\n              if (XTextWidth(font_info,reply_info.marker,i) > x)\n                break;\n            reply_info.cursor=reply_info.marker+i-1;\n            if (event.xbutton.time > (click_time+DoubleClick))\n              reply_info.highlight=MagickFalse;\n            else\n              {\n                /*\n                  Become the XA_PRIMARY selection owner.\n                */\n                (void) CopyMagickString(primary_selection,reply_info.text,\n                  MaxTextExtent);\n                (void) XSetSelectionOwner(display,XA_PRIMARY,windows->widget.id,\n                  event.xbutton.time);\n                reply_info.highlight=XGetSelectionOwner(display,XA_PRIMARY) ==\n                  windows->widget.id ? MagickTrue : MagickFalse;\n              }\n            XDrawMatteText(display,&windows->widget,&reply_info);\n            click_time=event.xbutton.time;\n            break;\n          }\n        /*\n          Request primary selection.\n        */\n        (void) XConvertSelection(display,XA_PRIMARY,XA_STRING,XA_STRING,\n          windows->widget.id,event.xbutton.time);\n        break;\n      }\n      case ButtonRelease:\n      {\n        if (windows->widget.mapped == MagickFalse)\n          break;\n        if (north_info.raised == MagickFalse)\n          {\n            /*\n              User released up button.\n            */\n            delay=SuspendTime << 2;\n            north_info.raised=MagickTrue;\n            XDrawTriangleNorth(display,&windows->widget,&north_info);\n          }\n        if (south_info.raised == MagickFalse)\n          {\n            /*\n              User released down button.\n            */\n            delay=SuspendTime << 2;\n            south_info.raised=MagickTrue;\n            XDrawTriangleSouth(display,&windows->widget,&south_info);\n          }\n        if (slider_info.active)\n          {\n            /*\n              Stop tracking slider.\n            */\n            slider_info.active=MagickFalse;\n            break;\n          }\n        if (back_info.raised == MagickFalse)\n          {\n            if (event.xbutton.window == windows->widget.id)\n              if (MatteIsActive(back_info,event.xbutton))\n                {\n                  (void) CopyMagickString(glob_pattern,back_pattern,\n                    MaxTextExtent);\n                  state|=UpdateListState;\n                }\n            back_info.raised=MagickTrue;\n            XDrawBeveledButton(display,&windows->widget,&back_info);\n          }\n        if (reset_info.raised == MagickFalse)\n          {\n            if (event.xbutton.window == windows->widget.id)\n              if (MatteIsActive(reset_info,event.xbutton))\n                {\n                  (void) CopyMagickString(back_pattern,glob_pattern,MaxTextExtent);\n                  (void) CopyMagickString(glob_pattern,reset_pattern,MaxTextExtent);\n                  state|=UpdateListState;\n                }\n            reset_info.raised=MagickTrue;\n            XDrawBeveledButton(display,&windows->widget,&reset_info);\n          }\n        if (action_info.raised == MagickFalse)\n          {\n            if (event.xbutton.window == windows->widget.id)\n              {\n                if (MatteIsActive(action_info,event.xbutton))\n                  {\n                    if (*reply_info.text == '\\0')\n                      (void) XBell(display,0);\n                    else\n                      state|=ExitState;\n                  }\n              }\n            action_info.raised=MagickTrue;\n            XDrawBeveledButton(display,&windows->widget,&action_info);\n          }\n        if (cancel_info.raised == MagickFalse)\n          {\n            if (event.xbutton.window == windows->widget.id)\n              if (MatteIsActive(cancel_info,event.xbutton))\n                {\n                  *reply_info.text='\\0';\n                  state|=ExitState;\n                }\n            cancel_info.raised=MagickTrue;\n            XDrawBeveledButton(display,&windows->widget,&cancel_info);\n          }\n        break;\n      }\n      case ClientMessage:\n      {\n        /*\n          If client window delete message, exit.\n        */\n        if (event.xclient.message_type != windows->wm_protocols)\n          break;\n        if (*event.xclient.data.l == (int) windows->wm_take_focus)\n          {\n            (void) XSetInputFocus(display,event.xclient.window,RevertToParent,\n              (Time) event.xclient.data.l[1]);\n            break;\n          }\n        if (*event.xclient.data.l != (int) windows->wm_delete_window)\n          break;\n        if (event.xclient.window == windows->widget.id)\n          {\n            *reply_info.text='\\0';\n            state|=ExitState;\n            break;\n          }\n        break;\n      }\n      case ConfigureNotify:\n      {\n        /*\n          Update widget configuration.\n        */\n        if (event.xconfigure.window != windows->widget.id)\n          break;\n        if ((event.xconfigure.width == (int) windows->widget.width) &&\n            (event.xconfigure.height == (int) windows->widget.height))\n          break;\n        windows->widget.width=(unsigned int)\n          MagickMax(event.xconfigure.width,(int) windows->widget.min_width);\n        windows->widget.height=(unsigned int)\n          MagickMax(event.xconfigure.height,(int) windows->widget.min_height);\n        state|=UpdateConfigurationState;\n        break;\n      }\n      case EnterNotify:\n      {\n        if (event.xcrossing.window != windows->widget.id)\n          break;\n        state&=(~InactiveWidgetState);\n        break;\n      }\n      case Expose:\n      {\n        if (event.xexpose.window != windows->widget.id)\n          break;\n        if (event.xexpose.count != 0)\n          break;\n        state|=RedrawWidgetState;\n        break;\n      }\n      case KeyPress:\n      {\n        static char\n          command[MaxTextExtent];\n\n        static int\n          length;\n\n        static KeySym\n          key_symbol;\n\n        /*\n          Respond to a user key press.\n        */\n        if (event.xkey.window != windows->widget.id)\n          break;\n        length=XLookupString((XKeyEvent *) &event.xkey,command,\n          (int) sizeof(command),&key_symbol,(XComposeStatus *) NULL);\n        *(command+length)='\\0';\n        if (AreaIsActive(scroll_info,event.xkey))\n          {\n            /*\n              Move slider.\n            */\n            switch ((int) key_symbol)\n            {\n              case XK_Home:\n              case XK_KP_Home:\n              {\n                slider_info.id=0;\n                break;\n              }\n              case XK_Up:\n              case XK_KP_Up:\n              {\n                slider_info.id--;\n                break;\n              }\n              case XK_Down:\n              case XK_KP_Down:\n              {\n                slider_info.id++;\n                break;\n              }\n              case XK_Prior:\n              case XK_KP_Prior:\n              {\n                slider_info.id-=visible_fonts;\n                break;\n              }\n              case XK_Next:\n              case XK_KP_Next:\n              {\n                slider_info.id+=visible_fonts;\n                break;\n              }\n              case XK_End:\n              case XK_KP_End:\n              {\n                slider_info.id=fonts;\n                break;\n              }\n            }\n            state|=RedrawListState;\n            break;\n          }\n        if ((key_symbol == XK_Return) || (key_symbol == XK_KP_Enter))\n          {\n            /*\n              Read new font or glob patterm.\n            */\n            if (*reply_info.text == '\\0')\n              break;\n            (void) CopyMagickString(back_pattern,glob_pattern,MaxTextExtent);\n            (void) CopyMagickString(glob_pattern,reply_info.text,MaxTextExtent);\n            state|=UpdateListState;\n            break;\n          }\n        if (key_symbol == XK_Control_L)\n          {\n            state|=ControlState;\n            break;\n          }\n        if (state & ControlState)\n          switch ((int) key_symbol)\n          {\n            case XK_u:\n            case XK_U:\n            {\n              /*\n                Erase the entire line of text.\n              */\n              *reply_info.text='\\0';\n              reply_info.cursor=reply_info.text;\n              reply_info.marker=reply_info.text;\n              reply_info.highlight=MagickFalse;\n              break;\n            }\n            default:\n              break;\n          }\n        XEditText(display,&reply_info,key_symbol,command,state);\n        XDrawMatteText(display,&windows->widget,&reply_info);\n        state|=JumpListState;\n        break;\n      }\n      case KeyRelease:\n      {\n        static char\n          command[MaxTextExtent];\n\n        static KeySym\n          key_symbol;\n\n        /*\n          Respond to a user key release.\n        */\n        if (event.xkey.window != windows->widget.id)\n          break;\n        (void) XLookupString((XKeyEvent *) &event.xkey,command,\n          (int) sizeof(command),&key_symbol,(XComposeStatus *) NULL);\n        if (key_symbol == XK_Control_L)\n          state&=(~ControlState);\n        break;\n      }\n      case LeaveNotify:\n      {\n        if (event.xcrossing.window != windows->widget.id)\n          break;\n        state|=InactiveWidgetState;\n        break;\n      }\n      case MapNotify:\n      {\n        mask&=(~CWX);\n        mask&=(~CWY);\n        break;\n      }\n      case MotionNotify:\n      {\n        /*\n          Discard pending button motion events.\n        */\n        while (XCheckMaskEvent(display,ButtonMotionMask,&event)) ;\n        if (slider_info.active)\n          {\n            /*\n              Move slider matte.\n            */\n            slider_info.y=event.xmotion.y-\n              ((slider_info.height+slider_info.bevel_width) >> 1)+1;\n            if (slider_info.y < slider_info.min_y)\n              slider_info.y=slider_info.min_y;\n            if (slider_info.y > slider_info.max_y)\n              slider_info.y=slider_info.max_y;\n            slider_info.id=0;\n            if (slider_info.y != slider_info.min_y)\n              slider_info.id=(fonts*(slider_info.y-slider_info.min_y+1))/\n                (slider_info.max_y-slider_info.min_y+1);\n            state|=RedrawListState;\n            break;\n          }\n        if (state & InactiveWidgetState)\n          break;\n        if (back_info.raised == MatteIsActive(back_info,event.xmotion))\n          {\n            /*\n              Back button status changed.\n            */\n            back_info.raised=!back_info.raised;\n            XDrawBeveledButton(display,&windows->widget,&back_info);\n            break;\n          }\n        if (reset_info.raised == MatteIsActive(reset_info,event.xmotion))\n          {\n            /*\n              Reset button status changed.\n            */\n            reset_info.raised=!reset_info.raised;\n            XDrawBeveledButton(display,&windows->widget,&reset_info);\n            break;\n          }\n        if (action_info.raised == MatteIsActive(action_info,event.xmotion))\n          {\n            /*\n              Action button status changed.\n            */\n            action_info.raised=action_info.raised == MagickFalse ?\n              MagickTrue : MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&action_info);\n            break;\n          }\n        if (cancel_info.raised == MatteIsActive(cancel_info,event.xmotion))\n          {\n            /*\n              Cancel button status changed.\n            */\n            cancel_info.raised=cancel_info.raised == MagickFalse ?\n              MagickTrue : MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&cancel_info);\n            break;\n          }\n        break;\n      }\n      case SelectionClear:\n      {\n        reply_info.highlight=MagickFalse;\n        XDrawMatteText(display,&windows->widget,&reply_info);\n        break;\n      }\n      case SelectionNotify:\n      {\n        Atom\n          type;\n\n        int\n          format;\n\n        unsigned char\n          *data;\n\n        unsigned long\n          after,\n          length;\n\n        /*\n          Obtain response from primary selection.\n        */\n        if (event.xselection.property == (Atom) None)\n          break;\n        status=XGetWindowProperty(display,event.xselection.requestor,\n          event.xselection.property,0L,2047L,MagickTrue,XA_STRING,&type,\n          &format,&length,&after,&data);\n        if ((status != Success) || (type != XA_STRING) || (format == 32) ||\n            (length == 0))\n          break;\n        if ((Extent(reply_info.text)+length) >= (MaxTextExtent-1))\n          (void) XBell(display,0);\n        else\n          {\n            /*\n              Insert primary selection in reply text.\n            */\n            *(data+length)='\\0';\n            XEditText(display,&reply_info,(KeySym) XK_Insert,(char *) data,\n              state);\n            XDrawMatteText(display,&windows->widget,&reply_info);\n            state|=JumpListState;\n            state|=RedrawActionState;\n          }\n        (void) XFree((void *) data);\n        break;\n      }\n      case SelectionRequest:\n      {\n        XSelectionEvent\n          notify;\n\n        XSelectionRequestEvent\n          *request;\n\n        /*\n          Set XA_PRIMARY selection.\n        */\n        request=(&(event.xselectionrequest));\n        (void) XChangeProperty(request->display,request->requestor,\n          request->property,request->target,8,PropModeReplace,\n          (unsigned char *) primary_selection,Extent(primary_selection));\n        notify.type=SelectionNotify;\n        notify.display=request->display;\n        notify.requestor=request->requestor;\n        notify.selection=request->selection;\n        notify.target=request->target;\n        notify.time=request->time;\n        if (request->property == None)\n          notify.property=request->target;\n        else\n          notify.property=request->property;\n        (void) XSendEvent(request->display,request->requestor,False,0,\n          (XEvent *) &notify);\n      }\n      default:\n        break;\n    }\n  } while ((state & ExitState) == 0);\n  XSetCursorState(display,windows,MagickFalse);\n  (void) XWithdrawWindow(display,windows->widget.id,windows->widget.screen);\n  XCheckRefreshWindows(display,windows);\n  /*\n    Free font list.\n  */\n  (void) XFreeFontNames(listhead);\n  fontlist=(char **) RelinquishMagickMemory(fontlist);\n}", "func_hash": 99334885650241582492144416268982789812, "file_name": "widget.c", "file_hash": 31318598747823313517201273606802259325, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 199778, "project": "puma", "commit_id": "acdc3ae571dfae0e045cf09a295280127db65c7f", "project_url": "https://github.com/puma/puma", "commit_url": "https://github.com/puma/puma/commit/acdc3ae571dfae0e045cf09a295280127db65c7f", "commit_message": "Merge pull request from GHSA-48w2-rm65-62xx\n\n* Fix HTTP request smuggling vulnerability\n\nSee GHSA-48w2-rm65-62xx or CVE-2021-41136 for more info.\n\n* 4.3.9 release note\n\n* 5.5.1 release note\n\n* 5.5.1", "target": 1, "func": "size_t puma_parser_execute(puma_parser *parser, const char *buffer, size_t len, size_t off)  {\n  const char *p, *pe;\n  int cs = parser->cs;\n\n  assert(off <= len && \"offset past end of buffer\");\n\n  p = buffer+off;\n  pe = buffer+len;\n\n  /* assert(*pe == '\\0' && \"pointer does not end on NUL\"); */\n  assert((size_t) (pe - p) == len - off && \"pointers aren't same distance\");\n\n  \n#line 87 \"ext/puma_http11/http11_parser.c\"\n\t{\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tswitch ( cs )\n\t{\ncase 1:\n\tswitch( (*p) ) {\n\t\tcase 36: goto tr0;\n\t\tcase 95: goto tr0;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto tr0;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto tr0;\n\t} else\n\t\tgoto tr0;\n\tgoto st0;\nst0:\ncs = 0;\n\tgoto _out;\ntr0:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st2;\nst2:\n\tif ( ++p == pe )\n\t\tgoto _test_eof2;\ncase 2:\n#line 118 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st27;\n\t\tcase 95: goto st27;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st27;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st27;\n\t} else\n\t\tgoto st27;\n\tgoto st0;\ntr2:\n#line 50 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_method(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st3;\nst3:\n\tif ( ++p == pe )\n\t\tgoto _test_eof3;\ncase 3:\n#line 143 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 42: goto tr4;\n\t\tcase 43: goto tr5;\n\t\tcase 47: goto tr6;\n\t\tcase 58: goto tr7;\n\t}\n\tif ( (*p) < 65 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 57 )\n\t\t\tgoto tr5;\n\t} else if ( (*p) > 90 ) {\n\t\tif ( 97 <= (*p) && (*p) <= 122 )\n\t\t\tgoto tr5;\n\t} else\n\t\tgoto tr5;\n\tgoto st0;\ntr4:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st4;\nst4:\n\tif ( ++p == pe )\n\t\tgoto _test_eof4;\ncase 4:\n#line 167 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr8;\n\t\tcase 35: goto tr9;\n\t}\n\tgoto st0;\ntr8:\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr31:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n#line 56 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->fragment(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr33:\n#line 56 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->fragment(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr37:\n#line 69 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_path(parser, PTR_TO(mark), LEN(mark,p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr41:\n#line 60 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(query_start, p); }\n#line 61 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr44:\n#line 61 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\nst5:\n\tif ( ++p == pe )\n\t\tgoto _test_eof5;\ncase 5:\n#line 229 \"ext/puma_http11/http11_parser.c\"\n\tif ( (*p) == 72 )\n\t\tgoto tr10;\n\tgoto st0;\ntr10:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st6;\nst6:\n\tif ( ++p == pe )\n\t\tgoto _test_eof6;\ncase 6:\n#line 241 \"ext/puma_http11/http11_parser.c\"\n\tif ( (*p) == 84 )\n\t\tgoto st7;\n\tgoto st0;\nst7:\n\tif ( ++p == pe )\n\t\tgoto _test_eof7;\ncase 7:\n\tif ( (*p) == 84 )\n\t\tgoto st8;\n\tgoto st0;\nst8:\n\tif ( ++p == pe )\n\t\tgoto _test_eof8;\ncase 8:\n\tif ( (*p) == 80 )\n\t\tgoto st9;\n\tgoto st0;\nst9:\n\tif ( ++p == pe )\n\t\tgoto _test_eof9;\ncase 9:\n\tif ( (*p) == 47 )\n\t\tgoto st10;\n\tgoto st0;\nst10:\n\tif ( ++p == pe )\n\t\tgoto _test_eof10;\ncase 10:\n\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\tgoto st11;\n\tgoto st0;\nst11:\n\tif ( ++p == pe )\n\t\tgoto _test_eof11;\ncase 11:\n\tif ( (*p) == 46 )\n\t\tgoto st12;\n\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\tgoto st11;\n\tgoto st0;\nst12:\n\tif ( ++p == pe )\n\t\tgoto _test_eof12;\ncase 12:\n\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\tgoto st13;\n\tgoto st0;\nst13:\n\tif ( ++p == pe )\n\t\tgoto _test_eof13;\ncase 13:\n\tif ( (*p) == 13 )\n\t\tgoto tr18;\n\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\tgoto st13;\n\tgoto st0;\ntr18:\n#line 65 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->http_version(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st14;\ntr26:\n#line 46 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n#line 47 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->http_field(parser, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st14;\ntr29:\n#line 47 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->http_field(parser, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st14;\nst14:\n\tif ( ++p == pe )\n\t\tgoto _test_eof14;\ncase 14:\n#line 322 \"ext/puma_http11/http11_parser.c\"\n\tif ( (*p) == 10 )\n\t\tgoto st15;\n\tgoto st0;\nst15:\n\tif ( ++p == pe )\n\t\tgoto _test_eof15;\ncase 15:\n\tswitch( (*p) ) {\n\t\tcase 13: goto st16;\n\t\tcase 33: goto tr21;\n\t\tcase 124: goto tr21;\n\t\tcase 126: goto tr21;\n\t}\n\tif ( (*p) < 45 ) {\n\t\tif ( (*p) > 39 ) {\n\t\t\tif ( 42 <= (*p) && (*p) <= 43 )\n\t\t\t\tgoto tr21;\n\t\t} else if ( (*p) >= 35 )\n\t\t\tgoto tr21;\n\t} else if ( (*p) > 46 ) {\n\t\tif ( (*p) < 65 ) {\n\t\t\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\t\t\tgoto tr21;\n\t\t} else if ( (*p) > 90 ) {\n\t\t\tif ( 94 <= (*p) && (*p) <= 122 )\n\t\t\t\tgoto tr21;\n\t\t} else\n\t\t\tgoto tr21;\n\t} else\n\t\tgoto tr21;\n\tgoto st0;\nst16:\n\tif ( ++p == pe )\n\t\tgoto _test_eof16;\ncase 16:\n\tif ( (*p) == 10 )\n\t\tgoto tr22;\n\tgoto st0;\ntr22:\n#line 73 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->body_start = p - buffer + 1;\n    parser->header_done(parser, p + 1, pe - p - 1);\n    {p++; cs = 46; goto _out;}\n  }\n\tgoto st46;\nst46:\n\tif ( ++p == pe )\n\t\tgoto _test_eof46;\ncase 46:\n#line 373 \"ext/puma_http11/http11_parser.c\"\n\tgoto st0;\ntr21:\n#line 40 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(field_start, p); }\n#line 41 \"ext/puma_http11/http11_parser.rl\"\n\t{ snake_upcase_char((char *)p); }\n\tgoto st17;\ntr23:\n#line 41 \"ext/puma_http11/http11_parser.rl\"\n\t{ snake_upcase_char((char *)p); }\n\tgoto st17;\nst17:\n\tif ( ++p == pe )\n\t\tgoto _test_eof17;\ncase 17:\n#line 389 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 33: goto tr23;\n\t\tcase 58: goto tr24;\n\t\tcase 124: goto tr23;\n\t\tcase 126: goto tr23;\n\t}\n\tif ( (*p) < 45 ) {\n\t\tif ( (*p) > 39 ) {\n\t\t\tif ( 42 <= (*p) && (*p) <= 43 )\n\t\t\t\tgoto tr23;\n\t\t} else if ( (*p) >= 35 )\n\t\t\tgoto tr23;\n\t} else if ( (*p) > 46 ) {\n\t\tif ( (*p) < 65 ) {\n\t\t\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\t\t\tgoto tr23;\n\t\t} else if ( (*p) > 90 ) {\n\t\t\tif ( 94 <= (*p) && (*p) <= 122 )\n\t\t\t\tgoto tr23;\n\t\t} else\n\t\t\tgoto tr23;\n\t} else\n\t\tgoto tr23;\n\tgoto st0;\ntr24:\n#line 42 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->field_len = LEN(field_start, p);\n  }\n\tgoto st18;\ntr27:\n#line 46 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st18;\nst18:\n\tif ( ++p == pe )\n\t\tgoto _test_eof18;\ncase 18:\n#line 428 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 13: goto tr26;\n\t\tcase 32: goto tr27;\n\t}\n\tgoto tr25;\ntr25:\n#line 46 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st19;\nst19:\n\tif ( ++p == pe )\n\t\tgoto _test_eof19;\ncase 19:\n#line 442 \"ext/puma_http11/http11_parser.c\"\n\tif ( (*p) == 13 )\n\t\tgoto tr29;\n\tgoto st19;\ntr9:\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st20;\ntr38:\n#line 69 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_path(parser, PTR_TO(mark), LEN(mark,p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st20;\ntr42:\n#line 60 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(query_start, p); }\n#line 61 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st20;\ntr45:\n#line 61 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st20;\nst20:\n\tif ( ++p == pe )\n\t\tgoto _test_eof20;\ncase 20:\n#line 488 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr31;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( (*p) > 31 ) {\n\t\tif ( 34 <= (*p) && (*p) <= 35 )\n\t\t\tgoto st0;\n\t} else if ( (*p) >= 0 )\n\t\tgoto st0;\n\tgoto tr30;\ntr30:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st21;\nst21:\n\tif ( ++p == pe )\n\t\tgoto _test_eof21;\ncase 21:\n#line 509 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr33;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( (*p) > 31 ) {\n\t\tif ( 34 <= (*p) && (*p) <= 35 )\n\t\t\tgoto st0;\n\t} else if ( (*p) >= 0 )\n\t\tgoto st0;\n\tgoto st21;\ntr5:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st22;\nst22:\n\tif ( ++p == pe )\n\t\tgoto _test_eof22;\ncase 22:\n#line 530 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 43: goto st22;\n\t\tcase 58: goto st23;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st22;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( (*p) > 90 ) {\n\t\t\tif ( 97 <= (*p) && (*p) <= 122 )\n\t\t\t\tgoto st22;\n\t\t} else if ( (*p) >= 65 )\n\t\t\tgoto st22;\n\t} else\n\t\tgoto st22;\n\tgoto st0;\ntr7:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st23;\nst23:\n\tif ( ++p == pe )\n\t\tgoto _test_eof23;\ncase 23:\n#line 555 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr8;\n\t\tcase 34: goto st0;\n\t\tcase 35: goto tr9;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( 0 <= (*p) && (*p) <= 31 )\n\t\tgoto st0;\n\tgoto st23;\ntr6:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st24;\nst24:\n\tif ( ++p == pe )\n\t\tgoto _test_eof24;\ncase 24:\n#line 575 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr37;\n\t\tcase 34: goto st0;\n\t\tcase 35: goto tr38;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 63: goto tr39;\n\t\tcase 127: goto st0;\n\t}\n\tif ( 0 <= (*p) && (*p) <= 31 )\n\t\tgoto st0;\n\tgoto st24;\ntr39:\n#line 69 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_path(parser, PTR_TO(mark), LEN(mark,p));\n  }\n\tgoto st25;\nst25:\n\tif ( ++p == pe )\n\t\tgoto _test_eof25;\ncase 25:\n#line 598 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr41;\n\t\tcase 34: goto st0;\n\t\tcase 35: goto tr42;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( 0 <= (*p) && (*p) <= 31 )\n\t\tgoto st0;\n\tgoto tr40;\ntr40:\n#line 60 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(query_start, p); }\n\tgoto st26;\nst26:\n\tif ( ++p == pe )\n\t\tgoto _test_eof26;\ncase 26:\n#line 618 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr44;\n\t\tcase 34: goto st0;\n\t\tcase 35: goto tr45;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( 0 <= (*p) && (*p) <= 31 )\n\t\tgoto st0;\n\tgoto st26;\nst27:\n\tif ( ++p == pe )\n\t\tgoto _test_eof27;\ncase 27:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st28;\n\t\tcase 95: goto st28;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st28;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st28;\n\t} else\n\t\tgoto st28;\n\tgoto st0;\nst28:\n\tif ( ++p == pe )\n\t\tgoto _test_eof28;\ncase 28:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st29;\n\t\tcase 95: goto st29;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st29;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st29;\n\t} else\n\t\tgoto st29;\n\tgoto st0;\nst29:\n\tif ( ++p == pe )\n\t\tgoto _test_eof29;\ncase 29:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st30;\n\t\tcase 95: goto st30;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st30;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st30;\n\t} else\n\t\tgoto st30;\n\tgoto st0;\nst30:\n\tif ( ++p == pe )\n\t\tgoto _test_eof30;\ncase 30:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st31;\n\t\tcase 95: goto st31;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st31;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st31;\n\t} else\n\t\tgoto st31;\n\tgoto st0;\nst31:\n\tif ( ++p == pe )\n\t\tgoto _test_eof31;\ncase 31:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st32;\n\t\tcase 95: goto st32;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st32;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st32;\n\t} else\n\t\tgoto st32;\n\tgoto st0;\nst32:\n\tif ( ++p == pe )\n\t\tgoto _test_eof32;\ncase 32:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st33;\n\t\tcase 95: goto st33;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st33;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st33;\n\t} else\n\t\tgoto st33;\n\tgoto st0;\nst33:\n\tif ( ++p == pe )\n\t\tgoto _test_eof33;\ncase 33:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st34;\n\t\tcase 95: goto st34;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st34;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st34;\n\t} else\n\t\tgoto st34;\n\tgoto st0;\nst34:\n\tif ( ++p == pe )\n\t\tgoto _test_eof34;\ncase 34:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st35;\n\t\tcase 95: goto st35;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st35;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st35;\n\t} else\n\t\tgoto st35;\n\tgoto st0;\nst35:\n\tif ( ++p == pe )\n\t\tgoto _test_eof35;\ncase 35:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st36;\n\t\tcase 95: goto st36;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st36;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st36;\n\t} else\n\t\tgoto st36;\n\tgoto st0;\nst36:\n\tif ( ++p == pe )\n\t\tgoto _test_eof36;\ncase 36:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st37;\n\t\tcase 95: goto st37;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st37;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st37;\n\t} else\n\t\tgoto st37;\n\tgoto st0;\nst37:\n\tif ( ++p == pe )\n\t\tgoto _test_eof37;\ncase 37:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st38;\n\t\tcase 95: goto st38;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st38;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st38;\n\t} else\n\t\tgoto st38;\n\tgoto st0;\nst38:\n\tif ( ++p == pe )\n\t\tgoto _test_eof38;\ncase 38:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st39;\n\t\tcase 95: goto st39;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st39;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st39;\n\t} else\n\t\tgoto st39;\n\tgoto st0;\nst39:\n\tif ( ++p == pe )\n\t\tgoto _test_eof39;\ncase 39:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st40;\n\t\tcase 95: goto st40;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st40;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st40;\n\t} else\n\t\tgoto st40;\n\tgoto st0;\nst40:\n\tif ( ++p == pe )\n\t\tgoto _test_eof40;\ncase 40:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st41;\n\t\tcase 95: goto st41;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st41;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st41;\n\t} else\n\t\tgoto st41;\n\tgoto st0;\nst41:\n\tif ( ++p == pe )\n\t\tgoto _test_eof41;\ncase 41:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st42;\n\t\tcase 95: goto st42;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st42;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st42;\n\t} else\n\t\tgoto st42;\n\tgoto st0;\nst42:\n\tif ( ++p == pe )\n\t\tgoto _test_eof42;\ncase 42:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st43;\n\t\tcase 95: goto st43;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st43;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st43;\n\t} else\n\t\tgoto st43;\n\tgoto st0;\nst43:\n\tif ( ++p == pe )\n\t\tgoto _test_eof43;\ncase 43:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st44;\n\t\tcase 95: goto st44;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st44;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st44;\n\t} else\n\t\tgoto st44;\n\tgoto st0;\nst44:\n\tif ( ++p == pe )\n\t\tgoto _test_eof44;\ncase 44:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st45;\n\t\tcase 95: goto st45;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st45;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st45;\n\t} else\n\t\tgoto st45;\n\tgoto st0;\nst45:\n\tif ( ++p == pe )\n\t\tgoto _test_eof45;\ncase 45:\n\tif ( (*p) == 32 )\n\t\tgoto tr2;\n\tgoto st0;\n\t}\n\t_test_eof2: cs = 2; goto _test_eof; \n\t_test_eof3: cs = 3; goto _test_eof; \n\t_test_eof4: cs = 4; goto _test_eof; \n\t_test_eof5: cs = 5; goto _test_eof; \n\t_test_eof6: cs = 6; goto _test_eof; \n\t_test_eof7: cs = 7; goto _test_eof; \n\t_test_eof8: cs = 8; goto _test_eof; \n\t_test_eof9: cs = 9; goto _test_eof; \n\t_test_eof10: cs = 10; goto _test_eof; \n\t_test_eof11: cs = 11; goto _test_eof; \n\t_test_eof12: cs = 12; goto _test_eof; \n\t_test_eof13: cs = 13; goto _test_eof; \n\t_test_eof14: cs = 14; goto _test_eof; \n\t_test_eof15: cs = 15; goto _test_eof; \n\t_test_eof16: cs = 16; goto _test_eof; \n\t_test_eof46: cs = 46; goto _test_eof; \n\t_test_eof17: cs = 17; goto _test_eof; \n\t_test_eof18: cs = 18; goto _test_eof; \n\t_test_eof19: cs = 19; goto _test_eof; \n\t_test_eof20: cs = 20; goto _test_eof; \n\t_test_eof21: cs = 21; goto _test_eof; \n\t_test_eof22: cs = 22; goto _test_eof; \n\t_test_eof23: cs = 23; goto _test_eof; \n\t_test_eof24: cs = 24; goto _test_eof; \n\t_test_eof25: cs = 25; goto _test_eof; \n\t_test_eof26: cs = 26; goto _test_eof; \n\t_test_eof27: cs = 27; goto _test_eof; \n\t_test_eof28: cs = 28; goto _test_eof; \n\t_test_eof29: cs = 29; goto _test_eof; \n\t_test_eof30: cs = 30; goto _test_eof; \n\t_test_eof31: cs = 31; goto _test_eof; \n\t_test_eof32: cs = 32; goto _test_eof; \n\t_test_eof33: cs = 33; goto _test_eof; \n\t_test_eof34: cs = 34; goto _test_eof; \n\t_test_eof35: cs = 35; goto _test_eof; \n\t_test_eof36: cs = 36; goto _test_eof; \n\t_test_eof37: cs = 37; goto _test_eof; \n\t_test_eof38: cs = 38; goto _test_eof; \n\t_test_eof39: cs = 39; goto _test_eof; \n\t_test_eof40: cs = 40; goto _test_eof; \n\t_test_eof41: cs = 41; goto _test_eof; \n\t_test_eof42: cs = 42; goto _test_eof; \n\t_test_eof43: cs = 43; goto _test_eof; \n\t_test_eof44: cs = 44; goto _test_eof; \n\t_test_eof45: cs = 45; goto _test_eof; \n\n\t_test_eof: {}\n\t_out: {}\n\t}\n\n#line 117 \"ext/puma_http11/http11_parser.rl\"\n\n  if (!puma_parser_has_error(parser))\n    parser->cs = cs;\n  parser->nread += p - (buffer + off);\n\n  assert(p <= pe && \"buffer overflow after parsing execute\");\n  assert(parser->nread <= len && \"nread longer than length\");\n  assert(parser->body_start <= len && \"body starts after buffer end\");\n  assert(parser->mark < len && \"mark is after buffer end\");\n  assert(parser->field_len <= len && \"field has length longer than whole buffer\");\n  assert(parser->field_start < len && \"field starts after buffer end\");\n\n  return(parser->nread);\n}", "func_hash": 94439113710401505299900606066823977917, "file_name": "http11_parser.c", "file_hash": 59830834973701402944362779116096200943, "cwe": ["CWE-444"], "cve": "CVE-2021-41136", "cve_desc": "Puma is a HTTP 1.1 server for Ruby/Rack applications. Prior to versions 5.5.1 and 4.3.9, using `puma` with a proxy which forwards HTTP header values which contain the LF character could allow HTTP request smugggling. A client could smuggle a request through a proxy, causing the proxy to send a response back to another unknown client. The only proxy which has this behavior, as far as the Puma team is aware of, is Apache Traffic Server. If the proxy uses persistent connections and the client adds another request in via HTTP pipelining, the proxy may mistake it as the first request's body. Puma, however, would see it as two requests, and when processing the second request, send back a response that the proxy does not expect. If the proxy has reused the persistent connection to Puma to send another request for a different client, the second response from the first client will be sent to the second client. This vulnerability was patched in Puma 5.5.1 and 4.3.9. As a workaround, do not use Apache Traffic Server with `puma`.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41136"}
{"idx": 90222, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual const WifiNetworkVector& remembered_wifi_networks() const {\n    return remembered_wifi_networks_;\n  }\n", "func_hash": 103061422617783678510633694060449189310, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90845, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  void DidGetModifiedOrigins(const std::set<GURL>& origins, StorageType type) {\n    modified_origins_ = origins;\n    modified_origins_type_ = type;\n  }\n", "func_hash": 303618201146505061336859258130906191991, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 220104, "project": "linux", "commit_id": "ab0fc21bc7105b54bafd85bd8b82742f9e68898a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/ab0fc21bc7105b54bafd85bd8b82742f9e68898a", "commit_message": "Revert \"NFSv4: Handle the special Linux file open access mode\"\n\nThis reverts commit 44942b4e457beda00981f616402a1a791e8c616e.\n\nAfter secondly opening a file with O_ACCMODE|O_DIRECT flags,\nnfs4_valid_open_stateid() will dereference NULL nfs4_state when lseek().\n\nReproducer:\n  1. mount -t nfs -o vers=4.2 $server_ip:/ /mnt/\n  2. fd = open(\"/mnt/file\", O_ACCMODE|O_DIRECT|O_CREAT)\n  3. close(fd)\n  4. fd = open(\"/mnt/file\", O_ACCMODE|O_DIRECT)\n  5. lseek(fd)\n\nReported-by: Lyu Tao <tao.lyu@epfl.ch>\nSigned-off-by: ChenXiaoSong <chenxiaosong2@huawei.com>\nSigned-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>", "target": 0, "func": "static ssize_t __nfs4_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t      struct file *file_out, loff_t pos_out,\n\t\t\t\t      size_t count, unsigned int flags)\n{\n\tstruct nfs42_copy_notify_res *cn_resp = NULL;\n\tstruct nl4_server *nss = NULL;\n\tnfs4_stateid *cnrs = NULL;\n\tssize_t ret;\n\tbool sync = false;\n\n\t/* Only offload copy if superblock is the same */\n\tif (file_in->f_op != &nfs4_file_operations)\n\t\treturn -EXDEV;\n\tif (!nfs_server_capable(file_inode(file_out), NFS_CAP_COPY) ||\n\t    !nfs_server_capable(file_inode(file_in), NFS_CAP_COPY))\n\t\treturn -EOPNOTSUPP;\n\tif (file_inode(file_in) == file_inode(file_out))\n\t\treturn -EOPNOTSUPP;\n\t/* if the copy size if smaller than 2 RPC payloads, make it\n\t * synchronous\n\t */\n\tif (count <= 2 * NFS_SERVER(file_inode(file_in))->rsize)\n\t\tsync = true;\nretry:\n\tif (!nfs42_files_from_same_server(file_in, file_out)) {\n\t\t/*\n\t\t * for inter copy, if copy size is too small\n\t\t * then fallback to generic copy.\n\t\t */\n\t\tif (sync)\n\t\t\treturn -EOPNOTSUPP;\n\t\tcn_resp = kzalloc(sizeof(struct nfs42_copy_notify_res),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (unlikely(cn_resp == NULL))\n\t\t\treturn -ENOMEM;\n\n\t\tret = nfs42_proc_copy_notify(file_in, file_out, cn_resp);\n\t\tif (ret) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tnss = &cn_resp->cnr_src;\n\t\tcnrs = &cn_resp->cnr_stateid;\n\t}\n\tret = nfs42_proc_copy(file_in, pos_in, file_out, pos_out, count,\n\t\t\t\tnss, cnrs, sync);\nout:\n\tkfree(cn_resp);\n\n\tif (ret == -EAGAIN)\n\t\tgoto retry;\n\treturn ret;\n}", "func_hash": 129148890053158408762714768479132470389, "file_name": "nfs4file.c", "file_hash": 19160442996144037090827134285929888626, "cwe": ["CWE-909"], "cve": "CVE-2022-24448", "cve_desc": "An issue was discovered in fs/nfs/dir.c in the Linux kernel before 5.16.5. If an application sets the O_DIRECTORY flag, and tries to open a regular file, nfs_atomic_open() performs a regular lookup. If a regular file is found, ENOTDIR should occur, but the server instead returns uninitialized data in the file descriptor.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-24448"}
{"idx": 221401, "project": "linux", "commit_id": "c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc", "commit_message": "KVM: nSVM: always intercept VMLOAD/VMSAVE when nested (CVE-2021-3656)\n\nIf L1 disables VMLOAD/VMSAVE intercepts, and doesn't enable\nVirtual VMLOAD/VMSAVE (currently not supported for the nested hypervisor),\nthen VMLOAD/VMSAVE must operate on the L1 physical memory, which is only\npossible by making L0 intercept these instructions.\n\nFailure to do so allowed the nested guest to run VMLOAD/VMSAVE unintercepted,\nand thus read/write portions of the host physical memory.\n\nFixes: 89c8a4984fc9 (\"KVM: SVM: Enable Virtual VMLOAD VMSAVE feature\")\n\nSuggested-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Maxim Levitsky <mlevitsk@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "target": 0, "func": "static inline bool nested_exit_on_init(struct vcpu_svm *svm)\n{\n\treturn vmcb_is_intercept(&svm->nested.ctl, INTERCEPT_INIT);\n}", "func_hash": 304345743359124987296673939790911329231, "file_name": "nested.c", "file_hash": 108011292709121623935842232206389598409, "cwe": ["CWE-862"], "cve": "CVE-2021-3656", "cve_desc": "A flaw was found in the KVM's AMD code for supporting SVM nested virtualization. The flaw occurs when processing the VMCB (virtual machine control block) provided by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation of the \"virt_ext\" field, this issue could allow a malicious L1 to disable both VMLOAD/VMSAVE intercepts and VLS (Virtual VMLOAD/VMSAVE) for the L2 guest. As a result, the L2 guest would be allowed to read/write physical pages of the host, resulting in a crash of the entire system, leak of sensitive data or potential guest-to-host escape.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3656"}
{"idx": 175699, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual bool cellular_enabled() const { return false; }\n", "func_hash": 136981732712477451181117132354670548841, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 220399, "project": "mruby", "commit_id": "27d1e0132a0804581dca28df042e7047fd27eaa8", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8", "commit_message": "array.c: fix `mrb_ary_shift_m` initialization bug.\n\nThe `ARY_PTR` and `ARY_LEN` may be modified in `mrb_get_args`.", "target": 0, "func": "ary_replace(mrb_state *mrb, struct RArray *a, struct RArray *b)\n{\n  mrb_int len = ARY_LEN(b);\n\n  ary_modify_check(mrb, a);\n  if (a == b) return;\n  if (ARY_SHARED_P(a)) {\n    mrb_ary_decref(mrb, a->as.heap.aux.shared);\n    a->as.heap.aux.capa = 0;\n    a->as.heap.len = 0;\n    a->as.heap.ptr = NULL;\n    ARY_UNSET_SHARED_FLAG(a);\n  }\n  if (ARY_SHARED_P(b)) {\n  shared_b:\n    if (ARY_EMBED_P(a)) {\n      ARY_UNSET_EMBED_FLAG(a);\n    }\n    else {\n      mrb_free(mrb, a->as.heap.ptr);\n    }\n    a->as.heap.ptr = b->as.heap.ptr;\n    a->as.heap.len = len;\n    a->as.heap.aux.shared = b->as.heap.aux.shared;\n    a->as.heap.aux.shared->refcnt++;\n    ARY_SET_SHARED_FLAG(a);\n    mrb_write_barrier(mrb, (struct RBasic*)a);\n    return;\n  }\n  if (!mrb_frozen_p(b) && len > ARY_REPLACE_SHARED_MIN) {\n    ary_make_shared(mrb, b);\n    goto shared_b;\n  }\n  if (ARY_CAPA(a) < len)\n    ary_expand_capa(mrb, a, len);\n  array_copy(ARY_PTR(a), ARY_PTR(b), len);\n  mrb_write_barrier(mrb, (struct RBasic*)a);\n  ARY_SET_LEN(a, len);\n}", "func_hash": 57203599215708279030571847204974539815, "file_name": "array.c", "file_hash": 295526445825727607536544634773604768998, "cwe": ["CWE-476"], "cve": "CVE-2021-4188", "cve_desc": "mruby is vulnerable to NULL Pointer Dereference", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4188"}
{"idx": 195017, "project": "gpac", "commit_id": "ad18ece95fa064efc0995c4ab2c985f77fb166ec", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/ad18ece95fa064efc0995c4ab2c985f77fb166ec", "commit_message": "fixed #1904", "target": 1, "func": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\t\t\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}", "func_hash": 91218268849686441388880855658517990203, "file_name": "hint_track.c", "file_hash": 60176895274654779679144452624639678766, "cwe": ["CWE-476"], "cve": "CVE-2021-40576", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability in the gf_isom_get_payt_count function in hint_track.c, which allows attackers to cause a denial of service.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40576"}
{"idx": 219957, "project": "glewlwyd", "commit_id": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "project_url": "https://github.com/babelouest/glewlwyd", "commit_url": "https://github.com/babelouest/glewlwyd/commit/125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "commit_message": "Fix update session when auth fail", "target": 0, "func": "int callback_metrics (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  UNUSED(request);\n  struct config_elements * config = (struct config_elements *)user_data;\n  size_t i, j;\n  char * content = o_strdup(\"# We have seen handsome noble-looking men but I have never seen a man like the one who now stands at the entrance of the gate.\\n\");\n  struct _glwd_metric * metric;\n  \n  if (!pthread_mutex_lock(&config->metrics_lock)) {\n    u_map_put(response->map_header, ULFIUS_HTTP_HEADER_CONTENT, \"text/plain; charset=utf-8\");\n    for (i=0; i<pointer_list_size(&config->metrics_list); i++) {\n      metric = (struct _glwd_metric *)pointer_list_get_at(&config->metrics_list, i);\n      content = mstrcatf(content, \"# HELP %s_total %s\\n\", metric->name, metric->help);\n      content = mstrcatf(content, \"# TYPE %s_total counter\\n\", metric->name);\n      for (j=0; j<metric->data_size; j++) {\n        if (metric->data[j].label != NULL) {\n          content = mstrcatf(content, \"%s_total{%s} %zu\\n\", metric->name, metric->data[j].label, metric->data[j].counter);\n        } else {\n          content = mstrcatf(content, \"%s_total %zu\\n\", metric->name, metric->data[j].counter);\n        }\n      }\n    }\n    ulfius_set_string_body_response(response, 200, content);\n    o_free(content);\n    pthread_mutex_unlock(&config->metrics_lock);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_metrics - Error lock\");\n    response->status = 500;\n  }\n  return U_CALLBACK_CONTINUE;\n}", "func_hash": 63017619658868044576527414819950320285, "file_name": "webservice.c", "file_hash": 287798817606377336444620654835011177393, "cwe": ["CWE-287"], "cve": "CVE-2021-45379", "cve_desc": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-45379"}
{"idx": 219931, "project": "tensorflow", "commit_id": "6b5adc0877de832b2a7c189532dbbbc64622eeb6", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/6b5adc0877de832b2a7c189532dbbbc64622eeb6", "commit_message": "Prevent `CHECK`-fail when building reference tensor.\n\nThe tensor constructor does not allow reference dtypes, as these should not show up explicitly. However, when passed these invalid types instead of building an invalid object the constructor crashes via a `CHECK`-fail. We have a static builder that properly handles this case but is not applicable given current usage.\n\nInstead, before calling the constructor, we can check that the dtype is not a reference type and return an error otherwise, given that the dtype is user controlled so malicious users can trigger denial of service.\n\nPiperOrigin-RevId: 409662503\nChange-Id: I5892f831fde7f276cd7ab34519cf6b8061c71a59", "target": 0, "func": "Status ConstantFolding::EvaluateOneFoldable(const NodeDef& node,\n                                            std::vector<NodeDef>* outputs,\n                                            bool* result_too_large) {\n  TensorVector inputs;\n  TensorVector output_tensors;\n  auto inputs_cleanup = gtl::MakeCleanup([&inputs, &output_tensors] {\n    for (const auto& input : inputs) {\n      delete input.tensor;\n    }\n    for (const auto& output : output_tensors) {\n      if (output.tensor) {\n        delete output.tensor;\n      }\n    }\n  });\n\n  size_t total_inputs_size = 0;\n  for (const auto& input : node.input()) {\n    const TensorId input_tensor = ParseTensorName(input);\n    if (input_tensor.index() < 0) {\n      // Control dependency\n      break;\n    }\n    const NodeDef* input_node = node_map_->GetNode(input);\n    if (!IsReallyConstant(*input_node)) {\n      return Status(error::INVALID_ARGUMENT,\n                    strings::StrCat(\"Can't fold \", node.name(), \", its \", input,\n                                    \" isn't constant\"));\n    }\n    TF_RETURN_IF_ERROR(CheckAttrExists(*input_node, \"value\"));\n    const TensorProto& raw_val = input_node->attr().at(\"value\").tensor();\n    if (raw_val.dtype() == DT_INVALID) {\n      return Status(\n          error::INVALID_ARGUMENT,\n          strings::StrCat(\"A tensor in the input node, with TensorId of \",\n                          input_tensor.ToString(),\n                          \" has a dtype of DT_INVALID.\"));\n    }\n    if (IsRefType(raw_val.dtype())) {\n      return errors::InvalidArgument(\n          \"Not allowed to construct a tensor with reference dtype, got \",\n          DataTypeString(raw_val.dtype()));\n    }\n    Tensor* value = new Tensor(raw_val.dtype(), raw_val.tensor_shape());\n    if (!value->FromProto(raw_val)) {\n      delete (value);\n      return errors::InvalidArgument(\"Unable to make Tensor from proto for \",\n                                     node.name(), \" with shape \",\n                                     raw_val.tensor_shape().DebugString());\n    }\n    inputs.emplace_back(value);\n    total_inputs_size += value->TotalBytes();\n  }\n\n  TF_RETURN_IF_ERROR(EvaluateNode(node, inputs, &output_tensors));\n  if (output_tensors.empty()) {\n    return Status(error::INVALID_ARGUMENT, \"Expected at least one output.\");\n  }\n\n  outputs->resize(output_tensors.size());\n  for (size_t i = 0; i < output_tensors.size(); i++) {\n    string node_name = OptimizedNodeName(node, \"-folded\");\n    if (output_tensors.size() > 1) {\n      node_name = strings::StrCat(node_name, \"-\", i);\n    }\n    if (output_tensors[i].tensor) {\n      Status s = CreateNodeDef(node_name, output_tensors[i], &outputs->at(i),\n                               total_inputs_size);\n      if (!s.ok()) {\n        *result_too_large = true;\n        return s;\n      }\n    } else {\n      // Create an empty NodeDef to identify dead outputs (e.g. the output of a\n      // switch that's not selected by the switch predicate).\n      outputs->at(i) = NodeDef();\n    }\n  }\n  return Status::OK();\n}", "func_hash": 111779981092160670584101984885423453823, "file_name": "constant_folding.cc", "file_hash": 271606694375277711450004865336349725435, "cwe": ["CWE-617"], "cve": "CVE-2022-23588", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that Grappler optimizer would attempt to build a tensor using a reference `dtype`. This would result in a crash due to a `CHECK`-fail in the `Tensor` constructor as reference types are not allowed. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23588"}
{"idx": 198736, "project": "linux", "commit_id": "d563131ef23cbc756026f839a82598c8445bc45f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d563131ef23cbc756026f839a82598c8445bc45f", "commit_message": "rsi: release skb if rsi_prepare_beacon fails\n\nIn rsi_send_beacon, if rsi_prepare_beacon fails the allocated skb should\nbe released.\n\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>", "target": 1, "func": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\n\treturn 0;\n}", "func_hash": 130931178778692254191224779038755080046, "file_name": "rsi_91x_mgmt.c", "file_hash": 125660046646447806158908760119804627111, "cwe": ["CWE-401"], "cve": "CVE-2019-19071", "cve_desc": "A memory leak in the rsi_send_beacon() function in drivers/net/wireless/rsi/rsi_91x_mgmt.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering rsi_prepare_beacon() failures, aka CID-d563131ef23c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19071"}
{"idx": 220197, "project": "tensorflow", "commit_id": "c99d98cd189839dcf51aee94e7437b54b31f8abd", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/c99d98cd189839dcf51aee94e7437b54b31f8abd", "commit_message": "Handle invalid inputs instead of crashing.\n\nPiperOrigin-RevId: 409549744\nChange-Id: I7f5935b34b53f7e426a5462fcc027bdbf5dcda24", "target": 0, "func": "void Graph::Copy(const Graph& src) {\n  SetConstructionContext(src.GetConstructionContextInternal());\n  for (Node* n : nodes()) {\n    CHECK(n->IsSource() || n->IsSink()) << \"*dest must be empty\";\n  }\n\n  // Copy GraphDef versions\n  set_versions(src.versions());\n\n  // Copy the nodes.\n  // \"Node in src\" -> \"Node in *dest\"\n  gtl::FlatMap<const Node*, Node*> node_map;\n  node_map.reserve(src.num_nodes());\n  node_map[src.source_node()] = source_node();\n  node_map[src.sink_node()] = sink_node();\n  for (Node* n : src.op_nodes()) {\n    auto copy = CopyNode(n);\n    copy->in_edges_.reserve(n->in_edges().size());\n    copy->out_edges_.reserve(n->out_edges().size());\n    node_map[n] = copy;\n  }\n\n  // Copy the edges\n  edges_.reserve(src.num_edges());\n  for (const Edge* e : src.edges()) {\n    Node* src_copy = node_map[e->src()];\n    Node* dst_copy = node_map[e->dst()];\n    AddEdge(src_copy, e->src_output(), dst_copy, e->dst_input());\n  }\n}", "func_hash": 200632211357625106077002661001591760499, "file_name": "graph.cc", "file_hash": 172099243927919341591512227523808328051, "cwe": ["CWE-125"], "cve": "CVE-2022-23592", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. TensorFlow's type inference can cause a heap out of bounds read as the bounds checking is done in a `DCHECK` (which is a no-op during production). An attacker can control the `input_idx` variable such that `ix` would be larger than the number of values in `node_t.args`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23592"}
{"idx": 175691, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual void ForgetWifiNetwork(const std::string& service_path) {}\n", "func_hash": 301328038796336754244959432557991017246, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 210866, "project": "xserver", "commit_id": "144849ea27230962227e62a943b399e2ab304787", "project_url": "http://gitweb.freedesktop.org/?p=xorg/xserver", "commit_url": "https://gitlab.freedesktop.org/xorg/xserver/-/commit/144849ea27230962227e62a943b399e2ab304787", "commit_message": "Fix XkbSelectEvents() integer underflow\n\nCVE-2020-14361 ZDI-CAN 11573\n\nThis vulnerability was discovered by:\nJan-Niklas Sohn working with Trend Micro Zero Day Initiative\n\nSigned-off-by: Matthieu Herrb <matthieu@herrb.eu>", "target": 1, "func": "SProcXkbSelectEvents(ClientPtr client)\n{\n    REQUEST(xkbSelectEventsReq);\n\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);\n    swaps(&stuff->deviceSpec);\n    swaps(&stuff->affectWhich);\n    swaps(&stuff->clear);\n    swaps(&stuff->selectAll);\n    swaps(&stuff->affectMap);\n    swaps(&stuff->map);\n    if ((stuff->affectWhich & (~XkbMapNotifyMask)) != 0) {\n        union {\n            BOOL *b;\n            CARD8 *c8;\n            CARD16 *c16;\n            CARD32 *c32;\n        } from;\n        register unsigned bit, ndx, maskLeft, dataLeft, size;\n\n        from.c8 = (CARD8 *) &stuff[1];\n        dataLeft = (stuff->length * 4) - SIZEOF(xkbSelectEventsReq);\n        maskLeft = (stuff->affectWhich & (~XkbMapNotifyMask));\n        for (ndx = 0, bit = 1; (maskLeft != 0); ndx++, bit <<= 1) {\n            if (((bit & maskLeft) == 0) || (ndx == XkbMapNotify))\n                continue;\n            maskLeft &= ~bit;\n            if ((stuff->selectAll & bit) || (stuff->clear & bit))\n                continue;\n            switch (ndx) {\n            case XkbNewKeyboardNotify:\n            case XkbStateNotify:\n            case XkbNamesNotify:\n            case XkbAccessXNotify:\n            case XkbExtensionDeviceNotify:\n                size = 2;\n                break;\n            case XkbControlsNotify:\n            case XkbIndicatorStateNotify:\n            case XkbIndicatorMapNotify:\n                size = 4;\n                break;\n            case XkbBellNotify:\n            case XkbActionMessage:\n            case XkbCompatMapNotify:\n                size = 1;\n                break;\n            default:\n                client->errorValue = _XkbErrCode2(0x1, bit);\n                return BadValue;\n            }\n            if (dataLeft < (size * 2))\n                return BadLength;\n            if (size == 2) {\n                swaps(&from.c16[0]);\n                swaps(&from.c16[1]);\n            }\n            else if (size == 4) {\n                swapl(&from.c32[0]);\n                swapl(&from.c32[1]);\n            }\n            else {\n                size = 2;\n            }\n            from.c8 += (size * 2);\n            dataLeft -= (size * 2);\n        }\n        if (dataLeft > 2) {\n            ErrorF(\"[xkb] Extra data (%d bytes) after SelectEvents\\n\",\n                   dataLeft);\n            return BadLength;\n        }\n    }\n    return ProcXkbSelectEvents(client);\n}", "func_hash": 49390769000512777763270194535836546170, "file_name": "xkbSwap.c", "file_hash": 248954015122387054723435955727908433288, "cwe": ["CWE-191"], "cve": "CVE-2020-14361", "cve_desc": "A flaw was found in X.Org Server before xorg-x11-server 1.20.9. An Integer underflow leading to heap-buffer overflow may lead to a privilege escalation vulnerability. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-14361"}
{"idx": 221488, "project": "flatpak", "commit_id": "89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "commit_message": "run: Add cross-references for some other seccomp syscall filters\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "target": 0, "func": "flatpak_run_add_a11y_dbus_args (FlatpakBwrap   *app_bwrap,\n                                FlatpakBwrap   *proxy_arg_bwrap,\n                                FlatpakContext *context,\n                                FlatpakRunFlags flags)\n{\n  static const char sandbox_socket_path[] = \"/run/flatpak/at-spi-bus\";\n  static const char sandbox_dbus_address[] = \"unix:path=/run/flatpak/at-spi-bus\";\n  g_autoptr(GDBusConnection) session_bus = NULL;\n  g_autofree char *a11y_address = NULL;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GDBusMessage) reply = NULL;\n  g_autoptr(GDBusMessage) msg = NULL;\n  g_autofree char *proxy_socket = NULL;\n\n  if ((flags & FLATPAK_RUN_FLAG_NO_A11Y_BUS_PROXY) != 0)\n    return FALSE;\n\n  session_bus = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  if (session_bus == NULL)\n    return FALSE;\n\n  msg = g_dbus_message_new_method_call (\"org.a11y.Bus\", \"/org/a11y/bus\", \"org.a11y.Bus\", \"GetAddress\");\n  g_dbus_message_set_body (msg, g_variant_new (\"()\"));\n  reply =\n    g_dbus_connection_send_message_with_reply_sync (session_bus, msg,\n                                                    G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                    30000,\n                                                    NULL,\n                                                    NULL,\n                                                    NULL);\n  if (reply)\n    {\n      if (g_dbus_message_to_gerror (reply, &local_error))\n        {\n          if (!g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN))\n            g_message (\"Can't find a11y bus: %s\", local_error->message);\n        }\n      else\n        {\n          g_variant_get (g_dbus_message_get_body (reply),\n                         \"(s)\", &a11y_address);\n        }\n    }\n\n  if (!a11y_address)\n    return FALSE;\n\n  proxy_socket = create_proxy_socket (\"a11y-bus-proxy-XXXXXX\");\n  if (proxy_socket == NULL)\n    return FALSE;\n\n  flatpak_bwrap_add_args (proxy_arg_bwrap,\n                          a11y_address,\n                          proxy_socket, \"--filter\", \"--sloppy-names\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Socket.Embed@/org/a11y/atspi/accessible/root\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Socket.Unembed@/org/a11y/atspi/accessible/root\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Registry.GetRegisteredEvents@/org/a11y/atspi/registry\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.GetKeystrokeListeners@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.GetDeviceEventListeners@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.NotifyListenersSync@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.NotifyListenersAsync@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          NULL);\n\n  if ((flags & FLATPAK_RUN_FLAG_LOG_A11Y_BUS) != 0)\n    flatpak_bwrap_add_args (proxy_arg_bwrap, \"--log\", NULL);\n\n  flatpak_bwrap_add_args (app_bwrap,\n                          \"--ro-bind\", proxy_socket, sandbox_socket_path,\n                          NULL);\n  flatpak_bwrap_set_env (app_bwrap, \"AT_SPI_BUS_ADDRESS\", sandbox_dbus_address, TRUE);\n\n  return TRUE;\n}", "func_hash": 282079552169776334048443104755770351266, "file_name": "flatpak-run.c", "file_hash": 32398709380082441128978861691951488575, "cwe": ["CWE-20"], "cve": "CVE-2021-41133", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41133"}
{"idx": 222508, "project": "tensorflow", "commit_id": "3d89911481ba6ebe8c88c1c0b595412121e6c645", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/3d89911481ba6ebe8c88c1c0b595412121e6c645", "commit_message": "Eliminate `CHECK`-fail from `function.cc`.\n\nPiperOrigin-RevId: 409414744\nChange-Id: Ic854e12ab2edb88b165d32e2d632c4ee654d71ad", "target": 0, "func": "FunctionDef FunctionDefHelper::Create(\n    const string& function_name, gtl::ArraySlice<string> in_def,\n    gtl::ArraySlice<string> out_def, gtl::ArraySlice<string> attr_def,\n    gtl::ArraySlice<Node> node_def,\n    gtl::ArraySlice<std::pair<string, string>> ret_def,\n    gtl::ArraySlice<std::pair<string, string>> control_ret_def) {\n  FunctionDef fdef;\n\n  // Signature\n  OpDefBuilder b(function_name);\n  for (const auto& i : in_def) b.Input(i);\n  for (const auto& o : out_def) b.Output(o);\n  for (const auto& a : attr_def) b.Attr(a);\n  for (const auto& c : control_ret_def) b.ControlOutput(c.first);\n\n  OpRegistrationData op_reg_data;\n  TF_CHECK_OK(b.Finalize(&op_reg_data));\n  fdef.mutable_signature()->Swap(&op_reg_data.op_def);\n\n  // Function body\n  for (const auto& n : node_def) {\n    *(fdef.add_node_def()) = n.ToNodeDef();\n  }\n\n  // Returns\n  for (const auto& r : ret_def) {\n    fdef.mutable_ret()->insert({r.first, r.second});\n  }\n\n  // Control returns\n  for (const auto& cr : control_ret_def) {\n    fdef.mutable_control_ret()->insert({cr.first, cr.second});\n  }\n\n  auto* op_def_registry = OpRegistry::Global();\n  // Check if any op is stateful.\n  for (const auto& n : node_def) {\n    const OpDef* op_def = nullptr;\n    auto status = op_def_registry->LookUpOpDef(n.op, &op_def);\n    // Lookup can fail if e.g. we are calling a function that was not yet\n    // defined.  If it happens, conservatively assume the op is stateful.\n    if (!status.ok() || op_def->is_stateful()) {\n      fdef.mutable_signature()->set_is_stateful(true);\n    }\n  }\n\n  return fdef;\n}", "func_hash": 235995284183910902350958442533312681104, "file_name": "function.cc", "file_hash": 275755455359751936167516531130081059449, "cwe": ["CWE-617"], "cve": "CVE-2022-23586", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that assertions in `function.cc` would be falsified and crash the Python interpreter. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23586"}
{"idx": 220438, "project": "mruby", "commit_id": "27d1e0132a0804581dca28df042e7047fd27eaa8", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8", "commit_message": "array.c: fix `mrb_ary_shift_m` initialization bug.\n\nThe `ARY_PTR` and `ARY_LEN` may be modified in `mrb_get_args`.", "target": 0, "func": "mrb_ary_first(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int size, alen;\n\n  if (mrb_get_argc(mrb) == 0) {\n    return (ARY_LEN(a) > 0)? ARY_PTR(a)[0]: mrb_nil_value();\n  }\n  mrb_get_args(mrb, \"|i\", &size);\n  if (size < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array size\");\n  }\n\n  alen = ARY_LEN(a);\n  if (size > alen) size = alen;\n  if (ARY_SHARED_P(a)) {\n    return ary_subseq(mrb, a, 0, size);\n  }\n  return mrb_ary_new_from_values(mrb, size, ARY_PTR(a));\n}", "func_hash": 245212261499229275322726486456569545083, "file_name": "array.c", "file_hash": 295526445825727607536544634773604768998, "cwe": ["CWE-476"], "cve": "CVE-2021-4188", "cve_desc": "mruby is vulnerable to NULL Pointer Dereference", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4188"}
{"idx": 221130, "project": "gpac", "commit_id": "a69b567b8c95c72f9560c873c5ab348be058f340", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340", "commit_message": "fixed #1895", "target": 0, "func": "GF_Err gf_odf_ac3_config_parse(u8 *dsi, u32 dsi_len, Bool is_ec3, GF_AC3Config *cfg)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tif (!cfg || !dsi) return GF_BAD_PARAM;\n\tbs = gf_bs_new(dsi, dsi_len, GF_BITSTREAM_READ);\n\te = gf_odf_ac3_config_parse_bs(bs, is_ec3, cfg);\n\tgf_bs_del(bs);\n\treturn e;\n}", "func_hash": 128135411382207720911084877738167234309, "file_name": "descriptors.c", "file_hash": 86476492964393375980272696403064975409, "cwe": ["CWE-415"], "cve": "CVE-2021-40571", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40571"}
{"idx": 221156, "project": "gpac", "commit_id": "a69b567b8c95c72f9560c873c5ab348be058f340", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340", "commit_message": "fixed #1895", "target": 0, "func": "void gf_odf_av1_cfg_del(GF_AV1Config *cfg)\n{\n\tif (!cfg) return;\n\twhile (gf_list_count(cfg->obu_array)) {\n\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_get(cfg->obu_array, 0);\n\t\tif (a->obu) gf_free(a->obu);\n\t\tgf_list_rem(cfg->obu_array, 0);\n\t\tgf_free(a);\n\t}\n\tgf_list_del(cfg->obu_array);\n\tgf_free(cfg);\n}", "func_hash": 212415737653710812306488227579778279094, "file_name": "descriptors.c", "file_hash": 86476492964393375980272696403064975409, "cwe": ["CWE-415"], "cve": "CVE-2021-40571", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40571"}
{"idx": 219978, "project": "glewlwyd", "commit_id": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "project_url": "https://github.com/babelouest/glewlwyd", "commit_url": "https://github.com/babelouest/glewlwyd/commit/125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "commit_message": "Fix update session when auth fail", "target": 0, "func": "int callback_glewlwyd_get_plugin_module (const struct _u_request * request, struct _u_response * response, void * plugin_data) {\n  struct config_elements * config = (struct config_elements *)plugin_data;\n  json_t * j_module;\n  \n  j_module = get_plugin_module(config, u_map_get(request->map_url, \"name\"));\n  if (check_result_value(j_module, G_OK)) {\n    ulfius_set_json_body_response(response, 200, json_object_get(j_module, \"module\"));\n  } else if (check_result_value(j_module, G_ERROR_NOT_FOUND)) {\n    response->status = 404;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_get_plugin_module - Error get_plugin_module\");\n    response->status = 500;\n  }\n  json_decref(j_module);\n  return U_CALLBACK_CONTINUE;\n}", "func_hash": 44890175337828347748730215226262843916, "file_name": "webservice.c", "file_hash": 287798817606377336444620654835011177393, "cwe": ["CWE-287"], "cve": "CVE-2021-45379", "cve_desc": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-45379"}
{"idx": 221078, "project": "gpac", "commit_id": "f1ae01d745200a258cdf62622f71754c37cb6c30", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/f1ae01d745200a258cdf62622f71754c37cb6c30", "commit_message": "fixed #1900", "target": 0, "func": "u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)\n{\n\tu32 val=0, code;\n\ts32 nb_lead = -1;\n\tu32 bits = 0;\n\tfor (code=0; !code; nb_lead++) {\n\t\tif (nb_lead>=32) {\n\t\t\tbreak;\n\t\t}\n\t\tcode = gf_bs_read_int(bs, 1);\n\t\tbits++;\n\t}\n\n\tif (nb_lead>=32) {\n\t\t//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)\n\t\t//we only test once nb_lead>=32 to avoid testing at each bit read\n\t\tif (!gf_bs_available(bs)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (nb_lead) {\n\t\tu32 leads=1;\n\t\tval = gf_bs_read_int(bs, nb_lead);\n\t\tleads <<= nb_lead;\n\t\tleads -= 1;\n\t\tval += leads;\n//\t\tval += (1 << nb_lead) - 1;\n\t\tbits += nb_lead;\n\t}\n\n\tif (fname) {\n\t\tgf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);\n\t}\n\treturn val;\n}", "func_hash": 234778334008962271558217086704071657173, "file_name": "av_parsers.c", "file_hash": 336095072032702615903888752582747164805, "cwe": ["CWE-120"], "cve": "CVE-2021-40568", "cve_desc": "A buffer overflow vulnerability exists in Gpac through 1.0.1 via a malformed MP4 file in the svc_parse_slice function in av_parsers.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40568"}
{"idx": 90214, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual bool ethernet_connecting() const { return false; }\n", "func_hash": 97883714936450999128875407444974195924, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 220171, "project": "tensorflow", "commit_id": "ab51e5b813573dc9f51efa335aebcf2994125ee9", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/ab51e5b813573dc9f51efa335aebcf2994125ee9", "commit_message": "Prevent memory leak in decoding PNG images.\n\nPiperOrigin-RevId: 409300653\nChange-Id: I6182124c545989cef80cefd439b659095920763b", "target": 0, "func": "  void Compute(OpKernelContext* context) override {\n    const Tensor& contents = context->input(0);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(contents.shape()),\n        errors::InvalidArgument(\"`contents` must be scalar but got shape\",\n                                contents.shape().DebugString()));\n    const StringPiece input = contents.scalar<tstring>()();\n    OP_REQUIRES(context, !input.empty(),\n                errors::InvalidArgument(\"Input is empty.\"));\n    OP_REQUIRES(context, input.size() <= std::numeric_limits<int>::max(),\n                errors::InvalidArgument(\n                    \"Input contents are too large for int: \", input.size()));\n\n    // Parse magic bytes to determine file format.\n    switch (ClassifyFileFormat(input)) {\n      case kJpgFormat:\n        DecodeJpegV2(context, input);\n        break;\n      case kPngFormat:\n        DecodePngV2(context, input);\n        break;\n      case kGifFormat:\n        DecodeGifV2(context, input);\n        break;\n      case kBmpFormat:\n        DecodeBmpV2(context, input);\n        break;\n      case kUnknownFormat:\n        OP_REQUIRES(context, false,\n                    errors::InvalidArgument(\"Unknown image file format. One of \"\n                                            \"JPEG, PNG, GIF, BMP required.\"));\n        break;\n    }\n  }", "func_hash": 74919242191136056574997868287016068209, "file_name": "decode_image_op.cc", "file_hash": 250371192243587827698671199962137663449, "cwe": ["CWE-401"], "cve": "CVE-2022-23585", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. When decoding PNG images TensorFlow can produce a memory leak if the image is invalid. After calling `png::CommonInitDecode(..., &decode)`, the `decode` value contains allocated buffers which can only be freed by calling `png::CommonFreeDecode(&decode)`. However, several error case in the function implementation invoke the `OP_REQUIRES` macro which immediately terminates the execution of the function, without allowing for the memory free to occur. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23585"}
{"idx": 221466, "project": "flatpak", "commit_id": "89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "commit_message": "run: Add cross-references for some other seccomp syscall filters\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "target": 0, "func": "flatpak_run_add_wayland_args (FlatpakBwrap *bwrap)\n{\n  const char *wayland_display;\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *wayland_socket = NULL;\n  g_autofree char *sandbox_wayland_socket = NULL;\n  gboolean res = FALSE;\n  struct stat statbuf;\n\n  wayland_display = g_getenv (\"WAYLAND_DISPLAY\");\n  if (!wayland_display)\n    wayland_display = \"wayland-0\";\n\n  wayland_socket = g_build_filename (user_runtime_dir, wayland_display, NULL);\n\n  if (!g_str_has_prefix (wayland_display, \"wayland-\") ||\n      strchr (wayland_display, '/') != NULL)\n    {\n      wayland_display = \"wayland-0\";\n      flatpak_bwrap_set_env (bwrap, \"WAYLAND_DISPLAY\", wayland_display, TRUE);\n    }\n\n  sandbox_wayland_socket = g_strdup_printf (\"/run/flatpak/%s\", wayland_display);\n\n  if (stat (wayland_socket, &statbuf) == 0 &&\n      (statbuf.st_mode & S_IFMT) == S_IFSOCK)\n    {\n      res = TRUE;\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", wayland_socket, sandbox_wayland_socket,\n                              NULL);\n      flatpak_bwrap_add_runtime_dir_member (bwrap, wayland_display);\n    }\n  return res;\n}", "func_hash": 203443370630494053102294994117165025259, "file_name": "flatpak-run.c", "file_hash": 32398709380082441128978861691951488575, "cwe": ["CWE-20"], "cve": "CVE-2021-41133", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41133"}
{"idx": 220464, "project": "tensorflow", "commit_id": "e21af685e1828f7ca65038307df5cc06de4479e8", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/e21af685e1828f7ca65038307df5cc06de4479e8", "commit_message": "Fix Null-pointer dereference in BuildXlaCompilationCache\n\nIf ConfigProto is not used, then use the default settings which is to allow all devices.\n\nPiperOrigin-RevId: 420391800\nChange-Id: I88161ad7042990aef678e77b597a2fb2c8f815be", "target": 0, "func": "std::shared_ptr<se::DeviceMemoryAllocator> GetAllocator(\n    DeviceBase* device, se::Stream* stream,\n    const XlaPlatformInfo& platform_info) {\n  if (platform_info.custom_allocator()) {\n    return platform_info.custom_allocator();\n  }\n  auto* alloc = device->GetAllocator({});\n  if (!stream) {\n    // Stream is not set for the host platform.\n    se::Platform* platform =\n        se::MultiPlatformManager::PlatformWithId(platform_info.platform_id())\n            .ValueOrDie();\n    return std::make_shared<se::TfAllocatorAdapter>(alloc, platform);\n  }\n  return std::make_shared<se::TfAllocatorAdapter>(alloc, stream);\n}", "func_hash": 215947835238715793102467445306044159007, "file_name": "xla_platform_info.cc", "file_hash": 318276067980065095571736754899104138947, "cwe": ["CWE-476"], "cve": "CVE-2022-23595", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. When building an XLA compilation cache, if default settings are used, TensorFlow triggers a null pointer dereference. In the default scenario, all devices are allowed, so `flr->config_proto` is `nullptr`. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23595"}
{"idx": 221644, "project": "hermes", "commit_id": "55e1b2343f4deb1a1b5726cfe1e23b2068217ff2", "project_url": "https://github.com/facebook/hermes", "commit_url": "https://github.com/facebook/hermes/commit/55e1b2343f4deb1a1b5726cfe1e23b2068217ff2", "commit_message": "Handle typeof applied to empty in InstSimplify\n\nSummary:\nDo not simplify `typeof` if it is applied to an invalid type. This\nhandles a case like the one in the added test, where `typeof` is called\non a literal empty in unreachable code.\n\nReviewed By: kodafb\n\nDifferential Revision: D31000173\n\nfbshipit-source-id: 2d7f69cbcc9c1bb0a916585c07171089444c85dc", "target": 0, "func": "bool hermes::evalIsTrue(IRBuilder &builder, Literal *operand) {\n  if (auto *lit = evalToBoolean(builder, operand))\n    return lit->getValue();\n  return false;\n}", "func_hash": 98153917199842898373603808618995317497, "file_name": "IREval.cpp", "file_hash": 42961914778696217563735135747458181955, "cwe": ["CWE-843"], "cve": "CVE-2021-24045", "cve_desc": "A type confusion vulnerability could be triggered when resolving the \"typeof\" unary operator in Facebook Hermes prior to v0.10.0. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-24045"}
{"idx": 101680, "project": "Chrome", "commit_id": "2bfb2b8299e2fb6a432390a93a99a85fed1d29c9", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/2bfb2b8299e2fb6a432390a93a99a85fed1d29c9", "commit_message": "None", "target": 0, "func": "bool WebProcessProxy::fullKeyboardAccessEnabled()\n{\n    return false;\n}\n", "func_hash": 304359859513965936787195250639141969459, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 211181, "project": "php-src", "commit_id": "a72cd07f2983dc43a6bb35209dc4687852e53c09", "project_url": "https://github.com/php/php-src", "commit_url": "http://git.php.net/?p=php-src.git;a=commit;h=a72cd07f2983dc43a6bb35209dc4687852e53c09", "commit_message": "Fixed bug #68665 (Invalid free)", "target": 1, "func": "apprentice_load(struct magic_set *ms, const char *fn, int action)\n{\n\tint errs = 0;\n\tuint32_t i, j;\n\tsize_t files = 0, maxfiles = 0;\n\tchar **filearr = NULL;\n\tstruct stat st;\n\tstruct magic_map *map;\n\tstruct magic_entry_set mset[MAGIC_SETS];\n\tphp_stream *dir;\n\tphp_stream_dirent d;\n \n\tTSRMLS_FETCH();\n\n\tmemset(mset, 0, sizeof(mset));\n\tms->flags |= MAGIC_CHECK;\t/* Enable checks for parsed files */\n\n\n\tif ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL)\n\t{\n\t\tfile_oomem(ms, sizeof(*map));\n\t\treturn NULL;\n\t}\n\n\t/* print silly verbose header for USG compat. */\n\tif (action == FILE_CHECK)\n\t\t(void)fprintf(stderr, \"%s\\n\", usg_hdr);\n\n\t/* load directory or file */\n\t/* FIXME: Read file names and sort them to prevent\n\t   non-determinism. See Debian bug #488562. */\n\tif (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {\n\t\tint mflen;\n\t\tchar mfn[MAXPATHLEN];\n\n\t\tdir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);\n\t\tif (!dir) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t\twhile (php_stream_readdir(dir, &d)) {\n\t\t\tif ((mflen = snprintf(mfn, sizeof(mfn), \"%s/%s\", fn, d.d_name)) < 0) {\n\t\t\t\tfile_oomem(ms,\n\t\t\t\tstrlen(fn) + strlen(d.d_name) + 2);\n\t\t\t\terrs++;\n\t\t\t\tphp_stream_closedir(dir);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (files >= maxfiles) {\n\t\t\t\tsize_t mlen;\n\t\t\t\tmaxfiles = (maxfiles + 1) * 2;\n\t\t\t\tmlen = maxfiles * sizeof(*filearr);\n\t\t\t\tif ((filearr = CAST(char **,\n\t\t\t\t    erealloc(filearr, mlen))) == NULL) {\n\t\t\t\t\tfile_oomem(ms, mlen);\n\t\t\t\t\tefree(mfn);\n\t\t\t\t\tphp_stream_closedir(dir);\n\t\t\t\t\terrs++;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfilearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen);\n\t\t}\n\t\tphp_stream_closedir(dir);\n\t\tqsort(filearr, files, sizeof(*filearr), cmpstrp);\n\t\tfor (i = 0; i < files; i++) {\n\t\t\tload_1(ms, action, filearr[i], &errs, mset);\n\t\t\tefree(filearr[i]);\n\t\t}\n\t\tefree(filearr);\n\t} else\n\t\tload_1(ms, action, fn, &errs, mset);\n\tif (errs)\n\t\tgoto out;\n\n\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t/* Set types of tests */\n\t\tfor (i = 0; i < mset[j].count; ) {\n\t\t\tif (mset[j].me[i].mp->cont_level != 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = set_text_binary(ms, mset[j].me, mset[j].count, i);\n\t\t}\n\t\tqsort(mset[j].me, mset[j].count, sizeof(*mset[j].me),\n\t\t    apprentice_sort);\n\n\t\t/*\n\t\t * Make sure that any level 0 \"default\" line is last\n\t\t * (if one exists).\n\t\t */\n\t\tset_last_default(ms, mset[j].me, mset[j].count);\n\n\t\t/* coalesce per file arrays into a single one */\n\t\tif (coalesce_entries(ms, mset[j].me, mset[j].count,\n\t\t    &map->magic[j], &map->nmagic[j]) == -1) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfor (j = 0; j < MAGIC_SETS; j++)\n\t\tmagic_entry_free(mset[j].me, mset[j].count);\n\n\tif (errs) {\n\t\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t\tif (map->magic[j])\n\t\t\t\tefree(map->magic[j]);\n\t\t}\n\t\tefree(map);\n\t\treturn NULL;\n\t}\n\treturn map;\n}", "func_hash": 215852170840415887446784967790257485070, "file_name": "apprentice.c", "file_hash": 136822894511518552455761565191570256868, "cwe": ["CWE-17"], "cve": "CVE-2014-9426", "cve_desc": "The apprentice_load function in libmagic/apprentice.c in the Fileinfo component in PHP through 5.6.4 attempts to perform a free operation on a stack-based character array, which allows remote attackers to cause a denial of service (memory corruption or application crash) or possibly have unspecified other impact via unknown vectors.  NOTE: this is disputed by the vendor because the standard erealloc behavior makes the free operation unreachable", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9426"}
{"idx": 90772, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "void QuotaManager::GetGlobalUsage(\n    StorageType type,\n    GlobalUsageCallback* callback) {\n  LazyInitialize();\n  GetUsageTracker(type)->GetGlobalUsage(callback);\n}\n", "func_hash": 191323255900110242792556979411512288875, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 195391, "project": "tensorflow", "commit_id": "f68fdab93fb7f4ddb4eb438c8fe052753c9413e8", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/f68fdab93fb7f4ddb4eb438c8fe052753c9413e8", "commit_message": "Add a check for pad width to be a positive value.\n\nPiperOrigin-RevId: 413275853\nChange-Id: I261a8db9dabf5ce48a806a9e58129080c9fac619", "target": 1, "func": "  void Compute(tensorflow::OpKernelContext* context) override {\n    for (int ngram_width : ngram_widths_) {\n      OP_REQUIRES(\n          context, ngram_width > 0,\n          errors::InvalidArgument(\"ngram_widths must contain positive values\"));\n    }\n\n    const tensorflow::Tensor* data;\n    OP_REQUIRES_OK(context, context->input(\"data\", &data));\n    const auto& input_data = data->flat<tstring>().data();\n\n    const tensorflow::Tensor* splits;\n    OP_REQUIRES_OK(context, context->input(\"data_splits\", &splits));\n    const auto& splits_vec = splits->flat<SPLITS_TYPE>();\n\n    // Validate that the splits are valid indices into data, only if there are\n    // splits specified.\n    const int input_data_size = data->flat<tstring>().size();\n    const int splits_vec_size = splits_vec.size();\n    if (splits_vec_size > 0) {\n      int prev_split = splits_vec(0);\n      OP_REQUIRES(context, prev_split == 0,\n                  errors::InvalidArgument(\"First split value must be 0, got \",\n                                          prev_split));\n      for (int i = 1; i < splits_vec_size; ++i) {\n        bool valid_splits = splits_vec(i) >= prev_split;\n        valid_splits = valid_splits && (splits_vec(i) <= input_data_size);\n        OP_REQUIRES(context, valid_splits,\n                    errors::InvalidArgument(\n                        \"Invalid split value \", splits_vec(i), \", must be in [\",\n                        prev_split, \", \", input_data_size, \"]\"));\n        prev_split = splits_vec(i);\n      }\n      OP_REQUIRES(context, prev_split == input_data_size,\n                  errors::InvalidArgument(\n                      \"Last split value must be data size. Expected \",\n                      input_data_size, \", got \", prev_split));\n    }\n\n    int num_batch_items = splits_vec.size() - 1;\n    tensorflow::Tensor* ngrams_splits;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(1, splits->shape(), &ngrams_splits));\n    auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data();\n\n    // If there is no data or size, return an empty RT.\n    if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) {\n      tensorflow::Tensor* empty;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, data->shape(), &empty));\n      for (int i = 0; i <= num_batch_items; ++i) {\n        ngrams_splits_data[i] = 0;\n      }\n      return;\n    }\n\n    ngrams_splits_data[0] = 0;\n    for (int i = 1; i <= num_batch_items; ++i) {\n      int length = splits_vec(i) - splits_vec(i - 1);\n      int num_ngrams = 0;\n      for (int ngram_width : ngram_widths_)\n        num_ngrams += get_num_ngrams(length, ngram_width);\n      if (preserve_short_ && length > 0 && num_ngrams == 0) {\n        num_ngrams = 1;\n      }\n      ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams;\n    }\n\n    tensorflow::Tensor* ngrams;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams));\n    auto ngrams_data = ngrams->flat<tstring>().data();\n\n    for (int i = 0; i < num_batch_items; ++i) {\n      auto data_start = &input_data[splits_vec(i)];\n      int output_start_idx = ngrams_splits_data[i];\n      for (int ngram_width : ngram_widths_) {\n        auto output_start = &ngrams_data[output_start_idx];\n        int length = splits_vec(i + 1) - splits_vec(i);\n        int num_ngrams = get_num_ngrams(length, ngram_width);\n        CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n        output_start_idx += num_ngrams;\n      }\n      // If we're preserving short sequences, check to see if no sequence was\n      // generated by comparing the current output start idx to the original\n      // one (ngram_splits_data). If no ngrams were generated, then they will\n      // be equal (since we increment output_start_idx by num_ngrams every\n      // time we create a set of ngrams.)\n      if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) {\n        int data_length = splits_vec(i + 1) - splits_vec(i);\n        // One legitimate reason to not have any ngrams when preserve_short_\n        // is true is if the sequence itself is empty. In that case, move on.\n        if (data_length == 0) {\n          continue;\n        }\n        // We don't have to worry about dynamic padding sizes here: if padding\n        // was dynamic, every sequence would have had sufficient padding to\n        // generate at least one ngram.\n        int ngram_width = data_length + 2 * pad_width_;\n        auto output_start = &ngrams_data[output_start_idx];\n        int num_ngrams = 1;\n        CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n      }\n    }\n  }", "func_hash": 93012019628610956612764593105283326156, "file_name": "string_ngrams_op.cc", "file_hash": 245905885483763938680185872776744444218, "cwe": ["CWE-190"], "cve": "CVE-2022-21733", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `StringNGrams` can be used to trigger a denial of service attack by causing an out of memory condition after an integer overflow. We are missing a validation on `pad_witdh` and that result in computing a negative value for `ngram_width` which is later used to allocate parts of the output. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-21733"}
{"idx": 220465, "project": "tensorflow", "commit_id": "e21af685e1828f7ca65038307df5cc06de4479e8", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/e21af685e1828f7ca65038307df5cc06de4479e8", "commit_message": "Fix Null-pointer dereference in BuildXlaCompilationCache\n\nIf ConfigProto is not used, then use the default settings which is to allow all devices.\n\nPiperOrigin-RevId: 420391800\nChange-Id: I88161ad7042990aef678e77b597a2fb2c8f815be", "target": 0, "func": "xla::StatusOr<absl::optional<std::set<int>>> ParseVisibleDeviceList(\n    absl::string_view visible_device_list) {\n  std::set<int> gpu_ids;\n  if (visible_device_list.empty()) {\n    return {{absl::nullopt}};\n  }\n  const std::vector<string> visible_devices =\n      absl::StrSplit(visible_device_list, ',');\n  for (const string& platform_device_id_str : visible_devices) {\n    int32_t platform_device_id;\n    if (!absl::SimpleAtoi(platform_device_id_str, &platform_device_id)) {\n      return errors::InvalidArgument(\n          \"Could not parse entry in 'visible_device_list': '\",\n          platform_device_id_str,\n          \"'. visible_device_list = \", visible_device_list);\n    }\n    gpu_ids.insert(platform_device_id);\n  }\n  return {{gpu_ids}};\n}", "func_hash": 128234779456301264317468481318675310772, "file_name": "xla_platform_info.cc", "file_hash": 318276067980065095571736754899104138947, "cwe": ["CWE-476"], "cve": "CVE-2022-23595", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. When building an XLA compilation cache, if default settings are used, TensorFlow triggers a null pointer dereference. In the default scenario, all devices are allowed, so `flr->config_proto` is `nullptr`. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23595"}
{"idx": 176403, "project": "Chrome", "commit_id": "45bae236b03f577ed6682ef4c7ef3ee006de5e5a", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/45bae236b03f577ed6682ef4c7ef3ee006de5e5a", "commit_message": "None", "target": 0, "func": "void AddDeleteUninstallShortcutsForMSIWorkItems(\n    const InstallerState& installer_state,\n    const Product& product,\n    const FilePath& temp_path,\n    WorkItemList* work_item_list) {\n  DCHECK(installer_state.is_msi())\n      << \"This must only be called for MSI installations!\";\n\n  HKEY reg_root = installer_state.root_key();\n  std::wstring uninstall_reg(product.distribution()->GetUninstallRegPath());\n\n  WorkItem* delete_reg_key = work_item_list->AddDeleteRegKeyWorkItem(\n      reg_root, uninstall_reg);\n  delete_reg_key->set_ignore_failure(true);\n\n  FilePath uninstall_link;\n  if (installer_state.system_install()) {\n    PathService::Get(base::DIR_COMMON_START_MENU, &uninstall_link);\n  } else {\n    PathService::Get(base::DIR_START_MENU, &uninstall_link);\n  }\n\n  if (uninstall_link.empty()) {\n    LOG(ERROR) << \"Failed to get location for shortcut.\";\n  } else {\n    uninstall_link = uninstall_link.Append(\n        product.distribution()->GetAppShortCutName());\n    uninstall_link = uninstall_link.Append(\n        product.distribution()->GetUninstallLinkName() + L\".lnk\");\n    VLOG(1) << \"Deleting old uninstall shortcut (if present): \"\n            << uninstall_link.value();\n    WorkItem* delete_link = work_item_list->AddDeleteTreeWorkItem(\n        uninstall_link, temp_path);\n    delete_link->set_ignore_failure(true);\n    delete_link->set_log_message(\n        \"Failed to delete old uninstall shortcut.\");\n  }\n}\n", "func_hash": 204840863584258047852537690933239743192, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90756, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  void DidGetGlobalQuota(QuotaStatusCode status,\n                         StorageType type,\n                         int64 quota) {\n    DCHECK_EQ(type_, type);\n    quota_status_ = status;\n    quota_ = quota;\n    CheckCompleted();\n  }\n", "func_hash": 67619737782262437040030552175594518304, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 205570, "project": "radare2", "commit_id": "153bcdc29f11cd8c90e7d639a7405450f644ddb6", "project_url": "https://github.com/radare/radare2", "commit_url": "https://github.com/radareorg/radare2/commit/153bcdc29f11cd8c90e7d639a7405450f644ddb6", "commit_message": "Fix oobread in NE parser ##crash\n\n* Reported by @hmsec via huntr.dev\n* Reproducer: necrash\n* BountyID: 52b57274-0e1a-4d61-ab29-1373b555fea0/", "target": 1, "func": "RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n\tRList *segments = bin->segments;\n\tif (!segments) {\n\t\treturn NULL;\n\t}\n\tRList *entries = bin->entries;\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *symbols = bin->symbols;\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\n\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));\n\tif (!modref) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *relocs = r_list_newf (free);\n\tif (!relocs) {\n\t\tfree (modref);\n\t\treturn NULL;\n\t}\n\n\tRListIter *it;\n\tRBinSection *seg;\n\tint index = -1;\n\tr_list_foreach (segments, it, seg) {\n\t\tindex++;\n\t\tif (!(bin->segment_entries[index].flags & RELOCINFO)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 off = seg->paddr + seg->size;\n\t\tut32 start = off;\n\t\tut16 length = r_buf_read_le16_at (bin->buf, off);\n\t\tif (!length) {\n\t\t\tcontinue;\n\t\t}\n\t\toff += 2;\n\t\t// size_t buf_size = r_buf_size (bin->buf);\n\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {\n\t\t\t// && off + sizeof (NE_image_reloc_item) < buf_size)\n\t\t\tNE_image_reloc_item rel = {0};\n\t\t\tif (r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel)) < 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treloc->paddr = seg->paddr + rel.offset;\n\t\t\tswitch (rel.type) {\n\t\t\tcase LOBYTE:\n\t\t\t\treloc->type = R_BIN_RELOC_8;\n\t\t\t\tbreak;\n\t\t\tcase SEL_16:\n\t\t\tcase OFF_16:\n\t\t\t\treloc->type = R_BIN_RELOC_16;\n\t\t\t\tbreak;\n\t\t\tcase POI_32:\n\t\t\tcase OFF_32:\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\tbreak;\n\t\t\tcase POI_48:\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 offset;\n\t\t\tif (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\tif (!imp) {\n\t\t\t\t\tfree (reloc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name;\n#if NE_BUG\n\t\t\t\tif (rel.index > 0 && rel.index < bin->ne_header->ModRefs) {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t} else {\n\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\t\t\t\t}\n#else\n\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {\n\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\t\t\t\t} else {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t}\n#endif\n\t\t\t\tif (rel.flags & IMPORTED_ORD) {\n\t\t\t\t\timp->ordinal = rel.func_ord;\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, __func_name_from_ord(name, rel.func_ord));\n\t\t\t\t} else {\n\t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;\n\t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, func);\n\t\t\t\t\tfree (func);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t\treloc->import = imp;\n\t\t\t} else if (rel.flags & OSFIXUP) {\n\t\t\t\t// TODO\n\t\t\t} else {\n\t\t\t\tif (strstr (seg->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *s = r_list_get_n (segments, rel.segnum - 1);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\toffset = s->paddr + rel.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\toffset = entry->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treloc->addend = offset;\n\t\t\t\tRBinSymbol *sym = NULL;\n\t\t\t\tRListIter *sit;\n\t\t\t\tr_list_foreach (symbols, sit, sym) {\n\t\t\t\t\tif (sym->paddr == reloc->addend) {\n\t\t\t\t\t\treloc->symbol = sym;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rel.flags & ADDITIVE) {\n\t\t\t\treloc->additive = 1;\n\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tdo {\n#if NE_BUG\n\t\t\t\t\tif (reloc->paddr + 4 < r_buf_size (bin->buf)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t\t\toffset = r_buf_read_le16_at (bin->buf, reloc->paddr);\n\t\t\t\t\tRBinReloc *tmp = reloc;\n\t\t\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*reloc = *tmp;\n\t\t\t\t\treloc->paddr = seg->paddr + offset;\n\t\t\t\t} while (offset != 0xFFFF);\n\t\t\t\tfree (reloc);\n\t\t\t}\n\n\t\t\toff += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tfree (modref);\n\treturn relocs;\n}", "func_hash": 235256022967149910602166555745478875317, "file_name": "ne.c", "file_hash": 246713186736928904180015449024557971547, "cwe": ["CWE-125"], "cve": "CVE-2022-1296", "cve_desc": "Out-of-bounds read in `r_bin_ne_get_relocs` function in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability may allow attackers to read sensitive information or cause a crash.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1296"}
{"idx": 139251, "project": "Chrome", "commit_id": "fb83de09f2c986ee91741f3a2776feea0e18e3f6", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/fb83de09f2c986ee91741f3a2776feea0e18e3f6", "commit_message": "None", "target": 0, "func": "void OverlayWindowViews::UpdateCustomControlsSize(\n    views::ControlImageButton* control_button) {\n  if (!control_button)\n    return;\n  UpdateButtonSize();\n  control_button->SetSize(button_size_);\n  if (control_button == first_custom_controls_view_.get()) {\n    first_custom_controls_view_->SetImage(\n        views::Button::STATE_NORMAL,\n        gfx::CreateVectorIcon(vector_icons::kPlayArrowIcon,\n                              button_size_.width() / 2, kControlIconColor));\n  }\n  if (control_button == second_custom_controls_view_.get()) {\n    second_custom_controls_view_->SetImage(\n        views::Button::STATE_NORMAL,\n        gfx::CreateVectorIcon(vector_icons::kPauseIcon,\n                              button_size_.width() / 2, kControlIconColor));\n  }\n  const gfx::ImageSkia control_background = gfx::CreateVectorIcon(\n      kPictureInPictureControlBackgroundIcon, button_size_.width(), kBgColor);\n  control_button->SetBackgroundImage(kBgColor, &control_background,\n                                     &control_background);\n}\n", "func_hash": 295427637911053551225136020369886556579, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 195385, "project": "flatpak", "commit_id": "65cbfac982cb1c83993a9e19aa424daee8e9f042", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/65cbfac982cb1c83993a9e19aa424daee8e9f042", "commit_message": "Ensure that bundles have metadata on install\n\nIf we have a bundle without metadata we wouldn't properly present\nthe permissions in the transaction.", "target": 1, "func": "flatpak_dir_ensure_bundle_remote (FlatpakDir         *self,\n                                  GFile              *file,\n                                  GBytes             *extra_gpg_data,\n                                  FlatpakDecomposed **out_ref,\n                                  char              **out_checksum,\n                                  char              **out_metadata,\n                                  gboolean           *out_created_remote,\n                                  GCancellable       *cancellable,\n                                  GError            **error)\n{\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  gboolean created_remote = FALSE;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(GVariant) metadata = NULL;\n  g_autofree char *origin = NULL;\n  g_autofree char *fp_metadata = NULL;\n  g_autofree char *basename = NULL;\n  g_autoptr(GBytes) included_gpg_data = NULL;\n  GBytes *gpg_data = NULL;\n  g_autofree char *to_checksum = NULL;\n  g_autofree char *remote = NULL;\n  g_autofree char *collection_id = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  metadata = flatpak_bundle_load (file, &to_checksum,\n                                  &ref,\n                                  &origin,\n                                  NULL, &fp_metadata, NULL,\n                                  &included_gpg_data,\n                                  &collection_id,\n                                  error);\n  if (metadata == NULL)\n    return NULL;\n\n  gpg_data = extra_gpg_data ? extra_gpg_data : included_gpg_data;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY, cancellable, NULL);\n  if (deploy_data != NULL)\n    {\n      remote = g_strdup (flatpak_deploy_data_get_origin (deploy_data));\n\n      /* We need to import any gpg keys because otherwise the pull will fail */\n      if (gpg_data != NULL)\n        {\n          g_autoptr(GKeyFile) new_config = NULL;\n\n          new_config = ostree_repo_copy_config (flatpak_dir_get_repo (self));\n\n          if (!flatpak_dir_modify_remote (self, remote, new_config,\n                                          gpg_data, cancellable, error))\n            return NULL;\n        }\n    }\n  else\n    {\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n      /* Add a remote for later updates */\n      basename = g_file_get_basename (file);\n      remote = flatpak_dir_create_origin_remote (self,\n                                                 origin,\n                                                 id,\n                                                 basename,\n                                                 flatpak_decomposed_get_ref (ref),\n                                                 gpg_data,\n                                                 collection_id,\n                                                 &created_remote,\n                                                 cancellable,\n                                                 error);\n      if (remote == NULL)\n        return NULL;\n    }\n\n  if (out_created_remote)\n    *out_created_remote = created_remote;\n\n  if (out_ref)\n    *out_ref = g_steal_pointer (&ref);\n\n  if (out_checksum)\n    *out_checksum = g_steal_pointer (&to_checksum);\n\n  if (out_metadata)\n    *out_metadata = g_steal_pointer (&fp_metadata);\n\n\n  return g_steal_pointer (&remote);\n}", "func_hash": 117751554146896350574194025697057651898, "file_name": "flatpak-dir.c", "file_hash": 41005800026546918810123079124181990480, "cwe": ["CWE-276"], "cve": "CVE-2021-43860", "cve_desc": "Flatpak is a Linux application sandboxing and distribution framework. Prior to versions 1.12.3 and 1.10.6, Flatpak doesn't properly validate that the permissions displayed to the user for an app at install time match the actual permissions granted to the app at runtime, in the case that there's a null byte in the metadata file of an app. Therefore apps can grant themselves permissions without the consent of the user. Flatpak shows permissions to the user during install by reading them from the \"xa.metadata\" key in the commit metadata. This cannot contain a null terminator, because it is an untrusted GVariant. Flatpak compares these permissions to the *actual* metadata, from the \"metadata\" file to ensure it wasn't lied to. However, the actual metadata contents are loaded in several places where they are read as simple C-style strings. That means that, if the metadata file includes a null terminator, only the content of the file from *before* the terminator gets compared to xa.metadata. Thus, any permissions that appear in the metadata file after a null terminator are applied at runtime but not shown to the user. So maliciously crafted apps can give themselves hidden permissions. Users who have Flatpaks installed from untrusted sources are at risk in case the Flatpak has a maliciously crafted metadata file, either initially or in an update. This issue is patched in versions 1.12.3 and 1.10.6. As a workaround, users can manually check the permissions of installed apps by checking the metadata file or the xa.metadata key on the commit metadata.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-43860"}
{"idx": 200976, "project": "vim", "commit_id": "395bd1f6d3edc9f7edb5d1f2d7deaf5a9e3ab93c", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/395bd1f6d3edc9f7edb5d1f2d7deaf5a9e3ab93c", "commit_message": "patch 8.2.4956: reading past end of line with \"gf\" in Visual block mode\n\nProblem:    Reading past end of line with \"gf\" in Visual block mode.\nSolution:   Do not include the NUL in the length.", "target": 1, "func": "get_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (has_mbyte && *lenp > 0)\n\t    // Correct the length to include all bytes of the last character.\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}", "func_hash": 284497166738290361019440448049627151253, "file_name": "None", "file_hash": null, "cwe": ["CWE-787"], "cve": "CVE-2022-1720", "cve_desc": "Buffer Over-read in function grab_file_name in GitHub repository vim/vim prior to 8.2.4956. This vulnerability is capable of crashing the software, memory modification, and possible remote execution.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1720"}
{"idx": 195388, "project": "postgres", "commit_id": "160c0258802d10b0600d7671b1bbea55d8e17d45", "project_url": "https://github.com/postgres/postgres", "commit_url": "https://github.com/postgres/postgres/commit/160c0258802d10b0600d7671b1bbea55d8e17d45", "commit_message": "libpq: reject extraneous data after SSL or GSS encryption handshake.\n\nlibpq collects up to a bufferload of data whenever it reads data from\nthe socket.  When SSL or GSS encryption is requested during startup,\nany additional data received with the server's yes-or-no reply\nremained in the buffer, and would be treated as already-decrypted data\nonce the encryption handshake completed.  Thus, a man-in-the-middle\nwith the ability to inject data into the TCP connection could stuff\nsome cleartext data into the start of a supposedly encryption-protected\ndatabase session.\n\nThis could probably be abused to inject faked responses to the\nclient's first few queries, although other details of libpq's behavior\nmake that harder than it sounds.  A different line of attack is to\nexfiltrate the client's password, or other sensitive data that might\nbe sent early in the session.  That has been shown to be possible with\na server vulnerable to CVE-2021-23214.\n\nTo fix, throw a protocol-violation error if the internal buffer\nis not empty after the encryption handshake.\n\nOur thanks to Jacob Champion for reporting this problem.\n\nSecurity: CVE-2021-23222", "target": 1, "func": "PQconnectPoll(PGconn *conn)\n{\n\tbool\t\treset_connection_state_machine = false;\n\tbool\t\tneed_new_connection = false;\n\tPGresult   *res;\n\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\tint\t\t\toptval;\n\n\tif (conn == NULL)\n\t\treturn PGRES_POLLING_FAILED;\n\n\t/* Get the new data */\n\tswitch (conn->status)\n\t{\n\t\t\t/*\n\t\t\t * We really shouldn't have been polled in these two cases, but we\n\t\t\t * can handle it.\n\t\t\t */\n\t\tcase CONNECTION_BAD:\n\t\t\treturn PGRES_POLLING_FAILED;\n\t\tcase CONNECTION_OK:\n\t\t\treturn PGRES_POLLING_OK;\n\n\t\t\t/* These are reading states */\n\t\tcase CONNECTION_AWAITING_RESPONSE:\n\t\tcase CONNECTION_AUTH_OK:\n\t\tcase CONNECTION_CHECK_WRITABLE:\n\t\tcase CONNECTION_CONSUME:\n\t\tcase CONNECTION_CHECK_STANDBY:\n\t\t\t{\n\t\t\t\t/* Load waiting data */\n\t\t\t\tint\t\t\tn = pqReadData(conn);\n\n\t\t\t\tif (n < 0)\n\t\t\t\t\tgoto error_return;\n\t\t\t\tif (n == 0)\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* These are writing states, so we just proceed. */\n\t\tcase CONNECTION_STARTED:\n\t\tcase CONNECTION_MADE:\n\t\t\tbreak;\n\n\t\t\t/* Special cases: proceed without waiting. */\n\t\tcase CONNECTION_SSL_STARTUP:\n\t\tcase CONNECTION_NEEDED:\n\t\tcase CONNECTION_GSS_STARTUP:\n\t\tcase CONNECTION_CHECK_TARGET:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t libpq_gettext(\"invalid connection state, probably indicative of memory corruption\\n\"));\n\t\t\tgoto error_return;\n\t}\n\n\nkeep_going:\t\t\t\t\t\t/* We will come back to here until there is\n\t\t\t\t\t\t\t\t * nothing left to do. */\n\n\t/* Time to advance to next address, or next host if no more addresses? */\n\tif (conn->try_next_addr)\n\t{\n\t\tif (conn->addr_cur && conn->addr_cur->ai_next)\n\t\t{\n\t\t\tconn->addr_cur = conn->addr_cur->ai_next;\n\t\t\treset_connection_state_machine = true;\n\t\t}\n\t\telse\n\t\t\tconn->try_next_host = true;\n\t\tconn->try_next_addr = false;\n\t}\n\n\t/* Time to advance to next connhost[] entry? */\n\tif (conn->try_next_host)\n\t{\n\t\tpg_conn_host *ch;\n\t\tstruct addrinfo hint;\n\t\tint\t\t\tthisport;\n\t\tint\t\t\tret;\n\t\tchar\t\tportstr[MAXPGPATH];\n\n\t\tif (conn->whichhost + 1 < conn->nconnhost)\n\t\t\tconn->whichhost++;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Oops, no more hosts.\n\t\t\t *\n\t\t\t * If we are trying to connect in \"prefer-standby\" mode, then drop\n\t\t\t * the standby requirement and start over.\n\t\t\t *\n\t\t\t * Otherwise, an appropriate error message is already set up, so\n\t\t\t * we just need to set the right status.\n\t\t\t */\n\t\t\tif (conn->target_server_type == SERVER_TYPE_PREFER_STANDBY &&\n\t\t\t\tconn->nconnhost > 0)\n\t\t\t{\n\t\t\t\tconn->target_server_type = SERVER_TYPE_PREFER_STANDBY_PASS2;\n\t\t\t\tconn->whichhost = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto error_return;\n\t\t}\n\n\t\t/* Drop any address info for previous host */\n\t\trelease_conn_addrinfo(conn);\n\n\t\t/*\n\t\t * Look up info for the new host.  On failure, log the problem in\n\t\t * conn->errorMessage, then loop around to try the next host.  (Note\n\t\t * we don't clear try_next_host until we've succeeded.)\n\t\t */\n\t\tch = &conn->connhost[conn->whichhost];\n\n\t\t/* Initialize hint structure */\n\t\tMemSet(&hint, 0, sizeof(hint));\n\t\thint.ai_socktype = SOCK_STREAM;\n\t\tconn->addrlist_family = hint.ai_family = AF_UNSPEC;\n\n\t\t/* Figure out the port number we're going to use. */\n\t\tif (ch->port == NULL || ch->port[0] == '\\0')\n\t\t\tthisport = DEF_PGPORT;\n\t\telse\n\t\t{\n\t\t\tif (!parse_int_param(ch->port, &thisport, conn, \"port\"))\n\t\t\t\tgoto error_return;\n\n\t\t\tif (thisport < 1 || thisport > 65535)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"invalid port number: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  ch->port);\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\t\t}\n\t\tsnprintf(portstr, sizeof(portstr), \"%d\", thisport);\n\n\t\t/* Use pg_getaddrinfo_all() to resolve the address */\n\t\tswitch (ch->type)\n\t\t{\n\t\t\tcase CHT_HOST_NAME:\n\t\t\t\tret = pg_getaddrinfo_all(ch->host, portstr, &hint,\n\t\t\t\t\t\t\t\t\t\t &conn->addrlist);\n\t\t\t\tif (ret || !conn->addrlist)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not translate host name \\\"%s\\\" to address: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  ch->host, gai_strerror(ret));\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CHT_HOST_ADDRESS:\n\t\t\t\thint.ai_flags = AI_NUMERICHOST;\n\t\t\t\tret = pg_getaddrinfo_all(ch->hostaddr, portstr, &hint,\n\t\t\t\t\t\t\t\t\t\t &conn->addrlist);\n\t\t\t\tif (ret || !conn->addrlist)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not parse network address \\\"%s\\\": %s\\n\"),\n\t\t\t\t\t\t\t\t\t  ch->hostaddr, gai_strerror(ret));\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CHT_UNIX_SOCKET:\n#ifdef HAVE_UNIX_SOCKETS\n\t\t\t\tconn->addrlist_family = hint.ai_family = AF_UNIX;\n\t\t\t\tUNIXSOCK_PATH(portstr, thisport, ch->host);\n\t\t\t\tif (strlen(portstr) >= UNIXSOCK_PATH_BUFLEN)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"Unix-domain socket path \\\"%s\\\" is too long (maximum %d bytes)\\n\"),\n\t\t\t\t\t\t\t\t\t  portstr,\n\t\t\t\t\t\t\t\t\t  (int) (UNIXSOCK_PATH_BUFLEN - 1));\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * NULL hostname tells pg_getaddrinfo_all to parse the service\n\t\t\t\t * name as a Unix-domain socket path.\n\t\t\t\t */\n\t\t\t\tret = pg_getaddrinfo_all(NULL, portstr, &hint,\n\t\t\t\t\t\t\t\t\t\t &conn->addrlist);\n\t\t\t\tif (ret || !conn->addrlist)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not translate Unix-domain socket path \\\"%s\\\" to address: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  portstr, gai_strerror(ret));\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n#else\n\t\t\t\tAssert(false);\n#endif\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, scan this addrlist for a working server address */\n\t\tconn->addr_cur = conn->addrlist;\n\t\treset_connection_state_machine = true;\n\t\tconn->try_next_host = false;\n\t}\n\n\t/* Reset connection state machine? */\n\tif (reset_connection_state_machine)\n\t{\n\t\t/*\n\t\t * (Re) initialize our connection control variables for a set of\n\t\t * connection attempts to a single server address.  These variables\n\t\t * must persist across individual connection attempts, but we must\n\t\t * reset them when we start to consider a new server.\n\t\t */\n\t\tconn->pversion = PG_PROTOCOL(3, 0);\n\t\tconn->send_appname = true;\n#ifdef USE_SSL\n\t\t/* initialize these values based on SSL mode */\n\t\tconn->allow_ssl_try = (conn->sslmode[0] != 'd');\t/* \"disable\" */\n\t\tconn->wait_ssl_try = (conn->sslmode[0] == 'a'); /* \"allow\" */\n#endif\n#ifdef ENABLE_GSS\n\t\tconn->try_gss = (conn->gssencmode[0] != 'd');\t/* \"disable\" */\n#endif\n\n\t\treset_connection_state_machine = false;\n\t\tneed_new_connection = true;\n\t}\n\n\t/* Force a new connection (perhaps to the same server as before)? */\n\tif (need_new_connection)\n\t{\n\t\t/* Drop any existing connection */\n\t\tpqDropConnection(conn, true);\n\n\t\t/* Reset all state obtained from old server */\n\t\tpqDropServerData(conn);\n\n\t\t/* Drop any PGresult we might have, too */\n\t\tconn->asyncStatus = PGASYNC_IDLE;\n\t\tconn->xactStatus = PQTRANS_IDLE;\n\t\tconn->pipelineStatus = PQ_PIPELINE_OFF;\n\t\tpqClearAsyncResult(conn);\n\n\t\t/* Reset conn->status to put the state machine in the right state */\n\t\tconn->status = CONNECTION_NEEDED;\n\n\t\tneed_new_connection = false;\n\t}\n\n\t/* Now try to advance the state machine for this connection */\n\tswitch (conn->status)\n\t{\n\t\tcase CONNECTION_NEEDED:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Try to initiate a connection to one of the addresses\n\t\t\t\t * returned by pg_getaddrinfo_all().  conn->addr_cur is the\n\t\t\t\t * next one to try.\n\t\t\t\t *\n\t\t\t\t * The extra level of braces here is historical.  It's not\n\t\t\t\t * worth reindenting this whole switch case to remove 'em.\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tstruct addrinfo *addr_cur = conn->addr_cur;\n\t\t\t\t\tchar\t\thost_addr[NI_MAXHOST];\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Advance to next possible host, if we've tried all of\n\t\t\t\t\t * the addresses for the current host.\n\t\t\t\t\t */\n\t\t\t\t\tif (addr_cur == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->try_next_host = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Remember current address for possible use later */\n\t\t\t\t\tmemcpy(&conn->raddr.addr, addr_cur->ai_addr,\n\t\t\t\t\t\t   addr_cur->ai_addrlen);\n\t\t\t\t\tconn->raddr.salen = addr_cur->ai_addrlen;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set connip, too.  Note we purposely ignore strdup\n\t\t\t\t\t * failure; not a big problem if it fails.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->connip != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tfree(conn->connip);\n\t\t\t\t\t\tconn->connip = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgetHostaddr(conn, host_addr, NI_MAXHOST);\n\t\t\t\t\tif (host_addr[0])\n\t\t\t\t\t\tconn->connip = strdup(host_addr);\n\n\t\t\t\t\t/* Try to create the socket */\n\t\t\t\t\tconn->sock = socket(addr_cur->ai_family, SOCK_STREAM, 0);\n\t\t\t\t\tif (conn->sock == PGINVALID_SOCKET)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\terrorno = SOCK_ERRNO;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Silently ignore socket() failure if we have more\n\t\t\t\t\t\t * addresses to try; this reduces useless chatter in\n\t\t\t\t\t\t * cases where the address list includes both IPv4 and\n\t\t\t\t\t\t * IPv6 but kernel only accepts one family.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (addr_cur->ai_next != NULL ||\n\t\t\t\t\t\t\tconn->whichhost + 1 < conn->nconnhost)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t\t}\n\t\t\t\t\t\temitHostIdentityInfo(conn, host_addr);\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not create socket: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(errorno, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Once we've identified a target address, all errors\n\t\t\t\t\t * except the preceding socket()-failure case should be\n\t\t\t\t\t * prefixed with host-identity information.  (If the\n\t\t\t\t\t * connection succeeds, the contents of conn->errorMessage\n\t\t\t\t\t * won't matter, so this is harmless.)\n\t\t\t\t\t */\n\t\t\t\t\temitHostIdentityInfo(conn, host_addr);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Select socket options: no delay of outgoing data for\n\t\t\t\t\t * TCP sockets, nonblock mode, close-on-exec.  Try the\n\t\t\t\t\t * next address if any of this fails.\n\t\t\t\t\t */\n\t\t\t\t\tif (!IS_AF_UNIX(addr_cur->ai_family))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!connectNoDelay(conn))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* error message already created */\n\t\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!pg_set_noblock(conn->sock))\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not set socket to nonblocking mode: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n#ifdef F_SETFD\n\t\t\t\t\tif (fcntl(conn->sock, F_SETFD, FD_CLOEXEC) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not set socket to close-on-exec mode: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* F_SETFD */\n\n\t\t\t\t\tif (!IS_AF_UNIX(addr_cur->ai_family))\n\t\t\t\t\t{\n#ifndef WIN32\n\t\t\t\t\t\tint\t\t\ton = 1;\n#endif\n\t\t\t\t\t\tint\t\t\tusekeepalives = useKeepalives(conn);\n\t\t\t\t\t\tint\t\t\terr = 0;\n\n\t\t\t\t\t\tif (usekeepalives < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"keepalives parameter must be an integer\\n\"));\n\t\t\t\t\t\t\terr = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (usekeepalives == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Do nothing */\n\t\t\t\t\t\t}\n#ifndef WIN32\n\t\t\t\t\t\telse if (setsockopt(conn->sock,\n\t\t\t\t\t\t\t\t\t\t\tSOL_SOCKET, SO_KEEPALIVE,\n\t\t\t\t\t\t\t\t\t\t\t(char *) &on, sizeof(on)) < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"%s(%s) failed: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t  \"setsockopt\",\n\t\t\t\t\t\t\t\t\t\t\t  \"SO_KEEPALIVE\",\n\t\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\t\terr = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!setKeepalivesIdle(conn)\n\t\t\t\t\t\t\t\t || !setKeepalivesInterval(conn)\n\t\t\t\t\t\t\t\t || !setKeepalivesCount(conn))\n\t\t\t\t\t\t\terr = 1;\n#else\t\t\t\t\t\t\t/* WIN32 */\n#ifdef SIO_KEEPALIVE_VALS\n\t\t\t\t\t\telse if (!setKeepalivesWin32(conn))\n\t\t\t\t\t\t\terr = 1;\n#endif\t\t\t\t\t\t\t/* SIO_KEEPALIVE_VALS */\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\t\t\t\telse if (!setTCPUserTimeout(conn))\n\t\t\t\t\t\t\terr = 1;\n\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/*----------\n\t\t\t\t\t * We have three methods of blocking SIGPIPE during\n\t\t\t\t\t * send() calls to this socket:\n\t\t\t\t\t *\n\t\t\t\t\t *\t- setsockopt(sock, SO_NOSIGPIPE)\n\t\t\t\t\t *\t- send(sock, ..., MSG_NOSIGNAL)\n\t\t\t\t\t *\t- setting the signal mask to SIG_IGN during send()\n\t\t\t\t\t *\n\t\t\t\t\t * The third method requires three syscalls per send,\n\t\t\t\t\t * so we prefer either of the first two, but they are\n\t\t\t\t\t * less portable.  The state is tracked in the following\n\t\t\t\t\t * members of PGconn:\n\t\t\t\t\t *\n\t\t\t\t\t * conn->sigpipe_so\t\t- we have set up SO_NOSIGPIPE\n\t\t\t\t\t * conn->sigpipe_flag\t- we're specifying MSG_NOSIGNAL\n\t\t\t\t\t *\n\t\t\t\t\t * If we can use SO_NOSIGPIPE, then set sigpipe_so here\n\t\t\t\t\t * and we're done.  Otherwise, set sigpipe_flag so that\n\t\t\t\t\t * we will try MSG_NOSIGNAL on sends.  If we get an error\n\t\t\t\t\t * with MSG_NOSIGNAL, we'll clear that flag and revert to\n\t\t\t\t\t * signal masking.\n\t\t\t\t\t *----------\n\t\t\t\t\t */\n\t\t\t\t\tconn->sigpipe_so = false;\n#ifdef MSG_NOSIGNAL\n\t\t\t\t\tconn->sigpipe_flag = true;\n#else\n\t\t\t\t\tconn->sigpipe_flag = false;\n#endif\t\t\t\t\t\t\t/* MSG_NOSIGNAL */\n\n#ifdef SO_NOSIGPIPE\n\t\t\t\t\toptval = 1;\n\t\t\t\t\tif (setsockopt(conn->sock, SOL_SOCKET, SO_NOSIGPIPE,\n\t\t\t\t\t\t\t\t   (char *) &optval, sizeof(optval)) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->sigpipe_so = true;\n\t\t\t\t\t\tconn->sigpipe_flag = false;\n\t\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* SO_NOSIGPIPE */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Start/make connection.  This should not block, since we\n\t\t\t\t\t * are in nonblock mode.  If it does, well, too bad.\n\t\t\t\t\t */\n\t\t\t\t\tif (connect(conn->sock, addr_cur->ai_addr,\n\t\t\t\t\t\t\t\taddr_cur->ai_addrlen) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (SOCK_ERRNO == EINPROGRESS ||\n#ifdef WIN32\n\t\t\t\t\t\t\tSOCK_ERRNO == EWOULDBLOCK ||\n#endif\n\t\t\t\t\t\t\tSOCK_ERRNO == EINTR)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * This is fine - we're in non-blocking mode, and\n\t\t\t\t\t\t\t * the connection is in progress.  Tell caller to\n\t\t\t\t\t\t\t * wait for write-ready on socket.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconn->status = CONNECTION_STARTED;\n\t\t\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* otherwise, trouble */\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Hm, we're connected already --- seems the \"nonblock\n\t\t\t\t\t\t * connection\" wasn't.  Advance the state machine and\n\t\t\t\t\t\t * go do the next stuff.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->status = CONNECTION_STARTED;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * This connection failed.  Add the error report to\n\t\t\t\t\t * conn->errorMessage, then try the next address if any.\n\t\t\t\t\t */\n\t\t\t\t\tconnectFailureMessage(conn, SOCK_ERRNO);\n\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase CONNECTION_STARTED:\n\t\t\t{\n\t\t\t\tACCEPT_TYPE_ARG3 optlen = sizeof(optval);\n\n\t\t\t\t/*\n\t\t\t\t * Write ready, since we've made it here, so the connection\n\t\t\t\t * has been made ... or has failed.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Now check (using getsockopt) that there is not an error\n\t\t\t\t * state waiting for us on the socket.\n\t\t\t\t */\n\n\t\t\t\tif (getsockopt(conn->sock, SOL_SOCKET, SO_ERROR,\n\t\t\t\t\t\t\t   (char *) &optval, &optlen) == -1)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not get socket error status: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\t\t\t\telse if (optval != 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * When using a nonblocking connect, we will typically see\n\t\t\t\t\t * connect failures at this point, so provide a friendly\n\t\t\t\t\t * error message.\n\t\t\t\t\t */\n\t\t\t\t\tconnectFailureMessage(conn, optval);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Try the next address if any, just as in the case where\n\t\t\t\t\t * connect() returned failure immediately.\n\t\t\t\t\t */\n\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\n\t\t\t\t/* Fill in the client address */\n\t\t\t\tconn->laddr.salen = sizeof(conn->laddr.addr);\n\t\t\t\tif (getsockname(conn->sock,\n\t\t\t\t\t\t\t\t(struct sockaddr *) &conn->laddr.addr,\n\t\t\t\t\t\t\t\t&conn->laddr.salen) < 0)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not get client address from socket: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make sure we can write before advancing to next step.\n\t\t\t\t */\n\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t}\n\n\t\tcase CONNECTION_MADE:\n\t\t\t{\n\t\t\t\tchar\t   *startpacket;\n\t\t\t\tint\t\t\tpacketlen;\n\n\t\t\t\t/*\n\t\t\t\t * Implement requirepeer check, if requested and it's a\n\t\t\t\t * Unix-domain socket.\n\t\t\t\t */\n\t\t\t\tif (conn->requirepeer && conn->requirepeer[0] &&\n\t\t\t\t\tIS_AF_UNIX(conn->raddr.addr.ss_family))\n\t\t\t\t{\n#ifndef WIN32\n\t\t\t\t\tchar\t\tpwdbuf[BUFSIZ];\n\t\t\t\t\tstruct passwd pass_buf;\n\t\t\t\t\tstruct passwd *pass;\n\t\t\t\t\tint\t\t\tpasserr;\n#endif\n\t\t\t\t\tuid_t\t\tuid;\n\t\t\t\t\tgid_t\t\tgid;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tif (getpeereid(conn->sock, &uid, &gid) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Provide special error message if getpeereid is a\n\t\t\t\t\t\t * stub\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (errno == ENOSYS)\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"requirepeer parameter is not supported on this platform\\n\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not get peer credentials: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t  strerror_r(errno, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n#ifndef WIN32\n\t\t\t\t\tpasserr = pqGetpwuid(uid, &pass_buf, pwdbuf, sizeof(pwdbuf), &pass);\n\t\t\t\t\tif (pass == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (passerr != 0)\n\t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not look up local user ID %d: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t  (int) uid,\n\t\t\t\t\t\t\t\t\t\t\t  strerror_r(passerr, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"local user with ID %d does not exist\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t  (int) uid);\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (strcmp(pass->pw_name, conn->requirepeer) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"requirepeer specifies \\\"%s\\\", but actual peer user name is \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t\t\t  conn->requirepeer, pass->pw_name);\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n#else\t\t\t\t\t\t\t/* WIN32 */\n\t\t\t\t\t/* should have failed with ENOSYS above */\n\t\t\t\t\tAssert(false);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\t\t}\n\n\t\t\t\tif (IS_AF_UNIX(conn->raddr.addr.ss_family))\n\t\t\t\t{\n\t\t\t\t\t/* Don't request SSL or GSSAPI over Unix sockets */\n#ifdef USE_SSL\n\t\t\t\t\tconn->allow_ssl_try = false;\n#endif\n#ifdef ENABLE_GSS\n\t\t\t\t\tconn->try_gss = false;\n#endif\n\t\t\t\t}\n\n#ifdef ENABLE_GSS\n\n\t\t\t\t/*\n\t\t\t\t * If GSSAPI encryption is enabled, then call\n\t\t\t\t * pg_GSS_have_cred_cache() which will return true if we can\n\t\t\t\t * acquire credentials (and give us a handle to use in\n\t\t\t\t * conn->gcred), and then send a packet to the server asking\n\t\t\t\t * for GSSAPI Encryption (and skip past SSL negotiation and\n\t\t\t\t * regular startup below).\n\t\t\t\t */\n\t\t\t\tif (conn->try_gss && !conn->gctx)\n\t\t\t\t\tconn->try_gss = pg_GSS_have_cred_cache(&conn->gcred);\n\t\t\t\tif (conn->try_gss && !conn->gctx)\n\t\t\t\t{\n\t\t\t\t\tProtocolVersion pv = pg_hton32(NEGOTIATE_GSS_CODE);\n\n\t\t\t\t\tif (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not send GSSAPI negotiation packet: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Ok, wait for response */\n\t\t\t\t\tconn->status = CONNECTION_GSS_STARTUP;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\t\t\t\telse if (!conn->gctx && conn->gssencmode[0] == 'r')\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"GSSAPI encryption required but was impossible (possibly no credential cache, no server support, or using a local socket)\\n\"));\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n#endif\n\n#ifdef USE_SSL\n\n\t\t\t\t/*\n\t\t\t\t * Enable the libcrypto callbacks before checking if SSL needs\n\t\t\t\t * to be done.  This is done before sending the startup packet\n\t\t\t\t * as depending on the type of authentication done, like MD5\n\t\t\t\t * or SCRAM that use cryptohashes, the callbacks would be\n\t\t\t\t * required even without a SSL connection\n\t\t\t\t */\n\t\t\t\tif (pqsecure_initialize(conn, false, true) < 0)\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\t/*\n\t\t\t\t * If SSL is enabled and we haven't already got encryption of\n\t\t\t\t * some sort running, request SSL instead of sending the\n\t\t\t\t * startup message.\n\t\t\t\t */\n\t\t\t\tif (conn->allow_ssl_try && !conn->wait_ssl_try &&\n\t\t\t\t\t!conn->ssl_in_use\n#ifdef ENABLE_GSS\n\t\t\t\t\t&& !conn->gssenc\n#endif\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tProtocolVersion pv;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Send the SSL request packet.\n\t\t\t\t\t *\n\t\t\t\t\t * Theoretically, this could block, but it really\n\t\t\t\t\t * shouldn't since we only got here if the socket is\n\t\t\t\t\t * write-ready.\n\t\t\t\t\t */\n\t\t\t\t\tpv = pg_hton32(NEGOTIATE_SSL_CODE);\n\t\t\t\t\tif (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not send SSL negotiation packet: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t\t/* Ok, wait for response */\n\t\t\t\t\tconn->status = CONNECTION_SSL_STARTUP;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* USE_SSL */\n\n\t\t\t\t/*\n\t\t\t\t * Build the startup packet.\n\t\t\t\t */\n\t\t\t\tstartpacket = pqBuildStartupPacket3(conn, &packetlen,\n\t\t\t\t\t\t\t\t\t\t\t\t\tEnvironmentOptions);\n\t\t\t\tif (!startpacket)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Send the startup packet.\n\t\t\t\t *\n\t\t\t\t * Theoretically, this could block, but it really shouldn't\n\t\t\t\t * since we only got here if the socket is write-ready.\n\t\t\t\t */\n\t\t\t\tif (pqPacketSend(conn, 0, startpacket, packetlen) != STATUS_OK)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not send startup packet: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\tfree(startpacket);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\tfree(startpacket);\n\n\t\t\t\tconn->status = CONNECTION_AWAITING_RESPONSE;\n\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Handle SSL negotiation: wait for postmaster messages and\n\t\t\t * respond as necessary.\n\t\t\t */\n\t\tcase CONNECTION_SSL_STARTUP:\n\t\t\t{\n#ifdef USE_SSL\n\t\t\t\tPostgresPollingStatusType pollres;\n\n\t\t\t\t/*\n\t\t\t\t * On first time through, get the postmaster's response to our\n\t\t\t\t * SSL negotiation packet.\n\t\t\t\t */\n\t\t\t\tif (!conn->ssl_in_use)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We use pqReadData here since it has the logic to\n\t\t\t\t\t * distinguish no-data-yet from connection closure. Since\n\t\t\t\t\t * conn->ssl isn't set, a plain recv() will occur.\n\t\t\t\t\t */\n\t\t\t\t\tchar\t\tSSLok;\n\t\t\t\t\tint\t\t\trdresult;\n\n\t\t\t\t\trdresult = pqReadData(conn);\n\t\t\t\t\tif (rdresult < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* errorMessage is already filled in */\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t\tif (rdresult == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* caller failed to wait for data */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\t\t\t\t\tif (pqGetc(&SSLok, conn) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* should not happen really */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\t\t\t\t\tif (SSLok == 'S')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* mark byte consumed */\n\t\t\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Set up global SSL state if required.  The crypto\n\t\t\t\t\t\t * state has already been set if libpq took care of\n\t\t\t\t\t\t * doing that, so there is no need to make that happen\n\t\t\t\t\t\t * again.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (pqsecure_initialize(conn, true, false) != 0)\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t\telse if (SSLok == 'N')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* mark byte consumed */\n\t\t\t\t\t\tconn->inStart = conn->inCursor;\n\t\t\t\t\t\t/* OK to do without SSL? */\n\t\t\t\t\t\tif (conn->sslmode[0] == 'r' ||\t/* \"require\" */\n\t\t\t\t\t\t\tconn->sslmode[0] == 'v')\t/* \"verify-ca\" or\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * \"verify-full\" */\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Require SSL, but server does not want it */\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server does not support SSL, but SSL was required\\n\"));\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Otherwise, proceed with normal startup */\n\t\t\t\t\t\tconn->allow_ssl_try = false;\n\t\t\t\t\t\t/* We can proceed using this connection */\n\t\t\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t\t}\n\t\t\t\t\telse if (SSLok == 'E')\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Server failure of some sort, such as failure to\n\t\t\t\t\t\t * fork a backend process.  We need to process and\n\t\t\t\t\t\t * report the error message, which might be formatted\n\t\t\t\t\t\t * according to either protocol 2 or protocol 3.\n\t\t\t\t\t\t * Rather than duplicate the code for that, we flip\n\t\t\t\t\t\t * into AWAITING_RESPONSE state and let the code there\n\t\t\t\t\t\t * deal with it.  Note we have *not* consumed the \"E\"\n\t\t\t\t\t\t * byte here.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->status = CONNECTION_AWAITING_RESPONSE;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"received invalid response to SSL negotiation: %c\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SSLok);\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Begin or continue the SSL negotiation process.\n\t\t\t\t */\n\t\t\t\tpollres = pqsecure_open_client(conn);\n\t\t\t\tif (pollres == PGRES_POLLING_OK)\n\t\t\t\t{\n\t\t\t\t\t/* SSL handshake done, ready to send startup packet */\n\t\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t}\n\t\t\t\tif (pollres == PGRES_POLLING_FAILED)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Failed ... if sslmode is \"prefer\" then do a non-SSL\n\t\t\t\t\t * retry\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->sslmode[0] == 'p' /* \"prefer\" */\n\t\t\t\t\t\t&& conn->allow_ssl_try\t/* redundant? */\n\t\t\t\t\t\t&& !conn->wait_ssl_try) /* redundant? */\n\t\t\t\t\t{\n\t\t\t\t\t\t/* only retry once */\n\t\t\t\t\t\tconn->allow_ssl_try = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else it's a hard failure */\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\t\t\t\t/* Else, return POLLING_READING or POLLING_WRITING status */\n\t\t\t\treturn pollres;\n#else\t\t\t\t\t\t\t/* !USE_SSL */\n\t\t\t\t/* can't get here */\n\t\t\t\tgoto error_return;\n#endif\t\t\t\t\t\t\t/* USE_SSL */\n\t\t\t}\n\n\t\tcase CONNECTION_GSS_STARTUP:\n\t\t\t{\n#ifdef ENABLE_GSS\n\t\t\t\tPostgresPollingStatusType pollres;\n\n\t\t\t\t/*\n\t\t\t\t * If we haven't yet, get the postmaster's response to our\n\t\t\t\t * negotiation packet\n\t\t\t\t */\n\t\t\t\tif (conn->try_gss && !conn->gctx)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tgss_ok;\n\t\t\t\t\tint\t\t\trdresult = pqReadData(conn);\n\n\t\t\t\t\tif (rdresult < 0)\n\t\t\t\t\t\t/* pqReadData fills in error message */\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\telse if (rdresult == 0)\n\t\t\t\t\t\t/* caller failed to wait for data */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\tif (pqGetc(&gss_ok, conn) < 0)\n\t\t\t\t\t\t/* shouldn't happen... */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\n\t\t\t\t\tif (gss_ok == 'E')\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Server failure of some sort.  Assume it's a\n\t\t\t\t\t\t * protocol version support failure, and let's see if\n\t\t\t\t\t\t * we can't recover (if it's not, we'll get a better\n\t\t\t\t\t\t * error message on retry).  Server gets fussy if we\n\t\t\t\t\t\t * don't hang up the socket, though.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->try_gss = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* mark byte consumed */\n\t\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\t\tif (gss_ok == 'N')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Server doesn't want GSSAPI; fall back if we can */\n\t\t\t\t\t\tif (conn->gssencmode[0] == 'r')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server doesn't support GSSAPI encryption, but it was required\\n\"));\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconn->try_gss = false;\n\t\t\t\t\t\t/* We can proceed using this connection */\n\t\t\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t\t}\n\t\t\t\t\telse if (gss_ok != 'G')\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"received invalid response to GSSAPI negotiation: %c\\n\"),\n\t\t\t\t\t\t\t\t\t\t  gss_ok);\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Begin or continue GSSAPI negotiation */\n\t\t\t\tpollres = pqsecure_open_gss(conn);\n\t\t\t\tif (pollres == PGRES_POLLING_OK)\n\t\t\t\t{\n\t\t\t\t\t/* All set for startup packet */\n\t\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t}\n\t\t\t\telse if (pollres == PGRES_POLLING_FAILED &&\n\t\t\t\t\t\t conn->gssencmode[0] == 'p')\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We failed, but we can retry on \"prefer\".  Have to drop\n\t\t\t\t\t * the current connection to do so, though.\n\t\t\t\t\t */\n\t\t\t\t\tconn->try_gss = false;\n\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\t\t\t\treturn pollres;\n#else\t\t\t\t\t\t\t/* !ENABLE_GSS */\n\t\t\t\t/* unreachable */\n\t\t\t\tgoto error_return;\n#endif\t\t\t\t\t\t\t/* ENABLE_GSS */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Handle authentication exchange: wait for postmaster messages\n\t\t\t * and respond as necessary.\n\t\t\t */\n\t\tcase CONNECTION_AWAITING_RESPONSE:\n\t\t\t{\n\t\t\t\tchar\t\tberesp;\n\t\t\t\tint\t\t\tmsgLength;\n\t\t\t\tint\t\t\tavail;\n\t\t\t\tAuthRequest areq;\n\t\t\t\tint\t\t\tres;\n\n\t\t\t\t/*\n\t\t\t\t * Scan the message from current point (note that if we find\n\t\t\t\t * the message is incomplete, we will return without advancing\n\t\t\t\t * inStart, and resume here next time).\n\t\t\t\t */\n\t\t\t\tconn->inCursor = conn->inStart;\n\n\t\t\t\t/* Read type byte */\n\t\t\t\tif (pqGetc(&beresp, conn))\n\t\t\t\t{\n\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Validate message type: we expect only an authentication\n\t\t\t\t * request or an error here.  Anything else probably means\n\t\t\t\t * it's not Postgres on the other end at all.\n\t\t\t\t */\n\t\t\t\tif (!(beresp == 'R' || beresp == 'E'))\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"expected authentication request from server, but received %c\\n\"),\n\t\t\t\t\t\t\t\t\t  beresp);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/* Read message length word */\n\t\t\t\tif (pqGetInt(&msgLength, 4, conn))\n\t\t\t\t{\n\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Try to validate message length before using it.\n\t\t\t\t * Authentication requests can't be very large, although GSS\n\t\t\t\t * auth requests may not be that small.  Errors can be a\n\t\t\t\t * little larger, but not huge.  If we see a large apparent\n\t\t\t\t * length in an error, it means we're really talking to a\n\t\t\t\t * pre-3.0-protocol server; cope.  (Before version 14, the\n\t\t\t\t * server also used the old protocol for errors that happened\n\t\t\t\t * before processing the startup packet.)\n\t\t\t\t */\n\t\t\t\tif (beresp == 'R' && (msgLength < 8 || msgLength > 2000))\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"expected authentication request from server, but received %c\\n\"),\n\t\t\t\t\t\t\t\t\t  beresp);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\tif (beresp == 'E' && (msgLength < 8 || msgLength > 30000))\n\t\t\t\t{\n\t\t\t\t\t/* Handle error from a pre-3.0 server */\n\t\t\t\t\tconn->inCursor = conn->inStart + 1; /* reread data */\n\t\t\t\t\tif (pqGets_append(&conn->errorMessage, conn))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\t\t\t\t\t/* OK, we read the message; mark data consumed */\n\t\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Before 7.2, the postmaster didn't always end its\n\t\t\t\t\t * messages with a newline, so add one if needed to\n\t\t\t\t\t * conform to libpq conventions.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->errorMessage.len == 0 ||\n\t\t\t\t\t\tconn->errorMessage.data[conn->errorMessage.len - 1] != '\\n')\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBufferChar(&conn->errorMessage, '\\n');\n\t\t\t\t\t}\n\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Can't process if message body isn't all here yet.\n\t\t\t\t */\n\t\t\t\tmsgLength -= 4;\n\t\t\t\tavail = conn->inEnd - conn->inCursor;\n\t\t\t\tif (avail < msgLength)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Before returning, try to enlarge the input buffer if\n\t\t\t\t\t * needed to hold the whole message; see notes in\n\t\t\t\t\t * pqParseInput3.\n\t\t\t\t\t */\n\t\t\t\t\tif (pqCheckInBufferSpace(conn->inCursor + (size_t) msgLength,\n\t\t\t\t\t\t\t\t\t\t\t conn))\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\t/* Handle errors. */\n\t\t\t\tif (beresp == 'E')\n\t\t\t\t{\n\t\t\t\t\tif (pqGetErrorNotice3(conn, true))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\t\t\t\t\t/* OK, we read the message; mark data consumed */\n\t\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If error is \"cannot connect now\", try the next host if\n\t\t\t\t\t * any (but we don't want to consider additional addresses\n\t\t\t\t\t * for this host, nor is there much point in changing SSL\n\t\t\t\t\t * or GSS mode).  This is helpful when dealing with\n\t\t\t\t\t * standby servers that might not be in hot-standby state.\n\t\t\t\t\t */\n\t\t\t\t\tif (strcmp(conn->last_sqlstate,\n\t\t\t\t\t\t\t   ERRCODE_CANNOT_CONNECT_NOW) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->try_next_host = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Check to see if we should mention pgpassfile */\n\t\t\t\t\tpgpassfileWarning(conn);\n\n#ifdef ENABLE_GSS\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If gssencmode is \"prefer\" and we're using GSSAPI, retry\n\t\t\t\t\t * without it.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->gssenc && conn->gssencmode[0] == 'p')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* only retry once */\n\t\t\t\t\t\tconn->try_gss = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n#endif\n\n#ifdef USE_SSL\n\n\t\t\t\t\t/*\n\t\t\t\t\t * if sslmode is \"allow\" and we haven't tried an SSL\n\t\t\t\t\t * connection already, then retry with an SSL connection\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->sslmode[0] == 'a' /* \"allow\" */\n\t\t\t\t\t\t&& !conn->ssl_in_use\n\t\t\t\t\t\t&& conn->allow_ssl_try\n\t\t\t\t\t\t&& conn->wait_ssl_try)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* only retry once */\n\t\t\t\t\t\tconn->wait_ssl_try = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * if sslmode is \"prefer\" and we're in an SSL connection,\n\t\t\t\t\t * then do a non-SSL retry\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->sslmode[0] == 'p' /* \"prefer\" */\n\t\t\t\t\t\t&& conn->ssl_in_use\n\t\t\t\t\t\t&& conn->allow_ssl_try\t/* redundant? */\n\t\t\t\t\t\t&& !conn->wait_ssl_try) /* redundant? */\n\t\t\t\t\t{\n\t\t\t\t\t\t/* only retry once */\n\t\t\t\t\t\tconn->allow_ssl_try = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n#endif\n\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/* It is an authentication request. */\n\t\t\t\tconn->auth_req_received = true;\n\n\t\t\t\t/* Get the type of request. */\n\t\t\t\tif (pqGetInt((int *) &areq, 4, conn))\n\t\t\t\t{\n\t\t\t\t\t/* We'll come back when there are more data */\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\t\t\t\tmsgLength -= 4;\n\n\t\t\t\t/*\n\t\t\t\t * Process the rest of the authentication request message, and\n\t\t\t\t * respond to it if necessary.\n\t\t\t\t *\n\t\t\t\t * Note that conn->pghost must be non-NULL if we are going to\n\t\t\t\t * avoid the Kerberos code doing a hostname look-up.\n\t\t\t\t */\n\t\t\t\tres = pg_fe_sendauth(areq, msgLength, conn);\n\n\t\t\t\t/* OK, we have processed the message; mark data consumed */\n\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\tif (res != STATUS_OK)\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\t/*\n\t\t\t\t * Just make sure that any data sent by pg_fe_sendauth is\n\t\t\t\t * flushed out.  Although this theoretically could block, it\n\t\t\t\t * really shouldn't since we don't send large auth responses.\n\t\t\t\t */\n\t\t\t\tif (pqFlush(conn))\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\tif (areq == AUTH_REQ_OK)\n\t\t\t\t{\n\t\t\t\t\t/* We are done with authentication exchange */\n\t\t\t\t\tconn->status = CONNECTION_AUTH_OK;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set asyncStatus so that PQgetResult will think that\n\t\t\t\t\t * what comes back next is the result of a query.  See\n\t\t\t\t\t * below.\n\t\t\t\t\t */\n\t\t\t\t\tconn->asyncStatus = PGASYNC_BUSY;\n\t\t\t\t}\n\n\t\t\t\t/* Look to see if we have more data yet. */\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tcase CONNECTION_AUTH_OK:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Now we expect to hear from the backend. A ReadyForQuery\n\t\t\t\t * message indicates that startup is successful, but we might\n\t\t\t\t * also get an Error message indicating failure. (Notice\n\t\t\t\t * messages indicating nonfatal warnings are also allowed by\n\t\t\t\t * the protocol, as are ParameterStatus and BackendKeyData\n\t\t\t\t * messages.) Easiest way to handle this is to let\n\t\t\t\t * PQgetResult() read the messages. We just have to fake it\n\t\t\t\t * out about the state of the connection, by setting\n\t\t\t\t * asyncStatus = PGASYNC_BUSY (done above).\n\t\t\t\t */\n\n\t\t\t\tif (PQisBusy(conn))\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\n\t\t\t\tres = PQgetResult(conn);\n\n\t\t\t\t/*\n\t\t\t\t * NULL return indicating we have gone to IDLE state is\n\t\t\t\t * expected\n\t\t\t\t */\n\t\t\t\tif (res)\n\t\t\t\t{\n\t\t\t\t\tif (res->resultStatus != PGRES_FATAL_ERROR)\n\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"unexpected message from server during startup\\n\"));\n\t\t\t\t\telse if (conn->send_appname &&\n\t\t\t\t\t\t\t (conn->appname || conn->fbappname))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If we tried to send application_name, check to see\n\t\t\t\t\t\t * if the error is about that --- pre-9.0 servers will\n\t\t\t\t\t\t * reject it at this stage of the process.  If so,\n\t\t\t\t\t\t * close the connection and retry without sending\n\t\t\t\t\t\t * application_name.  We could possibly get a false\n\t\t\t\t\t\t * SQLSTATE match here and retry uselessly, but there\n\t\t\t\t\t\t * seems no great harm in that; we'll just get the\n\t\t\t\t\t\t * same error again if it's unrelated.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst char *sqlstate;\n\n\t\t\t\t\t\tsqlstate = PQresultErrorField(res, PG_DIAG_SQLSTATE);\n\t\t\t\t\t\tif (sqlstate &&\n\t\t\t\t\t\t\tstrcmp(sqlstate, ERRCODE_APPNAME_UNKNOWN) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPQclear(res);\n\t\t\t\t\t\t\tconn->send_appname = false;\n\t\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * if the resultStatus is FATAL, then conn->errorMessage\n\t\t\t\t\t * already has a copy of the error; needn't copy it back.\n\t\t\t\t\t * But add a newline if it's not there already, since\n\t\t\t\t\t * postmaster error messages may not have one.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->errorMessage.len <= 0 ||\n\t\t\t\t\t\tconn->errorMessage.data[conn->errorMessage.len - 1] != '\\n')\n\t\t\t\t\t\tappendPQExpBufferChar(&conn->errorMessage, '\\n');\n\t\t\t\t\tPQclear(res);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/* Almost there now ... */\n\t\t\t\tconn->status = CONNECTION_CHECK_TARGET;\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tcase CONNECTION_CHECK_TARGET:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If a read-write, read-only, primary, or standby connection\n\t\t\t\t * is required, see if we have one.\n\t\t\t\t */\n\t\t\t\tif (conn->target_server_type == SERVER_TYPE_READ_WRITE ||\n\t\t\t\t\tconn->target_server_type == SERVER_TYPE_READ_ONLY)\n\t\t\t\t{\n\t\t\t\t\tbool\t\tread_only_server;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If the server didn't report\n\t\t\t\t\t * \"default_transaction_read_only\" or \"in_hot_standby\" at\n\t\t\t\t\t * startup, we must determine its state by sending the\n\t\t\t\t\t * query \"SHOW transaction_read_only\".  This GUC exists in\n\t\t\t\t\t * all server versions that support 3.0 protocol.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->default_transaction_read_only == PG_BOOL_UNKNOWN ||\n\t\t\t\t\t\tconn->in_hot_standby == PG_BOOL_UNKNOWN)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We use PQsendQueryContinue so that\n\t\t\t\t\t\t * conn->errorMessage does not get cleared.  We need\n\t\t\t\t\t\t * to preserve any error messages related to previous\n\t\t\t\t\t\t * hosts we have tried and failed to connect to.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\t\t\tif (!PQsendQueryContinue(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t \"SHOW transaction_read_only\"))\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t\t/* We'll return to this state when we have the answer */\n\t\t\t\t\t\tconn->status = CONNECTION_CHECK_WRITABLE;\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* OK, we can make the test */\n\t\t\t\t\tread_only_server =\n\t\t\t\t\t\t(conn->default_transaction_read_only == PG_BOOL_YES ||\n\t\t\t\t\t\t conn->in_hot_standby == PG_BOOL_YES);\n\n\t\t\t\t\tif ((conn->target_server_type == SERVER_TYPE_READ_WRITE) ?\n\t\t\t\t\t\tread_only_server : !read_only_server)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Wrong server state, reject and try the next host */\n\t\t\t\t\t\tif (conn->target_server_type == SERVER_TYPE_READ_WRITE)\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"session is read-only\\n\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"session is not read-only\\n\"));\n\n\t\t\t\t\t\t/* Close connection politely. */\n\t\t\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\t\t\tsendTerminateConn(conn);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Try next host if any, but we don't want to consider\n\t\t\t\t\t\t * additional addresses for this host.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->try_next_host = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (conn->target_server_type == SERVER_TYPE_PRIMARY ||\n\t\t\t\t\t\t conn->target_server_type == SERVER_TYPE_STANDBY ||\n\t\t\t\t\t\t conn->target_server_type == SERVER_TYPE_PREFER_STANDBY)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If the server didn't report \"in_hot_standby\" at\n\t\t\t\t\t * startup, we must determine its state by sending the\n\t\t\t\t\t * query \"SELECT pg_catalog.pg_is_in_recovery()\".  Servers\n\t\t\t\t\t * before 9.0 don't have that function, but by the same\n\t\t\t\t\t * token they don't have any standby mode, so we may just\n\t\t\t\t\t * assume the result.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->sversion < 90000)\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_NO;\n\n\t\t\t\t\tif (conn->in_hot_standby == PG_BOOL_UNKNOWN)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We use PQsendQueryContinue so that\n\t\t\t\t\t\t * conn->errorMessage does not get cleared.  We need\n\t\t\t\t\t\t * to preserve any error messages related to previous\n\t\t\t\t\t\t * hosts we have tried and failed to connect to.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\t\t\tif (!PQsendQueryContinue(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t \"SELECT pg_catalog.pg_is_in_recovery()\"))\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t\t/* We'll return to this state when we have the answer */\n\t\t\t\t\t\tconn->status = CONNECTION_CHECK_STANDBY;\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* OK, we can make the test */\n\t\t\t\t\tif ((conn->target_server_type == SERVER_TYPE_PRIMARY) ?\n\t\t\t\t\t\t(conn->in_hot_standby == PG_BOOL_YES) :\n\t\t\t\t\t\t(conn->in_hot_standby == PG_BOOL_NO))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Wrong server state, reject and try the next host */\n\t\t\t\t\t\tif (conn->target_server_type == SERVER_TYPE_PRIMARY)\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server is in hot standby mode\\n\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server is not in hot standby mode\\n\"));\n\n\t\t\t\t\t\t/* Close connection politely. */\n\t\t\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\t\t\tsendTerminateConn(conn);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Try next host if any, but we don't want to consider\n\t\t\t\t\t\t * additional addresses for this host.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->try_next_host = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* We can release the address list now. */\n\t\t\t\trelease_conn_addrinfo(conn);\n\n\t\t\t\t/*\n\t\t\t\t * Contents of conn->errorMessage are no longer interesting\n\t\t\t\t * (and it seems some clients expect it to be empty after a\n\t\t\t\t * successful connection).\n\t\t\t\t */\n\t\t\t\tresetPQExpBuffer(&conn->errorMessage);\n\n\t\t\t\t/* We are open for business! */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\treturn PGRES_POLLING_OK;\n\t\t\t}\n\n\t\tcase CONNECTION_CONSUME:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This state just makes sure the connection is idle after\n\t\t\t\t * we've obtained the result of a SHOW or SELECT query.  Once\n\t\t\t\t * we're clear, return to CONNECTION_CHECK_TARGET state to\n\t\t\t\t * decide what to do next.  We must transiently set status =\n\t\t\t\t * CONNECTION_OK in order to use the result-consuming\n\t\t\t\t * subroutines.\n\t\t\t\t */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tif (!PQconsumeInput(conn))\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\tif (PQisBusy(conn))\n\t\t\t\t{\n\t\t\t\t\tconn->status = CONNECTION_CONSUME;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\t/* Call PQgetResult() again until we get a NULL result */\n\t\t\t\tres = PQgetResult(conn);\n\t\t\t\tif (res != NULL)\n\t\t\t\t{\n\t\t\t\t\tPQclear(res);\n\t\t\t\t\tconn->status = CONNECTION_CONSUME;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\tconn->status = CONNECTION_CHECK_TARGET;\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tcase CONNECTION_CHECK_WRITABLE:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Waiting for result of \"SHOW transaction_read_only\".  We\n\t\t\t\t * must transiently set status = CONNECTION_OK in order to use\n\t\t\t\t * the result-consuming subroutines.\n\t\t\t\t */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tif (!PQconsumeInput(conn))\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\tif (PQisBusy(conn))\n\t\t\t\t{\n\t\t\t\t\tconn->status = CONNECTION_CHECK_WRITABLE;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\tres = PQgetResult(conn);\n\t\t\t\tif (res && PQresultStatus(res) == PGRES_TUPLES_OK &&\n\t\t\t\t\tPQntuples(res) == 1)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *val = PQgetvalue(res, 0, 0);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * \"transaction_read_only = on\" proves that at least one\n\t\t\t\t\t * of default_transaction_read_only and in_hot_standby is\n\t\t\t\t\t * on, but we don't actually know which.  We don't care\n\t\t\t\t\t * though for the purpose of identifying a read-only\n\t\t\t\t\t * session, so satisfy the CONNECTION_CHECK_TARGET code by\n\t\t\t\t\t * claiming they are both on.  On the other hand, if it's\n\t\t\t\t\t * a read-write session, they are certainly both off.\n\t\t\t\t\t */\n\t\t\t\t\tif (strncmp(val, \"on\", 2) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->default_transaction_read_only = PG_BOOL_YES;\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_YES;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->default_transaction_read_only = PG_BOOL_NO;\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_NO;\n\t\t\t\t\t}\n\t\t\t\t\tPQclear(res);\n\n\t\t\t\t\t/* Finish reading messages before continuing */\n\t\t\t\t\tconn->status = CONNECTION_CONSUME;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\n\t\t\t\t/* Something went wrong with \"SHOW transaction_read_only\". */\n\t\t\t\tif (res)\n\t\t\t\t\tPQclear(res);\n\n\t\t\t\t/* Append error report to conn->errorMessage. */\n\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"\\\"%s\\\" failed\\n\"),\n\t\t\t\t\t\t\t\t  \"SHOW transaction_read_only\");\n\n\t\t\t\t/* Close connection politely. */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tsendTerminateConn(conn);\n\n\t\t\t\t/* Try next host. */\n\t\t\t\tconn->try_next_host = true;\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tcase CONNECTION_CHECK_STANDBY:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Waiting for result of \"SELECT pg_is_in_recovery()\".  We\n\t\t\t\t * must transiently set status = CONNECTION_OK in order to use\n\t\t\t\t * the result-consuming subroutines.\n\t\t\t\t */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tif (!PQconsumeInput(conn))\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\tif (PQisBusy(conn))\n\t\t\t\t{\n\t\t\t\t\tconn->status = CONNECTION_CHECK_STANDBY;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\tres = PQgetResult(conn);\n\t\t\t\tif (res && PQresultStatus(res) == PGRES_TUPLES_OK &&\n\t\t\t\t\tPQntuples(res) == 1)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *val = PQgetvalue(res, 0, 0);\n\n\t\t\t\t\tif (strncmp(val, \"t\", 1) == 0)\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_YES;\n\t\t\t\t\telse\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_NO;\n\t\t\t\t\tPQclear(res);\n\n\t\t\t\t\t/* Finish reading messages before continuing */\n\t\t\t\t\tconn->status = CONNECTION_CONSUME;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\n\t\t\t\t/* Something went wrong with \"SELECT pg_is_in_recovery()\". */\n\t\t\t\tif (res)\n\t\t\t\t\tPQclear(res);\n\n\t\t\t\t/* Append error report to conn->errorMessage. */\n\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"\\\"%s\\\" failed\\n\"),\n\t\t\t\t\t\t\t\t  \"SELECT pg_is_in_recovery()\");\n\n\t\t\t\t/* Close connection politely. */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tsendTerminateConn(conn);\n\n\t\t\t\t/* Try next host. */\n\t\t\t\tconn->try_next_host = true;\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid connection state %d, \"\n\t\t\t\t\t\t\t\t\t\t\t\"probably indicative of memory corruption\\n\"),\n\t\t\t\t\t\t\t  conn->status);\n\t\t\tgoto error_return;\n\t}\n\n\t/* Unreachable */\n\nerror_return:\n\n\t/*\n\t * We used to close the socket at this point, but that makes it awkward\n\t * for those above us if they wish to remove this socket from their own\n\t * records (an fd_set for example).  We'll just have this socket closed\n\t * when PQfinish is called (which is compulsory even after an error, since\n\t * the connection structure must be freed).\n\t */\n\tconn->status = CONNECTION_BAD;\n\treturn PGRES_POLLING_FAILED;\n}", "func_hash": 145605680477709719969453491383463044279, "file_name": "fe-connect.c", "file_hash": 157537093140020562394962573075779914657, "cwe": ["CWE-522"], "cve": "CVE-2021-23222", "cve_desc": "A man-in-the-middle attacker can inject false responses to the client's first few queries, despite the use of SSL certificate verification and encryption.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-23222"}
{"idx": 200831, "project": "tor", "commit_id": "00fffbc1a15e2696a89c721d0c94dc333ff419ef", "project_url": "https://github.com/torproject/tor", "commit_url": "https://gitweb.torproject.org/tor.git/commitdiff/00fffbc1a15e2696a89c721d0c94dc333ff419ef", "commit_message": "Don't give the Guard flag to relays without the CVE-2011-2768 fix", "target": 1, "func": "set_routerstatus_from_routerinfo(routerstatus_t *rs,\n                                 routerinfo_t *ri, time_t now,\n                                 int naming, int listbadexits,\n                                 int listbaddirs, int vote_on_hsdirs)\n{\n  int unstable_version =\n    !tor_version_as_new_as(ri->platform,\"0.1.1.16-rc-cvs\");\n  memset(rs, 0, sizeof(routerstatus_t));\n\n  rs->is_authority =\n    router_digest_is_trusted_dir(ri->cache_info.identity_digest);\n\n  /* Already set by compute_performance_thresholds. */\n  rs->is_exit = ri->is_exit;\n  rs->is_stable = ri->is_stable =\n    router_is_active(ri, now) &&\n    !dirserv_thinks_router_is_unreliable(now, ri, 1, 0) &&\n    !unstable_version;\n  rs->is_fast = ri->is_fast =\n    router_is_active(ri, now) &&\n    !dirserv_thinks_router_is_unreliable(now, ri, 0, 1);\n  rs->is_running = ri->is_running; /* computed above */\n\n  if (naming) {\n    uint32_t name_status = dirserv_get_name_status(\n                         ri->cache_info.identity_digest, ri->nickname);\n    rs->is_named = (naming && (name_status & FP_NAMED)) ? 1 : 0;\n    rs->is_unnamed = (naming && (name_status & FP_UNNAMED)) ? 1 : 0;\n  }\n  rs->is_valid = ri->is_valid;\n\n  if (rs->is_fast &&\n      (router_get_advertised_bandwidth(ri) >= BANDWIDTH_TO_GUARANTEE_GUARD ||\n       router_get_advertised_bandwidth(ri) >=\n                              MIN(guard_bandwidth_including_exits,\n                                  guard_bandwidth_excluding_exits))) {\n    long tk = rep_hist_get_weighted_time_known(\n                                      ri->cache_info.identity_digest, now);\n    double wfu = rep_hist_get_weighted_fractional_uptime(\n                                      ri->cache_info.identity_digest, now);\n    rs->is_possible_guard = (wfu >= guard_wfu && tk >= guard_tk) ? 1 : 0;\n  } else {\n    rs->is_possible_guard = 0;\n  }\n  rs->is_bad_directory = listbaddirs && ri->is_bad_directory;\n  rs->is_bad_exit = listbadexits && ri->is_bad_exit;\n  ri->is_hs_dir = dirserv_thinks_router_is_hs_dir(ri, now);\n  rs->is_hs_dir = vote_on_hsdirs && ri->is_hs_dir;\n  rs->is_v2_dir = ri->dir_port != 0;\n\n  if (!strcasecmp(ri->nickname, UNNAMED_ROUTER_NICKNAME))\n    rs->is_named = rs->is_unnamed = 0;\n\n  rs->published_on = ri->cache_info.published_on;\n  memcpy(rs->identity_digest, ri->cache_info.identity_digest, DIGEST_LEN);\n  memcpy(rs->descriptor_digest, ri->cache_info.signed_descriptor_digest,\n         DIGEST_LEN);\n  rs->addr = ri->addr;\n  strlcpy(rs->nickname, ri->nickname, sizeof(rs->nickname));\n  rs->or_port = ri->or_port;\n  rs->dir_port = ri->dir_port;\n}", "func_hash": 318178419664162766552129781692369632852, "file_name": "dirserv.c", "file_hash": 144814081099750966253037063350589014941, "cwe": ["CWE-264"], "cve": "CVE-2011-2768", "cve_desc": "Tor before 0.2.2.34, when configured as a client or bridge, sends a TLS certificate chain as part of an outgoing OR connection, which allows remote relays to bypass intended anonymity properties by reading this chain and then determining the set of entry guards that the client or bridge had selected.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2768"}
{"idx": 220830, "project": "tensorflow", "commit_id": "8c6f391a2282684a25cbfec7687bd5d35261a209", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/8c6f391a2282684a25cbfec7687bd5d35261a209", "commit_message": "[lite] Add check for bias_size is zero to avoid division by zero. This shouldn't happen for properly converted models. Just safety check\n\nPiperOrigin-RevId: 416383645\nChange-Id: If8e508bf696ae8ecfb927e69c139a8ccf7fe60cb", "target": 0, "func": "inline int32_t MultiplyByQuantizedMultiplier(int32_t x,\n                                             int32_t quantized_multiplier,\n                                             int shift) {\n  TFLITE_DCHECK(quantized_multiplier >= 0);\n  TFLITE_DCHECK(shift >= -31 && shift <= 30);\n\n  const int64_t total_shift = 31 - shift;\n  const int64_t round = static_cast<int64_t>(1) << (total_shift - 1);\n  int64_t result = x * static_cast<int64_t>(quantized_multiplier) + round;\n  result = result >> total_shift;\n\n  TFLITE_DCHECK(result >= std::numeric_limits<int32_t>::min() &&\n                result <= std::numeric_limits<int32_t>::max());\n  return static_cast<int32_t>(result);\n}", "func_hash": 136773084967392616146537741227969047882, "file_name": "common.h", "file_hash": 206010119069068373550820723284960883967, "cwe": ["CWE-369"], "cve": "CVE-2022-23557", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would trigger a division by zero in `BiasAndClamp` implementation. There is no check that the `bias_size` is non zero. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23557"}
{"idx": 218754, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static wchar_t *ConvertUTF8ToUTF16(const unsigned char *source)\n{\n  size_t\n    length;\n\n  wchar_t\n    *utf16;\n\n  length=UTF8ToUTF16(source,(wchar_t *) NULL);\n  if (length == 0)\n    {\n      ssize_t\n        i;\n\n      /*\n        Not UTF-8, just copy.\n      */\n      length=strlen((char *) source);\n      utf16=(wchar_t *) AcquireQuantumMemory(length+1,sizeof(*utf16));\n      if (utf16 == (wchar_t *) NULL)\n        return((wchar_t *) NULL);\n      for (i=0; i <= (ssize_t) length; i++)\n        utf16[i]=source[i];\n      return(utf16);\n    }\n  utf16=(wchar_t *) AcquireQuantumMemory(length+1,sizeof(*utf16));\n  if (utf16 == (wchar_t *) NULL)\n    return((wchar_t *) NULL);\n  length=UTF8ToUTF16(source,utf16);\n  return(utf16);\n}", "func_hash": 40697322064819167267544778781891956822, "file_name": "emf.c", "file_hash": 107669295784465069224649926956785164656, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 221165, "project": "gpac", "commit_id": "a69b567b8c95c72f9560c873c5ab348be058f340", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340", "commit_message": "fixed #1895", "target": 0, "func": "GF_Err gf_odf_write_base_descriptor(GF_BitStream *bs, u8 tag, u32 size)\n{\n\tu32 length;\n\tunsigned char vals[4];\n\n\tif (!tag ) return GF_BAD_PARAM;\n\n\tlength = size;\n\tvals[3] = (unsigned char) (length & 0x7f);\n\tlength >>= 7;\n\tvals[2] = (unsigned char) ((length & 0x7f) | 0x80);\n\tlength >>= 7;\n\tvals[1] = (unsigned char) ((length & 0x7f) | 0x80);\n\tlength >>= 7;\n\tvals[0] = (unsigned char) ((length & 0x7f) | 0x80);\n\n\tgf_bs_write_int(bs, tag, 8);\n\tif (size < 0x00000080) {\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (size < 0x00004000) {\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (size < 0x00200000) {\n\t\tgf_bs_write_int(bs, vals[1], 8);\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (size < 0x10000000) {\n\t\tgf_bs_write_int(bs, vals[0], 8);\n\t\tgf_bs_write_int(bs, vals[1], 8);\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else {\n\t\treturn GF_ODF_INVALID_DESCRIPTOR;\n\t}\n\treturn GF_OK;\n}", "func_hash": 47899485844432792153947187160548570309, "file_name": "descriptors.c", "file_hash": 86476492964393375980272696403064975409, "cwe": ["CWE-415"], "cve": "CVE-2021-40571", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40571"}
{"idx": 206676, "project": "vim", "commit_id": "777e7c21b7627be80961848ac560cb0a9978ff43", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/777e7c21b7627be80961848ac560cb0a9978ff43", "commit_message": "patch 8.2.3564: invalid memory access when scrolling without valid screen\n\nProblem:    Invalid memory access when scrolling without a valid screen.\nSolution:   Do not set VALID_BOTLINE in w_valid.", "target": 1, "func": "update_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n    linenr_T\told_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill;\n#endif\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t     >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t   + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tif (curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_skipcol = 0;\n\t    redraw_later(NOT_VALID);\n\t}\n\telse\n\t    redraw_later(VALID);\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}", "func_hash": 228543629723963000813717359055705778977, "file_name": "move.c", "file_hash": 235877722919937919149866597040080656666, "cwe": ["CWE-122"], "cve": "CVE-2021-3903", "cve_desc": "vim is vulnerable to Heap-based Buffer Overflow", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3903"}
{"idx": 125902, "project": "Chrome", "commit_id": "6d067124e87295721c62a77f0610e4b37f6098ad", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/6d067124e87295721c62a77f0610e4b37f6098ad", "commit_message": "None", "target": 0, "func": "v8::Handle<v8::Value> V8ThrowException::createSyntaxError(v8::Isolate* isolate, const String& message)\n{\n    return v8::Exception::SyntaxError(v8String(isolate, message.isNull() ? \"Syntax error\" : message));\n}\n", "func_hash": 203441341902559238899164825264739901061, "file_name": "None", "file_hash": null, "cwe": [], "cve": "CVE-2015-1210", "cve_desc": "", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1210"}
{"idx": 222506, "project": "tensorflow", "commit_id": "3d89911481ba6ebe8c88c1c0b595412121e6c645", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/3d89911481ba6ebe8c88c1c0b595412121e6c645", "commit_message": "Eliminate `CHECK`-fail from `function.cc`.\n\nPiperOrigin-RevId: 409414744\nChange-Id: Ic854e12ab2edb88b165d32e2d632c4ee654d71ad", "target": 0, "func": "  Status AddReturnNode(\n      const OpDef::ArgDef& ret_def, AttrSlice attrs,\n      const ::tensorflow::protobuf::Map<string, string>& ret_map,\n      bool ints_on_device, int* ret_index) {\n    auto ret_iter = ret_map.find(ret_def.name());\n    if (ret_iter == ret_map.end()) {\n      return errors::InvalidArgument(\"Return \", ret_def.name(), \" missing.\");\n    }\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(ArgNumType(attrs, ret_def, &is_type_list, &dtypes));\n    CHECK_GE(dtypes.size(), size_t{1});\n    const auto* item = GetItemOrNull(ret_iter->second);\n    if (item == nullptr) {\n      return errors::InvalidArgument(\"Return \", ret_def.name(), \" -> \",\n                                     ret_iter->second, \" is not found.\");\n    }\n    if (dtypes != item->dtypes) {\n      return errors::InvalidArgument(\"Invalid ret types \", ret_def.name(),\n                                     \" : \", DataTypeVectorString(dtypes),\n                                     \" vs. \",\n                                     DataTypeVectorString(item->dtypes));\n    }\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      string name = strings::StrCat(ret_def.name(), \"_RetVal\");\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceRetOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kRetOp);\n      }\n      AddInput(nodes_.size() - 1, item->nid, item->idx + i);\n      DataType dtype = ret_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", (*ret_index)++, gnode);\n      result_.ret_types.push_back(dtypes[i]);\n    }\n    return Status::OK();\n  }", "func_hash": 228526204245966714221712494458377313394, "file_name": "function.cc", "file_hash": 275755455359751936167516531130081059449, "cwe": ["CWE-617"], "cve": "CVE-2022-23586", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that assertions in `function.cc` would be falsified and crash the Python interpreter. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23586"}
{"idx": 211650, "project": "linux", "commit_id": "89f3594d0de58e8a57d92d497dea9fee3d4b9cda", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?id=89f3594d0de58e8a57d92d497dea9fee3d4b9cda", "commit_message": "usb: gadget: don't release an existing dev->buf\n\ndev->buf does not need to be released if it already exists before\nexecuting dev_config.\n\nAcked-by: Alan Stern <stern@rowland.harvard.edu>\nSigned-off-by: Hangyu Hua <hbh25y@gmail.com>\nLink: https://lore.kernel.org/r/20211231172138.7993-2-hbh25y@gmail.com\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 1, "func": "dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\tssize_t\t\t\tvalue, length = len;\n\tunsigned\t\ttotal;\n\tu32\t\t\ttag;\n\tchar\t\t\t*kbuf;\n\n\tspin_lock_irq(&dev->lock);\n\tif (dev->state > STATE_DEV_OPENED) {\n\t\tvalue = ep0_write(fd, buf, len, ptr);\n\t\tspin_unlock_irq(&dev->lock);\n\t\treturn value;\n\t}\n\tspin_unlock_irq(&dev->lock);\n\n\tif ((len < (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) ||\n\t    (len > PAGE_SIZE * 4))\n\t\treturn -EINVAL;\n\n\t/* we might need to change message format someday */\n\tif (copy_from_user (&tag, buf, 4))\n\t\treturn -EFAULT;\n\tif (tag != 0)\n\t\treturn -EINVAL;\n\tbuf += 4;\n\tlength -= 4;\n\n\tkbuf = memdup_user(buf, length);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tspin_lock_irq (&dev->lock);\n\tvalue = -EINVAL;\n\tif (dev->buf) {\n\t\tkfree(kbuf);\n\t\tgoto fail;\n\t}\n\tdev->buf = kbuf;\n\n\t/* full or low speed config */\n\tdev->config = (void *) kbuf;\n\ttotal = le16_to_cpu(dev->config->wTotalLength);\n\tif (!is_valid_config(dev->config, total) ||\n\t\t\ttotal > length - USB_DT_DEVICE_SIZE)\n\t\tgoto fail;\n\tkbuf += total;\n\tlength -= total;\n\n\t/* optional high speed config */\n\tif (kbuf [1] == USB_DT_CONFIG) {\n\t\tdev->hs_config = (void *) kbuf;\n\t\ttotal = le16_to_cpu(dev->hs_config->wTotalLength);\n\t\tif (!is_valid_config(dev->hs_config, total) ||\n\t\t\t\ttotal > length - USB_DT_DEVICE_SIZE)\n\t\t\tgoto fail;\n\t\tkbuf += total;\n\t\tlength -= total;\n\t} else {\n\t\tdev->hs_config = NULL;\n\t}\n\n\t/* could support multiple configs, using another encoding! */\n\n\t/* device descriptor (tweaked for paranoia) */\n\tif (length != USB_DT_DEVICE_SIZE)\n\t\tgoto fail;\n\tdev->dev = (void *)kbuf;\n\tif (dev->dev->bLength != USB_DT_DEVICE_SIZE\n\t\t\t|| dev->dev->bDescriptorType != USB_DT_DEVICE\n\t\t\t|| dev->dev->bNumConfigurations != 1)\n\t\tgoto fail;\n\tdev->dev->bcdUSB = cpu_to_le16 (0x0200);\n\n\t/* triggers gadgetfs_bind(); then we can enumerate. */\n\tspin_unlock_irq (&dev->lock);\n\tif (dev->hs_config)\n\t\tgadgetfs_driver.max_speed = USB_SPEED_HIGH;\n\telse\n\t\tgadgetfs_driver.max_speed = USB_SPEED_FULL;\n\n\tvalue = usb_gadget_probe_driver(&gadgetfs_driver);\n\tif (value != 0) {\n\t\tkfree (dev->buf);\n\t\tdev->buf = NULL;\n\t} else {\n\t\t/* at this point \"good\" hardware has for the first time\n\t\t * let the USB the host see us.  alternatively, if users\n\t\t * unplug/replug that will clear all the error state.\n\t\t *\n\t\t * note:  everything running before here was guaranteed\n\t\t * to choke driver model style diagnostics.  from here\n\t\t * on, they can work ... except in cleanup paths that\n\t\t * kick in after the ep0 descriptor is closed.\n\t\t */\n\t\tvalue = len;\n\t\tdev->gadget_registered = true;\n\t}\n\treturn value;\n\nfail:\n\tspin_unlock_irq (&dev->lock);\n\tpr_debug (\"%s: %s fail %zd, %p\\n\", shortname, __func__, value, dev);\n\tkfree (dev->buf);\n\tdev->buf = NULL;\n\treturn value;\n}", "func_hash": 339900816673316733531042403989601737669, "file_name": "inode.c", "file_hash": 285517450790200814550043247346710912339, "cwe": ["CWE-763"], "cve": "CVE-2022-24958", "cve_desc": "drivers/usb/gadget/legacy/inode.c in the Linux kernel through 5.16.8 mishandles dev->buf release.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-24958"}
{"idx": 90224, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual bool wifi_available() const {\n    return available_devices_ & (1 << TYPE_WIFI);\n  }\n", "func_hash": 226315973824881959437856633924685238390, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90873, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  int64 available_space() const { return available_space_; }\n", "func_hash": 35308761641739534118531901986019397780, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 195261, "project": "tensorflow", "commit_id": "955059813cc325dc1db5e2daa6221271406d4439", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/955059813cc325dc1db5e2daa6221271406d4439", "commit_message": "Check for type inference error on node construction.\n\nPiperOrigin-RevId: 409415804\nChange-Id: Ieb6e020906b96f522bf8e2fa103715ddbbdc434a", "target": 1, "func": "Node* Graph::AddNode(NodeDef node_def, Status* status) {\n  const OpRegistrationData* op_reg_data;\n  status->Update(ops_.LookUp(node_def.op(), &op_reg_data));\n  if (!status->ok()) return nullptr;\n\n  DataTypeVector inputs;\n  DataTypeVector outputs;\n  status->Update(\n      InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs));\n  if (!status->ok()) {\n    *status = AttachDef(*status, node_def);\n    return nullptr;\n  }\n\n  Node::NodeClass node_class = op_reg_data->is_function_op\n                                   ? Node::NC_FUNCTION_OP\n                                   : Node::GetNodeClassForOp(node_def.op());\n\n  if (op_reg_data->type_ctor != nullptr) {\n    VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();\n    const auto ctor_type =\n        full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);\n    const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();\n    if (ctor_typedef.type_id() != TFT_UNSET) {\n      *(node_def.mutable_experimental_type()) = ctor_typedef;\n    }\n  } else {\n    VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();\n  }\n\n  Node* node = AllocateNode(std::make_shared<NodeProperties>(\n                                &op_reg_data->op_def, std::move(node_def),\n                                inputs, outputs, op_reg_data->fwd_type_fn),\n                            nullptr, node_class);\n  return node;\n}", "func_hash": 216608112162338080739127582529653382623, "file_name": "graph.cc", "file_hash": 171004513035817799651733534811388619872, "cwe": ["CWE-754"], "cve": "CVE-2022-23590", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. A `GraphDef` from a TensorFlow `SavedModel` can be maliciously altered to cause a TensorFlow process to crash due to encountering a `StatusOr` value that is an error and forcibly extracting the value from it. We have patched the issue in multiple GitHub commits and these will be included in TensorFlow 2.8.0 and TensorFlow 2.7.1, as both are affected.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23590"}
{"idx": 220864, "project": "tensorflow", "commit_id": "8c6f391a2282684a25cbfec7687bd5d35261a209", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/8c6f391a2282684a25cbfec7687bd5d35261a209", "commit_message": "[lite] Add check for bias_size is zero to avoid division by zero. This shouldn't happen for properly converted models. Just safety check\n\nPiperOrigin-RevId: 416383645\nChange-Id: If8e508bf696ae8ecfb927e69c139a8ccf7fe60cb", "target": 0, "func": "inline int32_t MultiplyByQuantizedMultiplierGreaterThanOne(\n    int32_t x, int32_t quantized_multiplier, int shift) {\n  TFLITE_DCHECK_GE(shift, 0);\n  return MultiplyByQuantizedMultiplier(x, quantized_multiplier, shift);\n}", "func_hash": 135742229959335792779280028774611188296, "file_name": "common.h", "file_hash": 206010119069068373550820723284960883967, "cwe": ["CWE-369"], "cve": "CVE-2022-23557", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would trigger a division by zero in `BiasAndClamp` implementation. There is no check that the `bias_size` is non zero. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23557"}
{"idx": 204495, "project": "linux", "commit_id": "47abea041f897d64dbd5777f0cf7745148f85d75", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/47abea041f897d64dbd5777f0cf7745148f85d75", "commit_message": "io_uring: fix off-by-one in sync cancelation file check\n\nThe passed in index should be validated against the number of registered\nfiles we have, it needs to be smaller than the index value to avoid going\none beyond the end.\n\nFixes: 78a861b94959 (\"io_uring: add sync cancelation API through io_uring_register()\")\nReported-by: Luo Likang <luolikang@nsfocus.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>", "target": 1, "func": "static int __io_sync_cancel(struct io_uring_task *tctx,\n\t\t\t    struct io_cancel_data *cd, int fd)\n{\n\tstruct io_ring_ctx *ctx = cd->ctx;\n\n\t/* fixed must be grabbed every time since we drop the uring_lock */\n\tif ((cd->flags & IORING_ASYNC_CANCEL_FD) &&\n\t    (cd->flags & IORING_ASYNC_CANCEL_FD_FIXED)) {\n\t\tunsigned long file_ptr;\n\n\t\tif (unlikely(fd > ctx->nr_user_files))\n\t\t\treturn -EBADF;\n\t\tfd = array_index_nospec(fd, ctx->nr_user_files);\n\t\tfile_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr;\n\t\tcd->file = (struct file *) (file_ptr & FFS_MASK);\n\t\tif (!cd->file)\n\t\t\treturn -EBADF;\n\t}\n\n\treturn __io_async_cancel(cd, tctx, 0);\n}", "func_hash": 178631003172617197260225259743936148137, "file_name": "cancel.c", "file_hash": 251597362135051290688561510710144448867, "cwe": ["CWE-193"], "cve": "CVE-2022-3103", "cve_desc": "off-by-one in io_uring module.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3103"}
{"idx": 90881, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  int status_callback_count() const { return status_callback_count_; }\n", "func_hash": 188413144849519460253858134850842747409, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 221393, "project": "linux", "commit_id": "c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc", "commit_message": "KVM: nSVM: always intercept VMLOAD/VMSAVE when nested (CVE-2021-3656)\n\nIf L1 disables VMLOAD/VMSAVE intercepts, and doesn't enable\nVirtual VMLOAD/VMSAVE (currently not supported for the nested hypervisor),\nthen VMLOAD/VMSAVE must operate on the L1 physical memory, which is only\npossible by making L0 intercept these instructions.\n\nFailure to do so allowed the nested guest to run VMLOAD/VMSAVE unintercepted,\nand thus read/write portions of the host physical memory.\n\nFixes: 89c8a4984fc9 (\"KVM: SVM: Enable Virtual VMLOAD VMSAVE feature\")\n\nSuggested-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Maxim Levitsky <mlevitsk@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "target": 0, "func": "void svm_leave_nested(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\tif (is_guest_mode(vcpu)) {\n\t\tsvm->nested.nested_run_pending = 0;\n\t\tsvm->nested.vmcb12_gpa = INVALID_GPA;\n\n\t\tleave_guest_mode(vcpu);\n\n\t\tsvm_switch_vmcb(svm, &svm->vmcb01);\n\n\t\tnested_svm_uninit_mmu_context(vcpu);\n\t\tvmcb_mark_all_dirty(svm->vmcb);\n\t}\n\n\tkvm_clear_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu);\n}", "func_hash": 45498705495892756367904775259102357664, "file_name": "None", "file_hash": null, "cwe": ["CWE-862"], "cve": "CVE-2021-3656", "cve_desc": "A flaw was found in the KVM's AMD code for supporting SVM nested virtualization. The flaw occurs when processing the VMCB (virtual machine control block) provided by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation of the \"virt_ext\" field, this issue could allow a malicious L1 to disable both VMLOAD/VMSAVE intercepts and VLS (Virtual VMLOAD/VMSAVE) for the L2 guest. As a result, the L2 guest would be allowed to read/write physical pages of the host, resulting in a crash of the entire system, leak of sensitive data or potential guest-to-host escape.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3656"}
{"idx": 220220, "project": "tensorflow", "commit_id": "c99d98cd189839dcf51aee94e7437b54b31f8abd", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/c99d98cd189839dcf51aee94e7437b54b31f8abd", "commit_message": "Handle invalid inputs instead of crashing.\n\nPiperOrigin-RevId: 409549744\nChange-Id: I7f5935b34b53f7e426a5462fcc027bdbf5dcda24", "target": 0, "func": "void Graph::RemoveNode(Node* node) {\n  TF_DCHECK_OK(IsValidNode(node)) << node->DebugString();\n  DCHECK(!node->IsSource());\n  DCHECK(!node->IsSink());\n\n  // Remove any edges involving this node.\n  for (const Edge* e : node->in_edges_) {\n    CHECK_EQ(e->src_->out_edges_.erase(e), size_t{1});\n    edges_[e->id_] = nullptr;\n    RecycleEdge(e);\n    --num_edges_;\n  }\n  node->in_edges_.clear();\n  for (const Edge* e : node->out_edges_) {\n    CHECK_EQ(e->dst_->in_edges_.erase(e), size_t{1});\n    edges_[e->id_] = nullptr;\n    RecycleEdge(e);\n    --num_edges_;\n  }\n  node->out_edges_.clear();\n  ReleaseNode(node);\n}", "func_hash": 228141351483367580033080203910181495095, "file_name": "graph.cc", "file_hash": 172099243927919341591512227523808328051, "cwe": ["CWE-125"], "cve": "CVE-2022-23592", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. TensorFlow's type inference can cause a heap out of bounds read as the bounds checking is done in a `DCHECK` (which is a no-op during production). An attacker can control the `input_idx` variable such that `ix` would be larger than the number of values in `node_t.args`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23592"}
{"idx": 221074, "project": "tensorflow", "commit_id": "8a513cec4bec15961fbfdedcaa5376522980455c", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/8a513cec4bec15961fbfdedcaa5376522980455c", "commit_message": "Prevent null dereference read in `SpecializeType()`\n\nFor some adversarial protos, the attribute for a key might not exist.\n\nPiperOrigin-RevId: 408382090\nChange-Id: Ie7eabe532c9ff280fce5dce1f6cdb93c76c2e040", "target": 0, "func": "OpTypeConstructor UnaryTensorContainer(FullTypeId t, FullTypeId dtype) {\n  return [t, dtype](OpDef* op_def) {\n    FullTypeDef* tdef =\n        op_def->mutable_output_arg(0)->mutable_experimental_full_type();\n    tdef->set_type_id(t);\n\n    FullTypeDef* arg = tdef->add_args();\n    arg->set_type_id(TFT_TENSOR);\n    FullTypeDef* targ = arg->add_args();\n    targ->set_type_id(dtype);\n\n    return Status::OK();\n  };\n}", "func_hash": 323166107944987198215977731683712134503, "file_name": "full_type_util.cc", "file_hash": 314176305959180493784229267362521072211, "cwe": ["CWE-617"], "cve": "CVE-2022-23570", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. When decoding a tensor from protobuf, TensorFlow might do a null-dereference if attributes of some mutable arguments to some operations are missing from the proto. This is guarded by a `DCHECK`. However, `DCHECK` is a no-op in production builds and an assertion failure in debug builds. In the first case execution proceeds to the dereferencing of the null pointer, whereas in the second case it results in a crash due to the assertion failure. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, and TensorFlow 2.6.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23570"}
{"idx": 177169, "project": "Chrome", "commit_id": "2bfb2b8299e2fb6a432390a93a99a85fed1d29c9", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/2bfb2b8299e2fb6a432390a93a99a85fed1d29c9", "commit_message": "None", "target": 0, "func": "void WebProcessProxy::didBecomeResponsive(ResponsivenessTimer*)\n{\n    Vector<RefPtr<WebPageProxy> > pages;\n    copyValuesToVector(m_pageMap, pages);\n    for (size_t i = 0, size = pages.size(); i < size; ++i)\n        pages[i]->processDidBecomeResponsive();\n}\n", "func_hash": 305780027283176982755471671366831526154, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 139246, "project": "Chrome", "commit_id": "fb83de09f2c986ee91741f3a2776feea0e18e3f6", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/fb83de09f2c986ee91741f3a2776feea0e18e3f6", "commit_message": "None", "target": 0, "func": "void OverlayWindowViews::TogglePlayPause() {\n  bool is_active = controller_->TogglePlayPause();\n  play_pause_controls_view_->SetToggled(is_active);\n}\n", "func_hash": 187264438110589997663232529122624549444, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 212934, "project": "cyrus-imapd", "commit_id": "621f9e41465b521399f691c241181300fab55995", "project_url": "https://github.com/cyrusimap/cyrus-imapd", "commit_url": "https://github.com/cyrusimap/cyrus-imapd/commit/621f9e41465b521399f691c241181300fab55995", "commit_message": "annotate: don't allow everyone to write shared server entries", "target": 1, "func": "static int write_entry(struct mailbox *mailbox,\n                       unsigned int uid,\n                       const char *entry,\n                       const char *userid,\n                       const struct buf *value,\n                       int ignorequota,\n                       int silent,\n                       const struct annotate_metadata *mdata,\n                       int maywrite)\n\n{\n    char key[MAX_MAILBOX_PATH+1];\n    int keylen, r;\n    annotate_db_t *d = NULL;\n    struct buf oldval = BUF_INITIALIZER;\n    const char *mboxname = mailbox ? mailbox->name : \"\";\n    modseq_t modseq = mdata ? mdata->modseq : 0;\n\n    r = _annotate_getdb(mboxname, uid, CYRUSDB_CREATE, &d);\n    if (r)\n        return r;\n\n    /* must be in a transaction to modify the db */\n    annotate_begin(d);\n\n    keylen = make_key(mboxname, uid, entry, userid, key, sizeof(key));\n\n    if (mailbox) {\n        struct annotate_metadata oldmdata;\n        r = read_old_value(d, key, keylen, &oldval, &oldmdata);\n        if (r) goto out;\n\n        /* if the value is identical, don't touch the mailbox */\n        if (oldval.len == value->len && (!value->len || !memcmp(oldval.s, value->s, value->len)))\n            goto out;\n\n        if (!ignorequota) {\n            quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;\n            qdiffs[QUOTA_ANNOTSTORAGE] = value->len - (quota_t)oldval.len;\n            r = mailbox_quota_check(mailbox, qdiffs);\n            if (r) goto out;\n        }\n\n        if (!maywrite) {\n            r = IMAP_PERMISSION_DENIED;\n            if (r) goto out;\n        }\n\n        /* do the annot-changed here before altering the DB */\n        mailbox_annot_changed(mailbox, uid, entry, userid, &oldval, value, silent);\n\n        /* grab the message annotation modseq, if not overridden */\n        if (uid && !mdata) {\n            modseq = mailbox->i.highestmodseq;\n        }\n    }\n\n    /* zero length annotation is deletion.\n     * keep tombstones for message annotations */\n    if (!value->len && !uid) {\n\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: deleting key %s from %s\",\n                key_as_string(d, key, keylen), d->filename);\n#endif\n\n        do {\n            r = cyrusdb_delete(d->db, key, keylen, tid(d), /*force*/1);\n        } while (r == CYRUSDB_AGAIN);\n    }\n    else {\n        struct buf data = BUF_INITIALIZER;\n        unsigned char flags = 0;\n        if (!value->len || value->s == NULL) {\n            flags |= ANNOTATE_FLAG_DELETED;\n        }\n        else {\n            // this is only here to allow cleanup of invalid values in the past...\n            // the calling of this API with a NULL \"userid\" is bogus, because that's\n            // supposed to be reserved for the make_key of prefixes - but there has\n            // been API abuse in the past, so some of these are in the wild.  *sigh*.\n            // Don't allow new ones to be written\n            if (!userid) goto out;\n        }\n        make_entry(&data, value, modseq, flags);\n\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: storing key %s (value: %s) to %s (modseq=\" MODSEQ_FMT \")\",\n                key_as_string(d, key, keylen), value->s, d->filename, modseq);\n#endif\n\n        do {\n            r = cyrusdb_store(d->db, key, keylen, data.s, data.len, tid(d));\n        } while (r == CYRUSDB_AGAIN);\n        buf_free(&data);\n    }\n\n    if (!mailbox)\n        sync_log_annotation(\"\");\n\nout:\n    annotate_putdb(&d);\n    buf_free(&oldval);\n\n    return r;\n}", "func_hash": 63211042070136121773849314849857565491, "file_name": "annotate.c", "file_hash": 152032054661376167383830098805318046193, "cwe": ["CWE-732"], "cve": "CVE-2021-32056", "cve_desc": "Cyrus IMAP before 3.2.7, and 3.3.x and 3.4.x before 3.4.1, allows remote authenticated users to bypass intended access restrictions on server annotations and consequently cause replication to stall.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-32056"}
{"idx": 90118, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual void ConnectToWifiNetwork(const WifiNetwork* network,\n                                    const std::string& password,\n                                    const std::string& identity,\n                                    const std::string& certpath) {\n    DCHECK(network);\n    if (!EnsureCrosLoaded())\n      return;\n    if (ConnectToNetworkWithCertInfo(network->service_path().c_str(),\n        password.empty() ? NULL : password.c_str(),\n        identity.empty() ? NULL : identity.c_str(),\n        certpath.empty() ? NULL : certpath.c_str())) {\n      WifiNetwork* wifi = GetWirelessNetworkByPath(\n          wifi_networks_, network->service_path());\n      if (wifi) {\n        wifi->set_passphrase(password);\n        wifi->set_identity(identity);\n        wifi->set_cert_path(certpath);\n        wifi->set_connecting(true);\n        wifi_ = wifi;\n      }\n      NotifyNetworkManagerChanged();\n    }\n  }\n", "func_hash": 15685958005356315142055036861470092720, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 139224, "project": "Chrome", "commit_id": "fb83de09f2c986ee91741f3a2776feea0e18e3f6", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/fb83de09f2c986ee91741f3a2776feea0e18e3f6", "commit_message": "None", "target": 0, "func": "ui::Layer* OverlayWindowViews::GetResizeHandleLayer() {\n  return resize_handle_view_->layer();\n}\n", "func_hash": 326719211097409904458445305655540233774, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 96954, "project": "Chrome", "commit_id": "3c1864079c441ea2e08f882acaaf441f78a6de3d", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/3c1864079c441ea2e08f882acaaf441f78a6de3d", "commit_message": "None", "target": 0, "func": "void encode(ArgumentEncoder* encoder, CFDataRef data)\n{\n    CFIndex length = CFDataGetLength(data);\n    const UInt8* bytePtr = CFDataGetBytePtr(data);\n\n    encoder->encodeVariableLengthByteArray(CoreIPC::DataReference(bytePtr, length));\n}\n", "func_hash": 212565696779616042911770132122228578000, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90110, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "CellularNetwork::CellularNetwork()\n    : WirelessNetwork(),\n      activation_state_(ACTIVATION_STATE_UNKNOWN),\n      network_technology_(NETWORK_TECHNOLOGY_UNKNOWN),\n      roaming_state_(ROAMING_STATE_UNKNOWN),\n      restricted_pool_(false),\n      prl_version_(0) {\n  type_ = TYPE_CELLULAR;\n}\n", "func_hash": 252380351537756827079597733078591804638, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 181942, "project": "Chrome", "commit_id": "fb83de09f2c986ee91741f3a2776feea0e18e3f6", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/fb83de09f2c986ee91741f3a2776feea0e18e3f6", "commit_message": "None", "target": 0, "func": "gfx::Size OverlayWindowViews::GetMinimumSize() const {\n  return min_size_;\n}\n", "func_hash": 14470143283206508923724494390125041576, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 214335, "project": "ceph", "commit_id": "be7679007c3dfab3e19c22c38c36ccac91828e3b", "project_url": "https://github.com/ceph/ceph", "commit_url": "https://github.com/ceph/ceph/commit/be7679007c3dfab3e19c22c38c36ccac91828e3b", "commit_message": "rgw: reject control characters in response-header actions\n\nS3 GetObject permits overriding response header values, but those inputs\nneed to be validated to insure only characters that are valid in an HTTP\nheader value are present.\n\nCredit: Initial vulnerability discovery by William Bowling (@wcbowling)\nCredit: Further vulnerability discovery by Robin H. Johnson <rjohnson@digitalocean.com>\nSigned-off-by: Robin H. Johnson <rjohnson@digitalocean.com>", "target": 1, "func": "int RGWGetObj_ObjStore_S3::send_response_data(bufferlist& bl, off_t bl_ofs,\n\t\t\t\t\t      off_t bl_len)\n{\n  const char *content_type = NULL;\n  string content_type_str;\n  map<string, string> response_attrs;\n  map<string, string>::iterator riter;\n  bufferlist metadata_bl;\n\n  string expires = get_s3_expiration_header(s, lastmod);\n\n  if (sent_header)\n    goto send_data;\n\n  if (custom_http_ret) {\n    set_req_state_err(s, 0);\n    dump_errno(s, custom_http_ret);\n  } else {\n    set_req_state_err(s, (partial_content && !op_ret) ? STATUS_PARTIAL_CONTENT\n                  : op_ret);\n    dump_errno(s);\n  }\n\n  if (op_ret)\n    goto done;\n\n  if (range_str)\n    dump_range(s, start, end, s->obj_size);\n\n  if (s->system_request &&\n      s->info.args.exists(RGW_SYS_PARAM_PREFIX \"prepend-metadata\")) {\n\n    dump_header(s, \"Rgwx-Object-Size\", (long long)total_len);\n\n    if (rgwx_stat) {\n      /*\n       * in this case, we're not returning the object's content, only the prepended\n       * extra metadata\n       */\n      total_len = 0;\n    }\n\n    /* JSON encode object metadata */\n    JSONFormatter jf;\n    jf.open_object_section(\"obj_metadata\");\n    encode_json(\"attrs\", attrs, &jf);\n    utime_t ut(lastmod);\n    encode_json(\"mtime\", ut, &jf);\n    jf.close_section();\n    stringstream ss;\n    jf.flush(ss);\n    metadata_bl.append(ss.str());\n    dump_header(s, \"Rgwx-Embedded-Metadata-Len\", metadata_bl.length());\n    total_len += metadata_bl.length();\n  }\n\n  if (s->system_request && !real_clock::is_zero(lastmod)) {\n    /* we end up dumping mtime in two different methods, a bit redundant */\n    dump_epoch_header(s, \"Rgwx-Mtime\", lastmod);\n    uint64_t pg_ver = 0;\n    int r = decode_attr_bl_single_value(attrs, RGW_ATTR_PG_VER, &pg_ver, (uint64_t)0);\n    if (r < 0) {\n      ldpp_dout(this, 0) << \"ERROR: failed to decode pg ver attr, ignoring\" << dendl;\n    }\n    dump_header(s, \"Rgwx-Obj-PG-Ver\", pg_ver);\n\n    uint32_t source_zone_short_id = 0;\n    r = decode_attr_bl_single_value(attrs, RGW_ATTR_SOURCE_ZONE, &source_zone_short_id, (uint32_t)0);\n    if (r < 0) {\n      ldpp_dout(this, 0) << \"ERROR: failed to decode pg ver attr, ignoring\" << dendl;\n    }\n    if (source_zone_short_id != 0) {\n      dump_header(s, \"Rgwx-Source-Zone-Short-Id\", source_zone_short_id);\n    }\n  }\n\n  for (auto &it : crypt_http_responses)\n    dump_header(s, it.first, it.second);\n\n  dump_content_length(s, total_len);\n  dump_last_modified(s, lastmod);\n  dump_header_if_nonempty(s, \"x-amz-version-id\", version_id);\n  dump_header_if_nonempty(s, \"x-amz-expiration\", expires);\n\n  if (attrs.find(RGW_ATTR_APPEND_PART_NUM) != attrs.end()) {\n    dump_header(s, \"x-rgw-object-type\", \"Appendable\");\n    dump_header(s, \"x-rgw-next-append-position\", s->obj_size);\n  } else {\n    dump_header(s, \"x-rgw-object-type\", \"Normal\");\n  }\n\n  if (! op_ret) {\n    if (! lo_etag.empty()) {\n      /* Handle etag of Swift API's large objects (DLO/SLO). It's entirerly\n       * legit to perform GET on them through S3 API. In such situation,\n       * a client should receive the composited content with corresponding\n       * etag value. */\n      dump_etag(s, lo_etag);\n    } else {\n      auto iter = attrs.find(RGW_ATTR_ETAG);\n      if (iter != attrs.end()) {\n        dump_etag(s, iter->second.to_str());\n      }\n    }\n\n    for (struct response_attr_param *p = resp_attr_params; p->param; p++) {\n      bool exists;\n      string val = s->info.args.get(p->param, &exists);\n      if (exists) {\n\t/* reject unauthenticated response header manipulation, see\n\t * https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html */\n\tif (s->auth.identity->is_anonymous()) {\n\t  return -ERR_INVALID_REQUEST;\n\t}\n\tif (strcmp(p->param, \"response-content-type\") != 0) {\n\t  response_attrs[p->http_attr] = val;\n\t} else {\n\t  content_type_str = val;\n\t  content_type = content_type_str.c_str();\n\t}\n      }\n    }\n\n    for (auto iter = attrs.begin(); iter != attrs.end(); ++iter) {\n      const char *name = iter->first.c_str();\n      map<string, string>::iterator aiter = rgw_to_http_attrs.find(name);\n      if (aiter != rgw_to_http_attrs.end()) {\n        if (response_attrs.count(aiter->second) == 0) {\n          /* Was not already overridden by a response param. */\n\n          size_t len = iter->second.length();\n          string s(iter->second.c_str(), len);\n          while (len && !s[len - 1]) {\n            --len;\n            s.resize(len);\n          }\n          response_attrs[aiter->second] = s;\n        }\n      } else if (iter->first.compare(RGW_ATTR_CONTENT_TYPE) == 0) {\n        /* Special handling for content_type. */\n        if (!content_type) {\n          content_type_str = rgw_bl_str(iter->second);\n          content_type = content_type_str.c_str();\n        }\n      } else if (strcmp(name, RGW_ATTR_SLO_UINDICATOR) == 0) {\n        // this attr has an extra length prefix from encode() in prior versions\n        dump_header(s, \"X-Object-Meta-Static-Large-Object\", \"True\");\n      } else if (strncmp(name, RGW_ATTR_META_PREFIX,\n\t\t\t sizeof(RGW_ATTR_META_PREFIX)-1) == 0) {\n        /* User custom metadata. */\n        name += sizeof(RGW_ATTR_PREFIX) - 1;\n        dump_header(s, name, iter->second);\n      } else if (iter->first.compare(RGW_ATTR_TAGS) == 0) {\n        RGWObjTags obj_tags;\n        try{\n          auto it = iter->second.cbegin();\n          obj_tags.decode(it);\n        } catch (buffer::error &err) {\n          ldpp_dout(this,0) << \"Error caught buffer::error couldn't decode TagSet \" << dendl;\n        }\n        dump_header(s, RGW_AMZ_TAG_COUNT, obj_tags.count());\n      } else if (iter->first.compare(RGW_ATTR_OBJECT_RETENTION) == 0 && get_retention){\n        RGWObjectRetention retention;\n        try {\n          decode(retention, iter->second);\n          dump_header(s, \"x-amz-object-lock-mode\", retention.get_mode());\n          dump_time_header(s, \"x-amz-object-lock-retain-until-date\", retention.get_retain_until_date());\n        } catch (buffer::error& err) {\n          ldpp_dout(this, 0) << \"ERROR: failed to decode RGWObjectRetention\" << dendl;\n        }\n      } else if (iter->first.compare(RGW_ATTR_OBJECT_LEGAL_HOLD) == 0 && get_legal_hold) {\n        RGWObjectLegalHold legal_hold;\n        try {\n          decode(legal_hold, iter->second);\n          dump_header(s, \"x-amz-object-lock-legal-hold\",legal_hold.get_status());\n        } catch (buffer::error& err) {\n          ldpp_dout(this, 0) << \"ERROR: failed to decode RGWObjectLegalHold\" << dendl;\n        }\n      }\n    }\n  }\n\ndone:\n  for (riter = response_attrs.begin(); riter != response_attrs.end();\n       ++riter) {\n    dump_header(s, riter->first, riter->second);\n  }\n\n  if (op_ret == -ERR_NOT_MODIFIED) {\n      end_header(s, this);\n  } else {\n      if (!content_type)\n          content_type = \"binary/octet-stream\";\n\n      end_header(s, this, content_type);\n  }\n\n  if (metadata_bl.length()) {\n    dump_body(s, metadata_bl);\n  }\n  sent_header = true;\n\nsend_data:\n  if (get_data && !op_ret) {\n    int r = dump_body(s, bl.c_str() + bl_ofs, bl_len);\n    if (r < 0)\n      return r;\n  }\n\n  return 0;\n}", "func_hash": 252320959275346519647300715417843120718, "file_name": "rgw_rest_s3.cc", "file_hash": 121704064633287557349192949015382644860, "cwe": ["CWE-79"], "cve": "CVE-2020-1760", "cve_desc": "A flaw was found in the Ceph Object Gateway, where it supports request sent by an anonymous user in Amazon S3. This flaw could lead to potential XSS attacks due to the lack of proper neutralization of untrusted input.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-1760"}
{"idx": 90858, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  void GetTemporaryGlobalQuota() {\n    quota_status_ = kQuotaStatusUnknown;\n    quota_ = -1;\n    quota_manager_->GetTemporaryGlobalQuota(\n        callback_factory_.NewCallback(\n            &QuotaManagerTest::DidGetQuota));\n  }\n", "func_hash": 180441123855268097697686766179790527745, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 197632, "project": "njs", "commit_id": "6a40a85ff239497c6458c7dbef18f6a2736fe992", "project_url": "https://github.com/nginx/njs", "commit_url": "https://github.com/nginx/njs/commit/6a40a85ff239497c6458c7dbef18f6a2736fe992", "commit_message": "Fixed type confusion bug while resolving promises.\n\nPreviously, the internal function njs_promise_perform_then() which\nimplements PerformPromiseThen() expects its first argument to always be\na promise instance.  This assertion might be invalid because the\nfunctions corresponding to Promise.prototype.then() and\nPromise.resolve() incorrectly verified their arguments.\n\nSpecifically, the functions recognized their first argument as promise\nif it was an object which was an Promise or had Promise object in its\nprototype chain.  The later condition is not correct because internal\nslots are not inherited according to the spec.\n\nThis closes #447 issue in Github.", "target": 1, "func": "njs_promise_perform_then(njs_vm_t *vm, njs_value_t *value,\n    njs_value_t *fulfilled, njs_value_t *rejected,\n    njs_promise_capability_t *capability)\n{\n    njs_int_t               ret;\n    njs_value_t             arguments[2];\n    njs_promise_t           *promise;\n    njs_function_t          *function;\n    njs_promise_data_t      *data;\n    njs_promise_reaction_t  *fulfilled_reaction, *rejected_reaction;\n\n    if (!njs_is_function(fulfilled)) {\n        fulfilled = njs_value_arg(&njs_value_undefined);\n    }\n\n    if (!njs_is_function(rejected)) {\n        rejected = njs_value_arg(&njs_value_undefined);\n    }\n\n    promise = njs_promise(value);\n    data = njs_data(&promise->value);\n\n    fulfilled_reaction = njs_mp_alloc(vm->mem_pool,\n                                      sizeof(njs_promise_reaction_t));\n    if (njs_slow_path(fulfilled_reaction == NULL)) {\n        njs_memory_error(vm);\n        return NJS_ERROR;\n    }\n\n    fulfilled_reaction->capability = capability;\n    fulfilled_reaction->handler = *fulfilled;\n    fulfilled_reaction->type = NJS_PROMISE_FULFILL;\n\n    rejected_reaction = njs_mp_alloc(vm->mem_pool,\n                                     sizeof(njs_promise_reaction_t));\n    if (njs_slow_path(rejected_reaction == NULL)) {\n        njs_memory_error(vm);\n        return NJS_ERROR;\n    }\n\n    rejected_reaction->capability = capability;\n    rejected_reaction->handler = *rejected;\n    rejected_reaction->type = NJS_PROMISE_REJECTED;\n\n    if (data->state == NJS_PROMISE_PENDING) {\n        njs_queue_insert_tail(&data->fulfill_queue, &fulfilled_reaction->link);\n        njs_queue_insert_tail(&data->reject_queue, &rejected_reaction->link);\n\n    } else {\n        function = njs_promise_create_function(vm,\n                                               sizeof(njs_promise_context_t));\n        function->u.native = njs_promise_reaction_job;\n\n        if (data->state == NJS_PROMISE_REJECTED) {\n            njs_set_data(&arguments[0], rejected_reaction, 0);\n\n            ret = njs_promise_host_rejection_tracker(vm, promise,\n                                                     NJS_PROMISE_HANDLE);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n        } else {\n            njs_set_data(&arguments[0], fulfilled_reaction, 0);\n        }\n\n        arguments[1] = data->result;\n\n        ret = njs_promise_add_event(vm, function, arguments, 2);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    data->is_handled = 1;\n\n    if (capability == NULL) {\n        njs_vm_retval_set(vm, &njs_value_undefined);\n\n    } else {\n        njs_vm_retval_set(vm, &capability->promise);\n    }\n\n    return NJS_OK;\n}", "func_hash": 181580372713190612781917074071493405711, "file_name": "njs_promise.c", "file_hash": 261469139723432841860734117510139062920, "cwe": ["CWE-269"], "cve": "CVE-2021-46463", "cve_desc": "njs through 0.7.1, used in NGINX, was discovered to contain a control flow hijack caused by a Type Confusion vulnerability in njs_promise_perform_then().", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-46463"}
{"idx": 220805, "project": "tensorflow", "commit_id": "2b7100d6cdff36aa21010a82269bc05a6d1cc74a", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/2b7100d6cdff36aa21010a82269bc05a6d1cc74a", "commit_message": "Cleanup and remove duplicate validation in `SparseCount`.\n\nWe have valdiation that is duplicated, checking different conditions, in different formats and failing to capture all cases. This should fix all the previous bugs.\n\nPiperOrigin-RevId: 414886981\nChange-Id: Ibf0bba0beb057b76d505324bb9487565daf95f01", "target": 0, "func": "  explicit SparseCount(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"minlength\", &minlength_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"maxlength\", &maxlength_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"binary_output\", &binary_output_));\n  }", "func_hash": 255686253379861343136942384799404809714, "file_name": "count_ops.cc", "file_hash": 221778566959720819887290009238961995785, "cwe": ["CWE-787"], "cve": "CVE-2022-21740", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `SparseCountSparseOutput` is vulnerable to a heap overflow. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-21740"}
{"idx": 198146, "project": "tensorflow", "commit_id": "429f009d2b2c09028647dd4bb7b3f6f414bbaad7", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/429f009d2b2c09028647dd4bb7b3f6f414bbaad7", "commit_message": "Add remaining missing validation to `BoostedTreesCalculateBestFeatureSplit`\n\nPiperOrigin-RevId: 387423006\nChange-Id: I8eaf30efb223011519e60707bfa751b275d3a443", "target": 1, "func": "  void Compute(OpKernelContext* const context) override {\n    // node_id_range\n    const Tensor* node_id_range_t;\n    OP_REQUIRES_OK(context, context->input(\"node_id_range\", &node_id_range_t));\n    const auto node_id_range = node_id_range_t->vec<int32>();\n    const int32_t node_id_first = node_id_range(0);  // inclusive\n    const int32_t node_id_last = node_id_range(1);   // exclusive\n\n    const Tensor* stats_summary_t;\n    OP_REQUIRES_OK(context, context->input(\"stats_summary\", &stats_summary_t));\n    TTypes<float, 4>::ConstTensor stats_summary =\n        stats_summary_t->tensor<float, 4>();\n    const int32_t feature_dims = stats_summary_t->dim_size(1);\n    // The last bucket is for default/missing value.\n    const int32_t num_buckets = stats_summary_t->dim_size(2) - 1;\n    const int32_t logits_dim = logits_dim_;\n    const int32_t hessian_dim = stats_summary_t->dim_size(3) - logits_dim;\n    DCHECK_GT(hessian_dim, 0);\n    DCHECK_LE(hessian_dim, logits_dim * logits_dim);\n\n    const Tensor* l1_t;\n    OP_REQUIRES_OK(context, context->input(\"l1\", &l1_t));\n    const auto l1 = l1_t->scalar<float>()();\n    DCHECK_GE(l1, 0);\n    if (logits_dim_ > 1) {\n      // Multi-class L1 regularization not supported yet.\n      DCHECK_EQ(l1, 0);\n    }\n\n    const Tensor* l2_t;\n    OP_REQUIRES_OK(context, context->input(\"l2\", &l2_t));\n    const auto l2 = l2_t->scalar<float>()();\n    DCHECK_GE(l2, 0);\n\n    const Tensor* tree_complexity_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"tree_complexity\", &tree_complexity_t));\n    const auto tree_complexity = tree_complexity_t->scalar<float>()();\n\n    const Tensor* min_node_weight_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"min_node_weight\", &min_node_weight_t));\n    const auto min_node_weight = min_node_weight_t->scalar<float>()();\n\n    std::vector<int32> output_node_ids;\n    std::vector<float> output_gains;\n    std::vector<int32> output_feature_dimensions;\n    std::vector<int32> output_thresholds;\n    std::vector<Eigen::VectorXf> output_left_node_contribs;\n    std::vector<Eigen::VectorXf> output_right_node_contribs;\n    std::vector<string> output_split_types;\n\n    // TODO(tanzheny) parallelize the computation.\n    // Iterate each node and find the best gain per node.\n    for (int32_t node_id = node_id_first; node_id < node_id_last; ++node_id) {\n      float best_gain = std::numeric_limits<float>::lowest();\n      int32_t best_bucket = 0;\n      int32_t best_f_dim = 0;\n      string best_split_type;\n      Eigen::VectorXf best_contrib_for_left(logits_dim);\n      Eigen::VectorXf best_contrib_for_right(logits_dim);\n      float parent_gain;\n\n      // Including default bucket.\n      ConstMatrixMap stats_mat(&stats_summary(node_id, 0, 0, 0),\n                               num_buckets + 1, logits_dim + hessian_dim);\n      const Eigen::VectorXf total_grad =\n          stats_mat.leftCols(logits_dim).colwise().sum();\n      const Eigen::VectorXf total_hess =\n          stats_mat.rightCols(hessian_dim).colwise().sum();\n      if (total_hess.norm() < min_node_weight) {\n        continue;\n      }\n      Eigen::VectorXf parent_weight(logits_dim);\n      CalculateWeightsAndGains(total_grad, total_hess, l1, l2, &parent_weight,\n                               &parent_gain);\n\n      if (split_type_ == \"inequality\") {\n        CalculateBestInequalitySplit(\n            stats_summary, node_id, feature_dims, logits_dim, hessian_dim,\n            num_buckets, min_node_weight, l1, l2, &best_gain, &best_bucket,\n            &best_f_dim, &best_split_type, &best_contrib_for_left,\n            &best_contrib_for_right);\n      } else {\n        CalculateBestEqualitySplit(\n            stats_summary, total_grad, total_hess, node_id, feature_dims,\n            logits_dim, hessian_dim, num_buckets, l1, l2, &best_gain,\n            &best_bucket, &best_f_dim, &best_split_type, &best_contrib_for_left,\n            &best_contrib_for_right);\n      }\n\n      if (best_gain == std::numeric_limits<float>::lowest()) {\n        // Do not add the node if not split if found.\n        continue;\n      }\n      output_node_ids.push_back(node_id);\n      // Remove the parent gain for the parent node.\n      output_gains.push_back(best_gain - parent_gain);\n      output_feature_dimensions.push_back(best_f_dim);\n      // default direction is fixed for dense splits.\n      // TODO(tanzheny) account for default values.\n      output_split_types.push_back(best_split_type);\n      output_thresholds.push_back(best_bucket);\n      output_left_node_contribs.push_back(best_contrib_for_left);\n      output_right_node_contribs.push_back(best_contrib_for_right);\n    }  // for node id\n    const int num_nodes = output_node_ids.size();\n    // output_node_ids\n    Tensor* output_node_ids_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\"node_ids\", {num_nodes},\n                                                     &output_node_ids_t));\n    auto output_node_ids_vec = output_node_ids_t->vec<int32>();\n\n    // output_gains\n    Tensor* output_gains_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"gains\", {num_nodes},\n                                                     &output_gains_t));\n    auto output_gains_vec = output_gains_t->vec<float>();\n\n    // output_feature_dimensions\n    Tensor* output_feature_dimension_t;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"feature_dimensions\", {num_nodes},\n                                            &output_feature_dimension_t));\n    auto output_feature_dimensions_vec =\n        output_feature_dimension_t->vec<int32>();\n\n    // output_thresholds\n    Tensor* output_thresholds_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"thresholds\", {num_nodes},\n                                                     &output_thresholds_t));\n    auto output_thresholds_vec = output_thresholds_t->vec<int32>();\n\n    // output_left_node_contribs\n    Tensor* output_left_node_contribs_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"left_node_contribs\", {num_nodes, logits_dim},\n                                &output_left_node_contribs_t));\n    auto output_left_node_contribs_matrix =\n        output_left_node_contribs_t->matrix<float>();\n\n    // output_right_node_contribs\n    Tensor* output_right_node_contribs_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"right_node_contribs\", {num_nodes, logits_dim},\n                                &output_right_node_contribs_t));\n    auto output_right_node_contribs_matrix =\n        output_right_node_contribs_t->matrix<float>();\n\n    // split type\n    Tensor* output_split_types_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"split_with_default_directions\",\n                                          {num_nodes}, &output_split_types_t));\n    auto output_split_types_vec = output_split_types_t->vec<tstring>();\n\n    // Sets output tensors from vectors.\n    for (int i = 0; i < num_nodes; ++i) {\n      output_node_ids_vec(i) = output_node_ids[i];\n      // Adjust the gains to penalize by tree complexity.\n      output_gains_vec(i) = output_gains[i] - tree_complexity;\n      output_feature_dimensions_vec(i) = output_feature_dimensions[i];\n      output_thresholds_vec(i) = output_thresholds[i];\n      for (int j = 0; j < logits_dim; ++j) {\n        output_left_node_contribs_matrix(i, j) =\n            output_left_node_contribs[i][j];\n        output_right_node_contribs_matrix(i, j) =\n            output_right_node_contribs[i][j];\n      }\n      output_split_types_vec(i) = output_split_types[i];\n    }\n  }", "func_hash": 329288218153569846583726994870166814749, "file_name": "stats_ops.cc", "file_hash": 99816312750255630357955125041994485531, "cwe": ["CWE-824"], "cve": "CVE-2021-37662", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can generate undefined behavior via a reference binding to nullptr in `BoostedTreesCalculateBestGainsPerFeature` and similar attack can occur in `BoostedTreesCalculateBestFeatureSplitV2`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/stats_ops.cc) does not validate the input values. We have patched the issue in GitHub commit 9c87c32c710d0b5b53dc6fd3bfde4046e1f7a5ad and in commit 429f009d2b2c09028647dd4bb7b3f6f414bbaad7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-37662"}
{"idx": 219024, "project": "tensorflow", "commit_id": "240655511cd3e701155f944a972db71b6c0b1bb6", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/240655511cd3e701155f944a972db71b6c0b1bb6", "commit_message": "Eliminate `CHECK`-fails from `IsSimplifiableReshape` via `MakeShape(<invalid shape>)`\n\nPiperOrigin-RevId: 409166738\nChange-Id: I7f0a3590b8acae3f3e3e2fe636e1f5ef285693cf", "target": 0, "func": "Status ConstantFolding::MaterializeConstantValuedNode(\n    NodeDef* node, const GraphProperties& properties) {\n  if (disable_compressed_tensor_optimization_) {\n    return Status::OK();\n  }\n  // Nodes that generate constant-valued outputs can be represented compactly in\n  // compressed format, regardless of their shape.\n  const std::vector<OpInfo::TensorProperties>& output_props =\n      properties.GetOutputProperties(node->name());\n  if (output_props.size() != 1) return Status::OK();\n  const auto& output_shape = output_props[0].shape();\n  if (!PartialTensorShape(output_shape).IsFullyDefined()) {\n    return Status::OK();\n  }\n  if (IsFill(*node)) {\n    const auto output_dtype = output_props[0].dtype();\n    NodeDef* input_node = nullptr;\n    for (int i = 0; i < 2; ++i) {\n      input_node = node_map_->GetNode(NodeName(node->input(i)));\n      if (input_node == nullptr || !IsReallyConstant(*input_node)) {\n        return Status::OK();\n      }\n    }\n    TF_RETURN_IF_ERROR(CheckAttrExists(*input_node, \"value\"));\n\n    // Copy the input tensor to the fill node, set the output shape and data\n    // type, and change the node type to Const.\n    TensorProto* tensor = (*node->mutable_attr())[\"value\"].mutable_tensor();\n    const TensorProto& input_tensor = input_node->attr().at(\"value\").tensor();\n    if (!input_tensor.tensor_content().empty()) {\n      // Convert the value to repeated field format, so we can use the\n      // decompression mechanism to store only a single value in the constant\n      // node, even if the shape specified in the original Fill is large.\n      Tensor t;\n      if (!t.FromProto(input_tensor)) {\n        return errors::InvalidArgument(\n            \"Could not construct Tensor form TensorProto in node: \",\n            input_node->name());\n      }\n      tensor->clear_tensor_content();\n      t.AsProtoField(tensor);\n    } else {\n      *tensor = input_tensor;\n    }\n    *(tensor->mutable_tensor_shape()) = output_shape;\n    (*node->mutable_attr())[\"dtype\"].set_type(output_dtype);\n    node->mutable_attr()->erase(\"T\");\n    node->mutable_attr()->erase(\"index_type\");\n    node->set_op(\"Const\");\n    for (int i = 0; i < 2; i++) {\n      // Change inputs to a control inputs.\n      const string ctrl_dep = AsControlDependency(node->input(i));\n      node_map_->UpdateInput(node->name(), node->input(i), ctrl_dep);\n      node->set_input(i, ctrl_dep);\n    }\n    graph_modified_ = true;\n  } else {\n    double value =\n        (IsZerosLike(*node) ? 0.0 : (IsOnesLike(*node) ? 1.0 : -1.0));\n    if (value >= 0) {\n      TF_RETURN_IF_ERROR(ReplaceOperationWithConstant(\n          value, properties, output_shape, node, graph_));\n    }\n  }\n  return Status::OK();\n}", "func_hash": 211483964768294669063235670111819300308, "file_name": "constant_folding.cc", "file_hash": 221573695858123615640237954647315751120, "cwe": ["CWE-617"], "cve": "CVE-2022-23581", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The Grappler optimizer in TensorFlow can be used to cause a denial of service by altering a `SavedModel` such that `IsSimplifiableReshape` would trigger `CHECK` failures. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23581"}
{"idx": 211877, "project": "libexpat", "commit_id": "a2fe525e660badd64b6c557c2b1ec26ddc07f6e4", "project_url": "https://github.com/libexpat/libexpat", "commit_url": "https://github.com/libexpat/libexpat/commit/a2fe525e660badd64b6c557c2b1ec26ddc07f6e4", "commit_message": "lib: Protect against malicious namespace declarations (CVE-2022-25236)", "target": 1, "func": "addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,\n           const XML_Char *uri, BINDING **bindingsPtr) {\n  static const XML_Char xmlNamespace[]\n      = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,\n         ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,\n         ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,\n         ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,\n         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,\n         ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,\n         ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,\n         ASCII_e,      '\\0'};\n  static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;\n  static const XML_Char xmlnsNamespace[]\n      = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,\n         ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,\n         ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,\n         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,\n         ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\\0'};\n  static const int xmlnsLen\n      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;\n\n  XML_Bool mustBeXML = XML_FALSE;\n  XML_Bool isXML = XML_TRUE;\n  XML_Bool isXMLNS = XML_TRUE;\n\n  BINDING *b;\n  int len;\n\n  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */\n  if (*uri == XML_T('\\0') && prefix->name)\n    return XML_ERROR_UNDECLARING_PREFIX;\n\n  if (prefix->name && prefix->name[0] == XML_T(ASCII_x)\n      && prefix->name[1] == XML_T(ASCII_m)\n      && prefix->name[2] == XML_T(ASCII_l)) {\n    /* Not allowed to bind xmlns */\n    if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)\n        && prefix->name[5] == XML_T('\\0'))\n      return XML_ERROR_RESERVED_PREFIX_XMLNS;\n\n    if (prefix->name[3] == XML_T('\\0'))\n      mustBeXML = XML_TRUE;\n  }\n\n  for (len = 0; uri[len]; len++) {\n    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))\n      isXML = XML_FALSE;\n\n    if (! mustBeXML && isXMLNS\n        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n      isXMLNS = XML_FALSE;\n  }\n  isXML = isXML && len == xmlLen;\n  isXMLNS = isXMLNS && len == xmlnsLen;\n\n  if (mustBeXML != isXML)\n    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML\n                     : XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (isXMLNS)\n    return XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (parser->m_namespaceSeparator)\n    len++;\n  if (parser->m_freeBindingList) {\n    b = parser->m_freeBindingList;\n    if (len > b->uriAlloc) {\n      /* Detect and prevent integer overflow */\n      if (len > INT_MAX - EXPAND_SPARE) {\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      XML_Char *temp = (XML_Char *)REALLOC(\n          parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));\n      if (temp == NULL)\n        return XML_ERROR_NO_MEMORY;\n      b->uri = temp;\n      b->uriAlloc = len + EXPAND_SPARE;\n    }\n    parser->m_freeBindingList = b->nextTagBinding;\n  } else {\n    b = (BINDING *)MALLOC(parser, sizeof(BINDING));\n    if (! b)\n      return XML_ERROR_NO_MEMORY;\n\n    /* Detect and prevent integer overflow */\n    if (len > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    b->uri\n        = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));\n    if (! b->uri) {\n      FREE(parser, b);\n      return XML_ERROR_NO_MEMORY;\n    }\n    b->uriAlloc = len + EXPAND_SPARE;\n  }\n  b->uriLen = len;\n  memcpy(b->uri, uri, len * sizeof(XML_Char));\n  if (parser->m_namespaceSeparator)\n    b->uri[len - 1] = parser->m_namespaceSeparator;\n  b->prefix = prefix;\n  b->attId = attId;\n  b->prevPrefixBinding = prefix->binding;\n  /* NULL binding when default namespace undeclared */\n  if (*uri == XML_T('\\0') && prefix == &parser->m_dtd->defaultPrefix)\n    prefix->binding = NULL;\n  else\n    prefix->binding = b;\n  b->nextTagBinding = *bindingsPtr;\n  *bindingsPtr = b;\n  /* if attId == NULL then we are not starting a namespace scope */\n  if (attId && parser->m_startNamespaceDeclHandler)\n    parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,\n                                        prefix->binding ? uri : 0);\n  return XML_ERROR_NONE;\n}", "func_hash": 22295362737021887331084829836677682659, "file_name": "xmlparse.c", "file_hash": 64970761866861782031621044957132437337, "cwe": ["CWE-668"], "cve": "CVE-2022-25236", "cve_desc": "xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-25236"}
{"idx": 90786, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  InitializeTemporaryOriginsInfoTask(\n      QuotaManager* manager,\n      UsageTracker* temporary_usage_tracker)\n      : DatabaseTaskBase(manager),\n        has_registered_origins_(false) {\n    DCHECK(temporary_usage_tracker);\n    temporary_usage_tracker->GetCachedOrigins(&origins_);\n  }\n", "func_hash": 197142863775431967456572118162176178633, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 218977, "project": "tensorflow", "commit_id": "240655511cd3e701155f944a972db71b6c0b1bb6", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/240655511cd3e701155f944a972db71b6c0b1bb6", "commit_message": "Eliminate `CHECK`-fails from `IsSimplifiableReshape` via `MakeShape(<invalid shape>)`\n\nPiperOrigin-RevId: 409166738\nChange-Id: I7f0a3590b8acae3f3e3e2fe636e1f5ef285693cf", "target": 0, "func": "bool ConstantFolding::SimplifyPack(GraphDef* optimized_graph, NodeDef* node) {\n  const string axis_node_name = OptimizedNodeName(*node, \"_const_axis\");\n  if (!IsPack(*node) || NumNonControlInputs(*node) != 1 ||\n      node_map_->NodeExists(axis_node_name)) {\n    return false;\n  }\n\n  // It's unsafe to add a control dependency on the feed node, because it might\n  // have been never executed otherwiwise.\n  if (feed_nodes_.find(NodeName(node->input(0))) != feed_nodes_.end()) {\n    return false;\n  }\n\n  // Create constant axis node.\n  Tensor axis_t(DT_INT32, TensorShape({}));\n  const int axis =\n      node->attr().count(\"axis\") == 0 ? 0 : node->attr().at(\"axis\").i();\n  NodeDef new_node;\n  if (!SetTensorValue(DT_INT32, axis, &axis_t).ok() ||\n      !CreateNodeDef(axis_node_name, TensorValue(&axis_t), &new_node).ok()) {\n    return false;\n  }\n  NodeDef* axis_node = optimized_graph->add_node();\n  *axis_node = std::move(new_node);\n  axis_node->set_name(axis_node_name);\n  node_map_->AddNode(axis_node->name(), axis_node);\n  // Add a control dependency to make sure axis_node is in the right frame.\n  const string ctrl_dep = ConstantFolding::AddControlDependency(\n      node->input(0), optimized_graph, node_map_.get());\n  axis_node->add_input(ctrl_dep);\n  axis_node->set_device(node->device());\n  node_map_->AddOutput(NodeName(node->input(0)), axis_node->name());\n  node->set_op(\"ExpandDims\");\n  if (node->attr().count(\"axis\") != 0) {\n    node->mutable_attr()->erase(\"axis\");\n  }\n  if (node->attr().count(\"N\") != 0) {\n    node->mutable_attr()->erase(\"N\");\n  }\n  (*node->mutable_attr())[\"Tdim\"].set_type(DT_INT32);\n  node->add_input(axis_node->name());\n  node_map_->AddOutput(axis_node->name(), node->name());\n  if (node->input_size() > 2) {\n    node->mutable_input()->SwapElements(1, node->input_size() - 1);\n  }\n  return true;\n}", "func_hash": 36647643805573874571963658068102977682, "file_name": "constant_folding.cc", "file_hash": 221573695858123615640237954647315751120, "cwe": ["CWE-617"], "cve": "CVE-2022-23581", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The Grappler optimizer in TensorFlow can be used to cause a denial of service by altering a `SavedModel` such that `IsSimplifiableReshape` would trigger `CHECK` failures. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23581"}
{"idx": 195471, "project": "weechat", "commit_id": "9904cb6d2eb40f679d8ff6557c22d53a3e3dc75a", "project_url": "https://github.com/weechat/weechat", "commit_url": "https://github.com/weechat/weechat/commit/9904cb6d2eb40f679d8ff6557c22d53a3e3dc75a", "commit_message": "irc: fix crash when receiving a malformed message 352 (who)\n\nThanks to Stuart Nevans Locke for reporting the issue.", "target": 1, "func": "IRC_PROTOCOL_CALLBACK(352)\n{\n    char *pos_attr, *pos_hopcount, *pos_realname, *str_host;\n    int arg_start, length;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n\n    IRC_PROTOCOL_MIN_ARGS(5);\n\n    /* silently ignore malformed 352 message (missing infos) */\n    if (argc < 8)\n        return WEECHAT_RC_OK;\n\n    pos_attr = NULL;\n    pos_hopcount = NULL;\n    pos_realname = NULL;\n\n    if (argc > 8)\n    {\n        arg_start = (strcmp (argv[8], \"*\") == 0) ? 9 : 8;\n        if (argv[arg_start][0] == ':')\n        {\n            pos_attr = NULL;\n            pos_hopcount = (argc > arg_start) ? argv[arg_start] + 1 : NULL;\n            pos_realname = (argc > arg_start + 1) ? argv_eol[arg_start + 1] : NULL;\n        }\n        else\n        {\n            pos_attr = argv[arg_start];\n            pos_hopcount = (argc > arg_start + 1) ? argv[arg_start + 1] + 1 : NULL;\n            pos_realname = (argc > arg_start + 2) ? argv_eol[arg_start + 2] : NULL;\n        }\n    }\n\n    ptr_channel = irc_channel_search (server, argv[3]);\n    ptr_nick = (ptr_channel) ?\n        irc_nick_search (server, ptr_channel, argv[7]) : NULL;\n\n    /* update host in nick */\n    if (ptr_nick)\n    {\n        length = strlen (argv[4]) + 1 + strlen (argv[5]) + 1;\n        str_host = malloc (length);\n        if (str_host)\n        {\n            snprintf (str_host, length, \"%s@%s\", argv[4], argv[5]);\n            irc_nick_set_host (ptr_nick, str_host);\n            free (str_host);\n        }\n    }\n\n    /* update away flag in nick */\n    if (ptr_channel && ptr_nick && pos_attr)\n    {\n        irc_nick_set_away (server, ptr_channel, ptr_nick,\n                           (pos_attr[0] == 'G') ? 1 : 0);\n    }\n\n    /* update realname in nick */\n    if (ptr_channel && ptr_nick && pos_realname)\n    {\n        if (ptr_nick->realname)\n            free (ptr_nick->realname);\n        if (pos_realname &&\n            weechat_hashtable_has_key (server->cap_list, \"extended-join\"))\n        {\n            ptr_nick->realname = strdup (pos_realname);\n        }\n        else\n        {\n            ptr_nick->realname = NULL;\n        }\n    }\n\n    /* display output of who (manual who from user) */\n    if (!ptr_channel || (ptr_channel->checking_whox <= 0))\n    {\n        weechat_printf_date_tags (\n            irc_msgbuffer_get_target_buffer (\n                server, NULL, command, \"who\", NULL),\n            date,\n            irc_protocol_tags (command, \"irc_numeric\", NULL, NULL),\n            \"%s%s[%s%s%s] %s%s %s(%s%s@%s%s)%s %s%s%s%s(%s)\",\n            weechat_prefix (\"network\"),\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_CHANNEL,\n            argv[3],\n            IRC_COLOR_CHAT_DELIMITERS,\n            irc_nick_color_for_msg (server, 1, NULL, argv[7]),\n            argv[7],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_HOST,\n            argv[4],\n            argv[5],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_RESET,\n            (pos_attr) ? pos_attr : \"\",\n            (pos_attr) ? \" \" : \"\",\n            (pos_hopcount) ? pos_hopcount : \"\",\n            (pos_hopcount) ? \" \" : \"\",\n            (pos_realname) ? pos_realname : \"\");\n    }\n\n    return WEECHAT_RC_OK;\n}", "func_hash": 334241185700640959176375322270000746009, "file_name": "irc-protocol.c", "file_hash": 25326141648227228091841815556030791460, "cwe": ["CWE-476"], "cve": "CVE-2020-9759", "cve_desc": "A Vulnerability of LG Electronic web OS TV Emulator could allow an attacker to escalate privileges and overwrite certain files. This vulnerability is due to wrong environment setting. An attacker could exploit this vulnerability through crafted configuration files and executable files.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-9759"}
{"idx": 221412, "project": "linux", "commit_id": "c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc", "commit_message": "KVM: nSVM: always intercept VMLOAD/VMSAVE when nested (CVE-2021-3656)\n\nIf L1 disables VMLOAD/VMSAVE intercepts, and doesn't enable\nVirtual VMLOAD/VMSAVE (currently not supported for the nested hypervisor),\nthen VMLOAD/VMSAVE must operate on the L1 physical memory, which is only\npossible by making L0 intercept these instructions.\n\nFailure to do so allowed the nested guest to run VMLOAD/VMSAVE unintercepted,\nand thus read/write portions of the host physical memory.\n\nFixes: 89c8a4984fc9 (\"KVM: SVM: Enable Virtual VMLOAD VMSAVE feature\")\n\nSuggested-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Maxim Levitsky <mlevitsk@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "target": 0, "func": "static bool nested_vmcb_valid_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct vmcb_save_area *save)\n{\n\t/*\n\t * FIXME: these should be done after copying the fields,\n\t * to avoid TOC/TOU races.  For these save area checks\n\t * the possible damage is limited since kvm_set_cr0 and\n\t * kvm_set_cr4 handle failure; EFER_SVME is an exception\n\t * so it is force-set later in nested_prepare_vmcb_save.\n\t */\n\tif (CC(!(save->efer & EFER_SVME)))\n\t\treturn false;\n\n\tif (CC((save->cr0 & X86_CR0_CD) == 0 && (save->cr0 & X86_CR0_NW)) ||\n\t    CC(save->cr0 & ~0xffffffffULL))\n\t\treturn false;\n\n\tif (CC(!kvm_dr6_valid(save->dr6)) || CC(!kvm_dr7_valid(save->dr7)))\n\t\treturn false;\n\n\tif (!nested_vmcb_check_cr3_cr4(vcpu, save))\n\t\treturn false;\n\n\tif (CC(!kvm_valid_efer(vcpu, save->efer)))\n\t\treturn false;\n\n\treturn true;\n}", "func_hash": 148862571604383141626758063054295876474, "file_name": "None", "file_hash": null, "cwe": ["CWE-862"], "cve": "CVE-2021-3656", "cve_desc": "A flaw was found in the KVM's AMD code for supporting SVM nested virtualization. The flaw occurs when processing the VMCB (virtual machine control block) provided by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation of the \"virt_ext\" field, this issue could allow a malicious L1 to disable both VMLOAD/VMSAVE intercepts and VLS (Virtual VMLOAD/VMSAVE) for the L2 guest. As a result, the L2 guest would be allowed to read/write physical pages of the host, resulting in a crash of the entire system, leak of sensitive data or potential guest-to-host escape.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3656"}
{"idx": 195231, "project": "gpac", "commit_id": "893fb99b606eebfae46cde151846a980e689039b", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/893fb99b606eebfae46cde151846a980e689039b", "commit_message": "fixed #1902", "target": 1, "func": "s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)\n{\n\tu8 idr_flag;\n\ts32 slice, ret;\n\tu32 nal_hdr;\n\tAVCSliceInfo n_state;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tnal_hdr = gf_bs_read_u8(bs);\n\n\tslice = 0;\n\tmemcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo));\n\tavc->last_nal_type_parsed = n_state.nal_unit_type = nal_hdr & 0x1F;\n\tn_state.nal_ref_idc = (nal_hdr >> 5) & 0x3;\n\n\tidr_flag = 0;\n\n\tswitch (n_state.nal_unit_type) {\n\tcase GF_AVC_NALU_ACCESS_UNIT:\n\tcase GF_AVC_NALU_END_OF_SEQ:\n\tcase GF_AVC_NALU_END_OF_STREAM:\n\t\tret = 1;\n\t\tbreak;\n\n\tcase GF_AVC_NALU_SVC_SLICE:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\t// slice buffer - read the info and compare.\n\t\t/*ret = */svc_parse_slice(bs, avc, &n_state);\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t\tavc_compute_poc(&n_state);\n\n\t\tif (avc->s_info.poc != n_state.poc) {\n\t\t\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\t\t\treturn 1;\n\t\t}\n\t\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SVC_PREFIX_NALU:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_IDR_SLICE:\n\tcase GF_AVC_NALU_NON_IDR_SLICE:\n\tcase GF_AVC_NALU_DP_A_SLICE:\n\tcase GF_AVC_NALU_DP_B_SLICE:\n\tcase GF_AVC_NALU_DP_C_SLICE:\n\t\tslice = 1;\n\t\t/* slice buffer - read the info and compare.*/\n\t\tret = avc_parse_slice(bs, avc, idr_flag, &n_state);\n\t\tif (ret < 0) return ret;\n\t\tret = 0;\n\t\tif (\n\t\t\t((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE))\n\t\t\t&& (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE)\n\t\t\t) {\n\t\t\tbreak;\n\t\t}\n\t\tif (avc->s_info.frame_num != n_state.frame_num) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (avc->s_info.field_pic_flag != n_state.field_pic_flag) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) &&\n\t\t\t(!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tassert(avc->s_info.sps);\n\n\t\tif (avc->s_info.sps->poc_type == n_state.sps->poc_type) {\n\t\t\tif (!avc->s_info.sps->poc_type) {\n\t\t\t\tif (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (avc->s_info.sps->poc_type == 1) {\n\t\t\t\tif (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n\t\t\tif (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) { /*IdrPicFlag differs in value*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (avc->s_info.idr_pic_id != n_state.idr_pic_id) { /*both IDR and idr_pic_id differs*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tavc->last_ps_idx = (s32) gf_bs_read_ue(bs);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SEI:\n\tcase GF_AVC_NALU_FILLER_DATA:\n\t\treturn 0;\n\n\tdefault:\n\t\tif (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1;\n\t\t//To detect change of AU when multiple sps and pps in stream\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t/* save _prev values */\n\tif (ret && avc->s_info.sps) {\n\t\tn_state.frame_num_offset_prev = avc->s_info.frame_num_offset;\n\t\tif ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0))\n\t\t\tn_state.frame_num_prev = avc->s_info.frame_num;\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t}\n\tif (slice)\n\t\tavc_compute_poc(&n_state);\n\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\treturn ret;\n}", "func_hash": 99100226875075764129164909998725433232, "file_name": "av_parsers.c", "file_hash": 168517587328341017594269375399465893964, "cwe": ["CWE-476"], "cve": "CVE-2021-40565", "cve_desc": "A Segmentation fault caused by a null pointer dereference vulnerability exists in Gpac through 1.0.1 via the gf_avc_parse_nalu function in av_parsers.c when using mp4box, which causes a denial of service.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40565"}
{"idx": 219979, "project": "glewlwyd", "commit_id": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "project_url": "https://github.com/babelouest/glewlwyd", "commit_url": "https://github.com/babelouest/glewlwyd/commit/125281f1c0d4b6a8b49f7e55a757205a2ef01fbe", "commit_message": "Fix update session when auth fail", "target": 0, "func": "int callback_glewlwyd_get_client_list (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct config_elements * config = (struct config_elements *)user_data;\n  json_t * j_client_list;\n  size_t offset = 0, limit = GLEWLWYD_DEFAULT_LIMIT_SIZE;\n  long int l_converted = 0;\n  char * endptr = NULL;\n  \n  if (u_map_get(request->map_url, \"offset\") != NULL) {\n    l_converted = strtol(u_map_get(request->map_url, \"offset\"), &endptr, 10);\n    if (!(*endptr) && l_converted > 0) {\n      offset = (size_t)l_converted;\n    }\n  }\n  if (u_map_get(request->map_url, \"limit\") != NULL) {\n    l_converted = strtol(u_map_get(request->map_url, \"limit\"), &endptr, 10);\n    if (!(*endptr) && l_converted > 0) {\n      limit = (size_t)l_converted;\n    }\n  }\n  j_client_list = get_client_list(config, u_map_get(request->map_url, \"pattern\"), offset, limit, u_map_get(request->map_url, \"source\"));\n  if (check_result_value(j_client_list, G_OK)) {\n    ulfius_set_json_body_response(response, 200, json_object_get(j_client_list, \"client\"));\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_get_client_list - Error get_client_list\");\n    response->status = 500;\n  }\n  json_decref(j_client_list);\n  return U_CALLBACK_CONTINUE;\n}", "func_hash": 332836691625643241031577107755967535238, "file_name": "webservice.c", "file_hash": 287798817606377336444620654835011177393, "cwe": ["CWE-287"], "cve": "CVE-2021-45379", "cve_desc": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-45379"}
{"idx": 219040, "project": "tensorflow", "commit_id": "240655511cd3e701155f944a972db71b6c0b1bb6", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/240655511cd3e701155f944a972db71b6c0b1bb6", "commit_message": "Eliminate `CHECK`-fails from `IsSimplifiableReshape` via `MakeShape(<invalid shape>)`\n\nPiperOrigin-RevId: 409166738\nChange-Id: I7f0a3590b8acae3f3e3e2fe636e1f5ef285693cf", "target": 0, "func": "bool ConstantFolding::PrepareConstantPushDown(\n    const NodeDef& parent, const GraphProperties& properties,\n    bool must_have_properties, ConstantPushDownContext* ctx) const {\n  if (ctx == nullptr || !has_fetch_ || NumNonControlInputs(parent) != 2) {\n    return false;\n  }\n  NodeDef* left_child = node_map_->GetNode(parent.input(0));\n  NodeDef* right_child = node_map_->GetNode(parent.input(1));\n\n  // Sanity check for missing children.\n  if (left_child == nullptr || right_child == nullptr) {\n    return false;\n  }\n\n  ctx->left_child_is_const = IsReallyConstant(*left_child);\n  ctx->right_child_is_const = IsReallyConstant(*right_child);\n  ctx->op_child = ctx->left_child_is_const ? right_child : left_child;\n  ctx->const_child = ctx->left_child_is_const ? left_child : right_child;\n\n  // Nothing to do unless the parent has a constant child node.\n  if (!ctx->left_child_is_const && !ctx->right_child_is_const) {\n    return false;\n  }\n\n  // Don't move nodes across devices.\n  if (parent.device() != ctx->op_child->device() ||\n      parent.device() != ctx->const_child->device()) {\n    return false;\n  }\n\n  // Make sure that it is safe to change the value of the child node result.\n  if (ctx->op_child->input_size() < 2 ||\n      nodes_to_preserve_.find(ctx->op_child->name()) !=\n          nodes_to_preserve_.end() ||\n      NumNonControlOutputs(*ctx->op_child, *node_map_) > 1) {\n    return false;\n  }\n\n  // Don't apply reassociation to floating point types of low precision.\n  // The danger of significant numerical changes is too high.\n  if (!CheckAttrExists(parent, \"T\").ok()) return false;\n  DataType dtype = parent.attr().at(\"T\").type();\n  if (dtype == DT_BFLOAT16 || dtype == DT_HALF) {\n    return false;\n  }\n\n  // Don't rewrite the tree if it might create cycles.\n  // TODO(rmlarsen): Add back handling of control dependency from op to C.\n  const auto& child_output = node_map_->GetOutputs(ctx->op_child->name());\n  if (child_output.find(ctx->const_child) != child_output.end()) {\n    return false;\n  }\n\n  // Get leaf nodes.\n  ctx->left_leaf = node_map_->GetNode(ctx->op_child->input(0));\n  ctx->right_leaf = node_map_->GetNode(ctx->op_child->input(1));\n  ctx->left_leaf_is_const = IsReallyConstant(*ctx->left_leaf);\n  ctx->right_leaf_is_const = IsReallyConstant(*ctx->right_leaf);\n\n  if (ctx->left_leaf_is_const && ctx->right_leaf_is_const) {\n    // Child is already foldable, leave it alone.\n    return false;\n  }\n\n  // Don't move nodes across devices.\n  if (parent.device() != ctx->left_leaf->device() ||\n      parent.device() != ctx->right_leaf->device()) {\n    return false;\n  }\n\n  // Get shape and type information.\n  ctx->parent_input_props = &properties.GetInputProperties(parent.name());\n  ctx->op_child_input_props =\n      &properties.GetInputProperties(ctx->op_child->name());\n  if (must_have_properties && (ctx->parent_input_props == nullptr ||\n                               ctx->parent_input_props->size() < 2 ||\n                               ctx->op_child_input_props == nullptr ||\n                               ctx->op_child_input_props->size() < 2)) {\n    return false;\n  }\n\n  VLOG(1) << \"\\n++++++++ PushDown for node \" << parent.name() << \": \"\n          << parent.op() << \"(\" << left_child->op() << \", \" << right_child->op()\n          << \")\";\n\n  return true;\n}", "func_hash": 293093804281525598632220737595443461182, "file_name": "constant_folding.cc", "file_hash": 221573695858123615640237954647315751120, "cwe": ["CWE-617"], "cve": "CVE-2022-23581", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The Grappler optimizer in TensorFlow can be used to cause a denial of service by altering a `SavedModel` such that `IsSimplifiableReshape` would trigger `CHECK` failures. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23581"}
{"idx": 195026, "project": "linux", "commit_id": "ab0fc21bc7105b54bafd85bd8b82742f9e68898a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/ab0fc21bc7105b54bafd85bd8b82742f9e68898a", "commit_message": "Revert \"NFSv4: Handle the special Linux file open access mode\"\n\nThis reverts commit 44942b4e457beda00981f616402a1a791e8c616e.\n\nAfter secondly opening a file with O_ACCMODE|O_DIRECT flags,\nnfs4_valid_open_stateid() will dereference NULL nfs4_state when lseek().\n\nReproducer:\n  1. mount -t nfs -o vers=4.2 $server_ip:/ /mnt/\n  2. fd = open(\"/mnt/file\", O_ACCMODE|O_DIRECT|O_CREAT)\n  3. close(fd)\n  4. fd = open(\"/mnt/file\", O_ACCMODE|O_DIRECT)\n  5. lseek(fd)\n\nReported-by: Lyu Tao <tao.lyu@epfl.ch>\nSigned-off-by: ChenXiaoSong <chenxiaosong2@huawei.com>\nSigned-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>", "target": 1, "func": "nfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\n\t/*\n\t * If no cached dentry exists or if it's negative, NFSv4 handled the\n\t * opens in ->lookup() or ->create().\n\t *\n\t * We only get this far for a cached positive dentry.  We skipped\n\t * revalidation, so handle it here by dropping the dentry and returning\n\t * -EOPENSTALE.  The VFS will retry the lookup/create/open.\n\t */\n\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\n\t/* We can't create new files here */\n\topenflags &= ~(O_CREAT|O_EXCL);\n\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\n\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\n\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}", "func_hash": 67846125552854891508125900978071958871, "file_name": "nfs4file.c", "file_hash": 109456154040292488452120321326967957719, "cwe": ["CWE-909"], "cve": "CVE-2022-24448", "cve_desc": "An issue was discovered in fs/nfs/dir.c in the Linux kernel before 5.16.5. If an application sets the O_DIRECTORY flag, and tries to open a regular file, nfs_atomic_open() performs a regular lookup. If a regular file is found, ENOTDIR should occur, but the server instead returns uninitialized data in the file descriptor.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-24448"}
{"idx": 221135, "project": "gpac", "commit_id": "a69b567b8c95c72f9560c873c5ab348be058f340", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340", "commit_message": "fixed #1895", "target": 0, "func": "GF_Err gf_odf_size_descriptor_list(GF_List *descList, u32 *outSize)\n{\n\tGF_Err e;\n\tu32 tmpSize, count, i;\n\tif (! descList) return GF_OK;\n\n\tcount = gf_list_count(descList);\n\tfor ( i = 0; i < count; i++ ) {\n\t\tGF_Descriptor *tmp = (GF_Descriptor*)gf_list_get(descList, i);\n\t\tif (tmp) {\n\t\t\te = gf_odf_size_descriptor(tmp, &tmpSize);\n\t\t\tif (e) return e;\n\t\t\tif (tmpSize) *outSize += tmpSize + gf_odf_size_field_size(tmpSize);\n\t\t}\n\t}\n\treturn GF_OK;\n}", "func_hash": 214117990845106757310379144479581540959, "file_name": "descriptors.c", "file_hash": 86476492964393375980272696403064975409, "cwe": ["CWE-415"], "cve": "CVE-2021-40571", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40571"}
{"idx": 95906, "project": "Chrome", "commit_id": "45bae236b03f577ed6682ef4c7ef3ee006de5e5a", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/45bae236b03f577ed6682ef4c7ef3ee006de5e5a", "commit_message": "None", "target": 0, "func": "void AddUsageStatsWorkItems(const InstallationState& original_state,\n                            const InstallerState& installer_state,\n                            WorkItemList* install_list) {\n  DCHECK(installer_state.operation() == InstallerState::MULTI_INSTALL ||\n         installer_state.operation() == InstallerState::MULTI_UPDATE);\n\n  HKEY root_key = installer_state.root_key();\n  bool value_found = false;\n  DWORD usagestats = 0;\n  const Products& products = installer_state.products();\n\n  for (Products::const_iterator scan = products.begin(), end = products.end();\n       !value_found && scan != end; ++scan) {\n    BrowserDistribution* dist = (*scan)->distribution();\n    const ProductState* product_state =\n        original_state.GetNonVersionedProductState(\n            installer_state.system_install(), dist->GetType());\n    value_found = product_state->GetUsageStats(&usagestats);\n  }\n\n  if (value_found) {\n    std::wstring state_key(\n        installer_state.multi_package_binaries_distribution()->GetStateKey());\n    install_list->AddCreateRegKeyWorkItem(root_key, state_key);\n    install_list->AddSetRegValueWorkItem(root_key, state_key,\n                                         google_update::kRegUsageStatsField,\n                                         usagestats, false);\n\n    for (Products::const_iterator scan = products.begin(), end = products.end();\n         scan != end; ++scan) {\n      BrowserDistribution* dist = (*scan)->distribution();\n      if (installer_state.system_install()) {\n        install_list->AddDeleteRegValueWorkItem(\n            root_key, dist->GetStateMediumKey(),\n            google_update::kRegUsageStatsField);\n        install_list->AddDeleteRegValueWorkItem(\n            HKEY_CURRENT_USER, dist->GetStateKey(),\n            google_update::kRegUsageStatsField);\n      }\n      install_list->AddDeleteRegValueWorkItem(root_key, dist->GetStateKey(),\n          google_update::kRegUsageStatsField);\n    }\n  }\n}\n", "func_hash": 147981642094506301187936301171596353125, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 218793, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static inline ssize_t WritePSDSize(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size,const MagickOffsetType offset)\n{\n  MagickOffsetType\n    current_offset;\n\n  ssize_t\n    result;\n\n  current_offset=TellBlob(image);\n  (void) SeekBlob(image,offset,SEEK_SET);\n  if (psd_info->version == 1)\n    result=WriteBlobMSBLong(image,(unsigned int) size);\n  else\n    result=WriteBlobMSBLongLong(image,size);\n  (void) SeekBlob(image,current_offset,SEEK_SET);\n  return(result);\n}", "func_hash": 313425145554302550174365336893995823155, "file_name": "psd.c", "file_hash": 226732625250511916284298083592366716300, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 218986, "project": "tensorflow", "commit_id": "240655511cd3e701155f944a972db71b6c0b1bb6", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/240655511cd3e701155f944a972db71b6c0b1bb6", "commit_message": "Eliminate `CHECK`-fails from `IsSimplifiableReshape` via `MakeShape(<invalid shape>)`\n\nPiperOrigin-RevId: 409166738\nChange-Id: I7f0a3590b8acae3f3e3e2fe636e1f5ef285693cf", "target": 0, "func": "Status ConstantFolding::Optimize(Cluster* cluster, const GrapplerItem& item,\n                                 GraphDef* optimized_graph) {\n  // TensorFlow flushes denormals to zero and rounds to nearest, so we do\n  // the same here.\n  port::ScopedFlushDenormal flush;\n  port::ScopedSetRound round(FE_TONEAREST);\n  nodes_to_preserve_ = item.NodesToPreserve();\n  for (const auto& feed : item.feed) {\n    feed_nodes_.insert(NodeName(feed.first));\n  }\n\n  if (cpu_device_ == nullptr) {\n    owned_device_.reset(new DeviceSimple());\n    cpu_device_ = owned_device_.get();\n  }\n\n  graph_contains_assign_or_inplace_op_ = false;\n  for (const NodeDef& node : item.graph.node()) {\n    if (ModifiesInputsInPlace(node) || HasRefInput(node)) {\n      graph_contains_assign_or_inplace_op_ = true;\n      break;\n    }\n  }\n\n  has_fetch_ = !item.fetch.empty();\n  GrapplerItem item_to_optimize = item;\n  GraphProperties properties(item_to_optimize);\n  // It's possible to feed a placeholder with a tensor of any shape: make sure\n  // that the shape inference deals with this conservatively unless we're in\n  // aggressive mode.\n  const bool assume_valid_feeds = opt_level_ == RewriterConfig::AGGRESSIVE;\n  if (!properties\n           .InferStatically(assume_valid_feeds,\n                            /*aggressive_shape_inference=*/false,\n                            /*include_input_tensor_values=*/false,\n                            /*include_output_tensor_values=*/true)\n           .ok()) {\n    properties.Clear();\n  }\n\n  *optimized_graph = GraphDef();\n  item_to_optimize.graph.Swap(optimized_graph);\n  int64_t node_count;\n\n  do {\n    GRAPPLER_RETURN_IF_DEADLINE_EXCEEDED();\n    graph_modified_ = false;\n    item_to_optimize.graph.Swap(optimized_graph);\n    node_count = item_to_optimize.graph.node_size();\n    TF_RETURN_IF_ERROR(RunOptimizationPass(cluster, &item_to_optimize,\n                                           &properties, optimized_graph));\n  } while (graph_modified_ || optimized_graph->node_size() != node_count);\n  *optimized_graph->mutable_library() = item.graph.library();\n  *optimized_graph->mutable_versions() = item.graph.versions();\n\n  return Status::OK();\n}", "func_hash": 275853434045180336120164645659517665, "file_name": "constant_folding.cc", "file_hash": 221573695858123615640237954647315751120, "cwe": ["CWE-617"], "cve": "CVE-2022-23581", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The Grappler optimizer in TensorFlow can be used to cause a denial of service by altering a `SavedModel` such that `IsSimplifiableReshape` would trigger `CHECK` failures. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23581"}
{"idx": 197242, "project": "tensorflow", "commit_id": "537bc7c723439b9194a358f64d871dd326c18887", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/537bc7c723439b9194a358f64d871dd326c18887", "commit_message": "Fix a null pointer exception caused by branching on uninitialized data.\n\nThis is due to not checking that the params for the quantization exists. If there is no quantization, we should not access the `.params` field.\n\nPiperOrigin-RevId: 385163909\nChange-Id: I2beb8d50649b6542db224c163033fbcbaa49314f", "target": 1, "func": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = reinterpret_cast<TfLiteSVDFParams*>(node->builtin_data);\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  int scratch_tensor_index = op_data->scratch_tensor_index;\n\n  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 5);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* weights_feature;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kWeightsFeatureTensor,\n                                          &weights_feature));\n  const TfLiteTensor* weights_time;\n  TF_LITE_ENSURE_OK(\n      context, GetInputSafe(context, node, kWeightsTimeTensor, &weights_time));\n\n  TF_LITE_ENSURE(context,\n                 input->type == kTfLiteFloat32 || input->type == kTfLiteInt8);\n\n  // Check all the parameters of tensor match within themselves and match the\n  // input configuration.\n  const int rank = params->rank;\n  const int batch_size = input->dims->data[0];\n  const int num_filters = weights_feature->dims->data[0];\n  TF_LITE_ENSURE(context, rank != 0);\n  TF_LITE_ENSURE_EQ(context, num_filters % rank, 0);\n  const int num_units = num_filters / rank;\n  const int memory_size = weights_time->dims->data[1];\n  TF_LITE_ENSURE_EQ(context, input->dims->data[1],\n                    weights_feature->dims->data[1]);\n  TF_LITE_ENSURE_EQ(context, weights_time->dims->data[0], num_filters);\n\n  const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);\n  if (bias) {\n    TF_LITE_ENSURE_EQ(context, bias->dims->data[0], num_units);\n  }\n\n  const TfLiteTensor* state;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kStateTensor, &state));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  // Check the shape of input state tensors.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(state), 2);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 0), batch_size);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 1),\n                    memory_size * num_filters);\n\n  // Resize output.\n  TfLiteIntArray* output_size_array = TfLiteIntArrayCreate(2);\n  output_size_array->data[0] = batch_size;\n  output_size_array->data[1] = num_units;\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_size_array));\n\n  // The weights are of consistent type, so it suffices to check one.\n  const bool is_hybrid_op = IsHybridOp(input, weights_feature);\n  const bool is_full_integer = input->type == kTfLiteInt8;\n\n  // Resize scratch.\n  TfLiteIntArrayFree(node->temporaries);\n  if (is_hybrid_op) {\n    node->temporaries = TfLiteIntArrayCreate(6);\n  } else if (is_full_integer) {\n    node->temporaries = TfLiteIntArrayCreate(2);\n  } else {\n    node->temporaries = TfLiteIntArrayCreate(1);\n  }\n  node->temporaries->data[0] = scratch_tensor_index;\n\n  TfLiteIntArray* scratch_size_array = TfLiteIntArrayCreate(2);\n  scratch_size_array->data[0] = batch_size;\n  scratch_size_array->data[1] = num_filters;\n\n  TfLiteTensor* scratch_tensor;\n  TF_LITE_ENSURE_OK(\n      context, GetTemporarySafe(context, node, /*index=*/0, &scratch_tensor));\n\n  // The scratch buffer is of type int32 for full integer svdf and it's of type\n  // float32 for hybrid and float case.\n  if (is_full_integer) {\n    scratch_tensor->type = kTfLiteInt32;\n  } else {\n    scratch_tensor->type = kTfLiteFloat32;\n  }\n  scratch_tensor->allocation_type = kTfLiteArenaRw;\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scratch_tensor,\n                                                   scratch_size_array));\n\n  if (is_hybrid_op) {\n    op_data->compute_row_sums = true;\n    // Tell interpreter to allocate temporary tensors to store quantized values\n    // of input tensors.\n    node->temporaries->data[1] = scratch_tensor_index + 1;\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,\n                                                &input_quantized));\n    input_quantized->type = weights_feature->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n\n    // Tell interpreter to allocate temporary tensors to store scaling factors.\n    node->temporaries->data[2] = scratch_tensor_index + 2;\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/2,\n                                                &scaling_factors));\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n\n    // Used to store dequantized weights_time matrix for hybrid computation of\n    // matmul(state, weights_time), which occurs in floating point.\n    node->temporaries->data[3] = scratch_tensor_index + 3;\n    TfLiteTensor* float_weights_time;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/3,\n                                                &float_weights_time));\n    float_weights_time->type = kTfLiteFloat32;\n    // Persistent so that we can compute the dequantized weights only once.\n    float_weights_time->allocation_type = kTfLiteArenaRwPersistent;\n    if (!TfLiteIntArrayEqual(float_weights_time->dims, weights_time->dims)) {\n      TfLiteIntArray* float_weights_time_size =\n          TfLiteIntArrayCopy(weights_time->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, float_weights_time,\n                                              float_weights_time_size));\n    }\n\n    node->temporaries->data[4] = scratch_tensor_index + 4;\n    TfLiteTensor* zero_points;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/4, &zero_points));\n    zero_points->type = kTfLiteFloat32;\n    zero_points->allocation_type = kTfLiteArenaRw;\n    int zero_points_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n      zero_points_size->data[0] = zero_points_dims[0];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,\n                                                       zero_points_size));\n    }\n\n    node->temporaries->data[5] = scratch_tensor_index + 5;\n    TfLiteTensor* row_sums;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, /*index=*/5, &row_sums));\n    row_sums->type = kTfLiteFloat32;\n    row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int row_sums_dims[1] = {num_filters};\n    if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {\n      TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);\n      row_sums_size->data[0] = row_sums_dims[0];\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, row_sums, row_sums_size));\n    }\n  }\n  if (is_full_integer) {\n    // Allocated one extra tensor.\n    TfLiteIntArray* output_temp_size_array = TfLiteIntArrayCreate(2);\n    output_temp_size_array->data[0] = num_units;\n    output_temp_size_array->data[1] = batch_size;\n    node->temporaries->data[1] = scratch_tensor_index + 1;\n    TfLiteTensor* output_temp;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/1, &output_temp));\n    output_temp->type = kTfLiteInt32;\n    output_temp->allocation_type = kTfLiteArenaRw;\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output_temp,\n                                                     output_temp_size_array));\n\n    // Calculate effective scales.\n    auto* input_params =\n        reinterpret_cast<TfLiteAffineQuantization*>(input->quantization.params);\n    auto* weights_feature_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        weights_feature->quantization.params);\n    auto* state_params =\n        reinterpret_cast<TfLiteAffineQuantization*>(state->quantization.params);\n    auto* weight_time_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        weights_time->quantization.params);\n    auto* output_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        output->quantization.params);\n    const double effective_scale_1 = input_params->scale->data[0] *\n                                     weights_feature_params->scale->data[0] /\n                                     state_params->scale->data[0];\n    const double effective_scale_2 = state_params->scale->data[0] *\n                                     weight_time_params->scale->data[0] /\n                                     output_params->scale->data[0];\n    QuantizeMultiplier(effective_scale_1, &op_data->effective_scale_1_a,\n                       &op_data->effective_scale_1_b);\n    QuantizeMultiplier(effective_scale_2, &op_data->effective_scale_2_a,\n                       &op_data->effective_scale_2_b);\n  }\n  return kTfLiteOk;\n}", "func_hash": 233995710646174347190469029723118566827, "file_name": "svdf.cc", "file_hash": 151141611170941646620182312728274364600, "cwe": ["CWE-908"], "cve": "CVE-2021-37682", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions all TFLite operations that use quantization can be made to use unitialized values. [For example](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/depthwise_conv.cc#L198-L200). The issue stems from the fact that `quantization.params` is only valid if `quantization.type` is different that `kTfLiteNoQuantization`. However, these checks are missing in large parts of the code. We have patched the issue in GitHub commits 537bc7c723439b9194a358f64d871dd326c18887, 4a91f2069f7145aab6ba2d8cfe41be8a110c18a5 and 8933b8a21280696ab119b63263babdb54c298538. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-37682"}
{"idx": 220196, "project": "tensorflow", "commit_id": "c99d98cd189839dcf51aee94e7437b54b31f8abd", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/c99d98cd189839dcf51aee94e7437b54b31f8abd", "commit_message": "Handle invalid inputs instead of crashing.\n\nPiperOrigin-RevId: 409549744\nChange-Id: I7f5935b34b53f7e426a5462fcc027bdbf5dcda24", "target": 0, "func": "void Graph::RecycleEdge(const Edge* e) {\n  free_edges_.push_back(const_cast<Edge*>(e));\n}", "func_hash": 183240340360024603665135170485692100390, "file_name": "graph.cc", "file_hash": 172099243927919341591512227523808328051, "cwe": ["CWE-125"], "cve": "CVE-2022-23592", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. TensorFlow's type inference can cause a heap out of bounds read as the bounds checking is done in a `DCHECK` (which is a no-op during production). An attacker can control the `input_idx` variable such that `ix` would be larger than the number of values in `node_t.args`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23592"}
{"idx": 213515, "project": "vim", "commit_id": "5c68617d395f9d7b824f68475b24ce3e38d653a3", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/5c68617d395f9d7b824f68475b24ce3e38d653a3", "commit_message": "patch 8.2.4563: \"z=\" in Visual mode may go beyond the end of the line\n\nProblem:    \"z=\" in Visual mode may go beyond the end of the line.\nSolution:   Adjust \"badlen\".", "target": 1, "func": "spell_suggest(int count)\n{\n    char_u\t*line;\n    pos_T\tprev_cursor = curwin->w_cursor;\n    char_u\twcopy[MAXWLEN + 2];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n    suginfo_T\tsug;\n    suggest_T\t*stp;\n    int\t\tmouse_used;\n    int\t\tneed_cap;\n    int\t\tlimit;\n    int\t\tselected = count;\n    int\t\tbadlen = 0;\n    int\t\tmsg_scroll_save = msg_scroll;\n    int\t\two_spell_save = curwin->w_p_spell;\n\n    if (!curwin->w_p_spell)\n    {\n\tdid_set_spelllang(curwin);\n\tcurwin->w_p_spell = TRUE;\n    }\n\n    if (*curwin->w_s->b_p_spl == NUL)\n    {\n\temsg(_(e_spell_checking_is_not_possible));\n\treturn;\n    }\n\n    if (VIsual_active)\n    {\n\t// Use the Visually selected text as the bad word.  But reject\n\t// a multi-line selection.\n\tif (curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    vim_beep(BO_SPELL);\n\t    return;\n\t}\n\tbadlen = (int)curwin->w_cursor.col - (int)VIsual.col;\n\tif (badlen < 0)\n\t    badlen = -badlen;\n\telse\n\t    curwin->w_cursor.col = VIsual.col;\n\t++badlen;\n\tend_visual_mode();\n    }\n    // Find the start of the badly spelled word.\n    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0\n\t    || curwin->w_cursor.col > prev_cursor.col)\n    {\n\t// No bad word or it starts after the cursor: use the word under the\n\t// cursor.\n\tcurwin->w_cursor = prev_cursor;\n\tline = ml_get_curline();\n\tp = line + curwin->w_cursor.col;\n\t// Backup to before start of word.\n\twhile (p > line && spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_BACK(line, p);\n\t// Forward to start of word.\n\twhile (*p != NUL && !spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_ADV(p);\n\n\tif (!spell_iswordp_nmw(p, curwin))\t\t// No word found.\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\tcurwin->w_cursor.col = (colnr_T)(p - line);\n    }\n\n    // Get the word and its length.\n\n    // Figure out if the word should be capitalised.\n    need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n    // Make a copy of current line since autocommands may free the line.\n    line = vim_strsave(ml_get_curline());\n    if (line == NULL)\n\tgoto skip;\n\n    // Get the list of suggestions.  Limit to 'lines' - 2 or the number in\n    // 'spellsuggest', whatever is smaller.\n    if (sps_limit > (int)Rows - 2)\n\tlimit = (int)Rows - 2;\n    else\n\tlimit = sps_limit;\n    spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,\n\t\t\t\t\t\t\tTRUE, need_cap, TRUE);\n\n    if (sug.su_ga.ga_len == 0)\n\tmsg(_(\"Sorry, no suggestions\"));\n    else if (count > 0)\n    {\n\tif (count > sug.su_ga.ga_len)\n\t    smsg(_(\"Sorry, only %ld suggestions\"), (long)sug.su_ga.ga_len);\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\t// When 'rightleft' is set the list is drawn right-left.\n\tcmdmsg_rl = curwin->w_p_rl;\n\tif (cmdmsg_rl)\n\t    msg_col = Columns - 1;\n#endif\n\n\t// List the suggestions.\n\tmsg_start();\n\tmsg_row = Rows - 1;\t// for when 'cmdheight' > 1\n\tlines_left = Rows;\t// avoid more prompt\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Change \\\"%.*s\\\" to:\"),\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0)\n\t{\n\t    // And now the rabbit from the high hat: Avoid showing the\n\t    // untranslated message rightleft.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\",\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n\t}\n#endif\n\tmsg_puts((char *)IObuff);\n\tmsg_clr_eos();\n\tmsg_putchar('\\n');\n\n\tmsg_scroll = TRUE;\n\tfor (i = 0; i < sug.su_ga.ga_len; ++i)\n\t{\n\t    stp = &SUG(sug.su_ga, i);\n\n\t    // The suggested word may replace only part of the bad word, add\n\t    // the not replaced part.\n\t    vim_strncpy(wcopy, stp->st_word, MAXWLEN);\n\t    if (sug.su_badlen > stp->st_orglen)\n\t\tvim_strncpy(wcopy + stp->st_wordlen,\n\t\t\t\t\t       sug.su_badptr + stp->st_orglen,\n\t\t\t\t\t      sug.su_badlen - stp->st_orglen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i + 1);\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\trl_mirror(IObuff);\n#endif\n\t    msg_puts((char *)IObuff);\n\n\t    vim_snprintf((char *)IObuff, IOSIZE, \" \\\"%s\\\"\", wcopy);\n\t    msg_puts((char *)IObuff);\n\n\t    // The word may replace more than \"su_badlen\".\n\t    if (sug.su_badlen < stp->st_orglen)\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),\n\t\t\t\t\t       stp->st_orglen, sug.su_badptr);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\n\t    if (p_verbose > 0)\n\t    {\n\t\t// Add the score.\n\t\tif (sps_flags & (SPS_DOUBLE | SPS_BEST))\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\",\n\t\t\tstp->st_salscore ? \"s \" : \"\",\n\t\t\tstp->st_score, stp->st_altscore);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\",\n\t\t\t    stp->st_score);\n#ifdef FEAT_RIGHTLEFT\n\t\tif (cmdmsg_rl)\n\t\t    // Mirror the numbers, but keep the leading space.\n\t\t    rl_mirror(IObuff + 1);\n#endif\n\t\tmsg_advance(30);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\t    msg_putchar('\\n');\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tcmdmsg_rl = FALSE;\n\tmsg_col = 0;\n#endif\n\t// Ask for choice.\n\tselected = prompt_for_number(&mouse_used);\n\tif (mouse_used)\n\t    selected -= lines_left;\n\tlines_left = Rows;\t\t// avoid more prompt\n\t// don't delay for 'smd' in normal_cmd()\n\tmsg_scroll = msg_scroll_save;\n    }\n\n    if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)\n    {\n\t// Save the from and to text for :spellrepall.\n\tVIM_CLEAR(repl_from);\n\tVIM_CLEAR(repl_to);\n\n\tstp = &SUG(sug.su_ga, selected - 1);\n\tif (sug.su_badlen > stp->st_orglen)\n\t{\n\t    // Replacing less than \"su_badlen\", append the remainder to\n\t    // repl_to.\n\t    repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,\n\t\t    sug.su_badlen - stp->st_orglen,\n\t\t\t\t\t      sug.su_badptr + stp->st_orglen);\n\t    repl_to = vim_strsave(IObuff);\n\t}\n\telse\n\t{\n\t    // Replacing su_badlen or more, use the whole word.\n\t    repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);\n\t    repl_to = vim_strsave(stp->st_word);\n\t}\n\n\t// Replace the word.\n\tp = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);\n\tif (p != NULL)\n\t{\n\t    c = (int)(sug.su_badptr - line);\n\t    mch_memmove(p, line, c);\n\t    STRCPY(p + c, stp->st_word);\n\t    STRCAT(p, sug.su_badptr + stp->st_orglen);\n\n\t    // For redo we use a change-word command.\n\t    ResetRedobuff();\n\t    AppendToRedobuff((char_u *)\"ciw\");\n\t    AppendToRedobuffLit(p + c,\n\t\t\t    stp->st_wordlen + sug.su_badlen - stp->st_orglen);\n\t    AppendCharToRedobuff(ESC);\n\n\t    // \"p\" may be freed here\n\t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n\t    curwin->w_cursor.col = c;\n\n\t    changed_bytes(curwin->w_cursor.lnum, c);\n\t}\n    }\n    else\n\tcurwin->w_cursor = prev_cursor;\n\n    spell_find_cleanup(&sug);\nskip:\n    vim_free(line);\n    curwin->w_p_spell = wo_spell_save;\n}", "func_hash": 283321822802394416488141327214287342104, "file_name": "spellsuggest.c", "file_hash": 284064000006918275605147443263550733278, "cwe": ["CWE-787"], "cve": "CVE-2022-0943", "cve_desc": "Heap-based Buffer Overflow occurs in vim in GitHub repository vim/vim prior to 8.2.4563.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0943"}
{"idx": 220031, "project": "tensorflow", "commit_id": "a68f68061e263a88321c104a6c911fe5598050a8", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/a68f68061e263a88321c104a6c911fe5598050a8", "commit_message": "Replace faulty overflow check with a builder for `TensorShape`.\n\nPrevents an integer overflow that was not caught before.\n\nPiperOrigin-RevId: 415381595\nChange-Id: I76585ddedc912bd9f4a390aeafa8e2ced1a28863", "target": 0, "func": "  string DebugString() const override { return \"A SparseTensorsMap\"; }", "func_hash": 185315156359592068837380825250301664240, "file_name": "sparse_tensors_map_ops.cc", "file_hash": 224775123349374780251651202891389866533, "cwe": ["CWE-190"], "cve": "CVE-2022-23568", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `AddManySparseToTensorsMap` is vulnerable to an integer overflow which results in a `CHECK`-fail when building new `TensorShape` objects (so, an assert failure based denial of service). We are missing some validation on the shapes of the input tensors as well as directly constructing a large `TensorShape` with user-provided dimensions. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23568"}
{"idx": 90105, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual void AddCellularDataPlanObserver(CellularDataPlanObserver* observer) {\n    if (!data_plan_observers_.HasObserver(observer))\n      data_plan_observers_.AddObserver(observer);\n  }\n", "func_hash": 309963211831686180665706939295472305039, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 221504, "project": "flatpak", "commit_id": "89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "commit_message": "run: Add cross-references for some other seccomp syscall filters\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "target": 0, "func": "systemd_unit_name_escape (const gchar *in)\n{\n  /* Adapted from systemd source */\n  GString * const str = g_string_sized_new (strlen (in));\n\n  for (; *in; in++)\n    {\n      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')\n        g_string_append_c (str, *in);\n      else\n        g_string_append_printf (str, \"\\\\x%02x\", *in);\n    }\n  return g_string_free (str, FALSE);\n}", "func_hash": 326245681312995955471947912479435090088, "file_name": "flatpak-run.c", "file_hash": 32398709380082441128978861691951488575, "cwe": ["CWE-20"], "cve": "CVE-2021-41133", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41133"}
{"idx": 90840, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  void DidGetAvailableSpace(QuotaStatusCode status, int64 available_space) {\n    quota_status_ = status;\n    available_space_ = available_space;\n  }\n", "func_hash": 262166983838761783215383409034322073855, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90749, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "QuotaManager::UsageAndQuotaDispatcherTask::Create(\n    QuotaManager* manager, const std::string& host, StorageType type) {\n  switch (type) {\n    case kStorageTypeTemporary:\n      return new UsageAndQuotaDispatcherTaskForTemporary(\n          manager, host);\n    case kStorageTypePersistent:\n      return new UsageAndQuotaDispatcherTaskForPersistent(\n          manager, host);\n    default:\n      NOTREACHED();\n  }\n  return NULL;\n}\n", "func_hash": 11655697028438862518783283652154191374, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 175787, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  GatherGlobalUsageTask(\n      UsageTracker* tracker,\n      QuotaClient* client)\n      : GatherUsageTaskBase(tracker, client),\n        client_(client),\n        callback_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)) {\n    DCHECK(tracker);\n    DCHECK(client);\n  }\n", "func_hash": 105422086900871838118890638890411723610, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 200934, "project": "libvirt", "commit_id": "524de6cc35d3b222f0e940bb0fd027f5482572c5", "project_url": "https://github.com/libvirt/libvirt", "commit_url": "https://github.com/libvirt/libvirt/commit/524de6cc35d3b222f0e940bb0fd027f5482572c5", "commit_message": "virstoragetest: testBackingParse: Use VIR_DOMAIN_DEF_FORMAT_SECURE when formatting xml\n\nWe want to format even the secure information in tests.\n\nSigned-off-by: Peter Krempa <pkrempa@redhat.com>\nReviewed-by: Erik Skultety <eskultet@redhat.com>", "target": 1, "func": "testBackingParse(const void *args)\n{\n    const struct testBackingParseData *data = args;\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *xml = NULL;\n    g_autoptr(virStorageSource) src = NULL;\n    int rc;\n    int erc = data->rv;\n\n    /* expect failure return code with NULL expected data */\n    if (!data->expect)\n        erc = -1;\n\n    if ((rc = virStorageSourceNewFromBackingAbsolute(data->backing, &src)) != erc) {\n        fprintf(stderr, \"expected return value '%d' actual '%d'\\n\", erc, rc);\n        return -1;\n    }\n\n    if (!src)\n        return 0;\n\n    if (src && !data->expect) {\n        fprintf(stderr, \"parsing of backing store string '%s' should \"\n                        \"have failed\\n\", data->backing);\n        return -1;\n    }\n\n    if (virDomainDiskSourceFormat(&buf, src, \"source\", 0, false, 0, true, NULL) < 0 ||\n        !(xml = virBufferContentAndReset(&buf))) {\n        fprintf(stderr, \"failed to format disk source xml\\n\");\n        return -1;\n    }\n\n    if (STRNEQ(xml, data->expect)) {\n        fprintf(stderr, \"\\n backing store string '%s'\\n\"\n                        \"expected storage source xml:\\n%s\\n\"\n                        \"actual storage source xml:\\n%s\\n\",\n                        data->backing, data->expect, xml);\n        return -1;\n    }\n\n    return 0;\n}", "func_hash": 11097234962036893945341293376039418410, "file_name": "virstoragetest.c", "file_hash": 229136922246575533938843249875631381172, "cwe": ["CWE-212"], "cve": "CVE-2020-14301", "cve_desc": "An information disclosure vulnerability was found in libvirt in versions before 6.3.0. HTTP cookies used to access network-based disks were saved in the XML dump of the guest domain. This flaw allows an attacker to access potentially sensitive information in the domain configuration via the `dumpxml` command.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-14301"}
{"idx": 197898, "project": "tensorflow", "commit_id": "96f364a1ca3009f98980021c4b32be5fdcca33a1", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/96f364a1ca3009f98980021c4b32be5fdcca33a1", "commit_message": "Validate axis input in tf.raw_ops.QuantizeAndDequantizeV4Grad\n\nPiperOrigin-RevId: 388291385\nChange-Id: I3bab68dc61d935afa96c0da021a7b722c6dc8dc8", "target": 1, "func": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& gradient = ctx->input(0);\n    const Tensor& input = ctx->input(1);\n    Tensor* input_backprop = nullptr;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, input.shape(), &input_backprop));\n\n    OP_REQUIRES(\n        ctx, input.IsSameSize(gradient),\n        errors::InvalidArgument(\"gradient and input must be the same size\"));\n    const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);\n    const Tensor& input_min_tensor = ctx->input(2);\n    OP_REQUIRES(ctx,\n                input_min_tensor.dims() == 0 || input_min_tensor.dims() == 1,\n                errors::InvalidArgument(\n                    \"Input min tensor must have dimension 1. Recieved \",\n                    input_min_tensor.dims(), \".\"));\n    const Tensor& input_max_tensor = ctx->input(3);\n    OP_REQUIRES(ctx,\n                input_max_tensor.dims() == 0 || input_max_tensor.dims() == 1,\n                errors::InvalidArgument(\n                    \"Input max tensor must have dimension 1. Recieved \",\n                    input_max_tensor.dims(), \".\"));\n    if (axis_ != -1) {\n      OP_REQUIRES(\n          ctx, input_min_tensor.dim_size(0) == depth,\n          errors::InvalidArgument(\"min has incorrect size, expected \", depth,\n                                  \" was \", input_min_tensor.dim_size(0)));\n      OP_REQUIRES(\n          ctx, input_max_tensor.dim_size(0) == depth,\n          errors::InvalidArgument(\"max has incorrect size, expected \", depth,\n                                  \" was \", input_max_tensor.dim_size(0)));\n    }\n\n    TensorShape min_max_shape(input_min_tensor.shape());\n    Tensor* input_min_backprop;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(1, min_max_shape, &input_min_backprop));\n\n    Tensor* input_max_backprop;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(2, min_max_shape, &input_max_backprop));\n\n    if (axis_ == -1) {\n      functor::QuantizeAndDequantizeOneScaleGradientFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(), gradient.template flat<T>(),\n        input.template flat<T>(), input_min_tensor.scalar<T>(),\n        input_max_tensor.scalar<T>(), input_backprop->template flat<T>(),\n        input_min_backprop->template scalar<T>(),\n        input_max_backprop->template scalar<T>());\n    } else {\n      functor::QuantizeAndDequantizePerChannelGradientFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(),\n        gradient.template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        input.template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        &input_min_tensor, &input_max_tensor,\n        input_backprop->template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        input_min_backprop->template flat<T>(),\n        input_max_backprop->template flat<T>());\n    }\n  }", "func_hash": 29737241678039524897017482046018335676, "file_name": "quantize_and_dequantize_op.cc", "file_hash": 111820661822757211423774352328292852595, "cwe": ["CWE-703"], "cve": "CVE-2021-37645", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.QuantizeAndDequantizeV4Grad` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L126) uses the `axis` value as the size argument to `absl::InlinedVector` constructor. But, the constructor uses an unsigned type for the argument, so the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit 96f364a1ca3009f98980021c4b32be5fdcca33a1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, and TensorFlow 2.4.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-37645"}
{"idx": 90804, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "QuotaManagerProxy::QuotaManagerProxy(\n    QuotaManager* manager, base::MessageLoopProxy* io_thread)\n    : manager_(manager), io_thread_(io_thread) {\n}\n", "func_hash": 58182873393222730189138379196777677572, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 221509, "project": "flatpak", "commit_id": "89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "commit_message": "run: Add cross-references for some other seccomp syscall filters\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "target": 0, "func": "apply_exports (char            **envp,\n               const ExportData *exports,\n               gsize             n_exports)\n{\n  int i;\n\n  for (i = 0; i < n_exports; i++)\n    {\n      const char *value = exports[i].val;\n\n      if (value)\n        envp = g_environ_setenv (envp, exports[i].env, value, TRUE);\n      else\n        envp = g_environ_unsetenv (envp, exports[i].env);\n    }\n\n  return envp;\n}", "func_hash": 104750829307739800412693661991787982384, "file_name": "flatpak-run.c", "file_hash": 32398709380082441128978861691951488575, "cwe": ["CWE-20"], "cve": "CVE-2021-41133", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41133"}
{"idx": 96962, "project": "Chrome", "commit_id": "3c1864079c441ea2e08f882acaaf441f78a6de3d", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/3c1864079c441ea2e08f882acaaf441f78a6de3d", "commit_message": "None", "target": 0, "func": " CFTypeRef tokenNullTypeRef()\n{\n    static CFStringRef tokenNullType = CFSTR(\"WKNull\");\n    return tokenNullType;\n}\n", "func_hash": 175623978259648943406346575058036055479, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90752, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  DeleteOriginInfo(\n      QuotaManager* manager,\n      const GURL& origin,\n      StorageType type)\n      : DatabaseTaskBase(manager),\n        origin_(origin),\n        type_(type) {}\n", "func_hash": 132694291741080881118914350788991078920, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 220212, "project": "tensorflow", "commit_id": "c99d98cd189839dcf51aee94e7437b54b31f8abd", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/c99d98cd189839dcf51aee94e7437b54b31f8abd", "commit_message": "Handle invalid inputs instead of crashing.\n\nPiperOrigin-RevId: 409549744\nChange-Id: I7f5935b34b53f7e426a5462fcc027bdbf5dcda24", "target": 0, "func": "gtl::iterator_range<NeighborIter> Node::in_nodes() const {\n  return gtl::make_range(NeighborIter(in_edges_.begin(), true),\n                         NeighborIter(in_edges_.end(), true));\n}", "func_hash": 335820363851414436301359061010372978955, "file_name": "graph.cc", "file_hash": 172099243927919341591512227523808328051, "cwe": ["CWE-125"], "cve": "CVE-2022-23592", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. TensorFlow's type inference can cause a heap out of bounds read as the bounds checking is done in a `DCHECK` (which is a no-op during production). An attacker can control the `input_idx` variable such that `ix` would be larger than the number of values in `node_t.args`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23592"}
{"idx": 220426, "project": "mruby", "commit_id": "27d1e0132a0804581dca28df042e7047fd27eaa8", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8", "commit_message": "array.c: fix `mrb_ary_shift_m` initialization bug.\n\nThe `ARY_PTR` and `ARY_LEN` may be modified in `mrb_get_args`.", "target": 0, "func": "ary_modify_check(mrb_state *mrb, struct RArray *a)\n{\n  mrb_check_frozen(mrb, a);\n}", "func_hash": 248199445774405167359553939443734951531, "file_name": "array.c", "file_hash": 295526445825727607536544634773604768998, "cwe": ["CWE-476"], "cve": "CVE-2021-4188", "cve_desc": "mruby is vulnerable to NULL Pointer Dereference", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4188"}
{"idx": 220931, "project": "gpac", "commit_id": "5f2c2a16d30229b6241f02fa28e3d6b810d64858", "project_url": "https://github.com/gpac/gpac", "commit_url": "https://github.com/gpac/gpac/commit/5f2c2a16d30229b6241f02fa28e3d6b810d64858", "commit_message": "fixed #1905", "target": 0, "func": "static void mpgviddmx_check_pid(GF_Filter *filter, GF_MPGVidDmxCtx *ctx, u32 vosh_size, u8 *data)\n{\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tmpgviddmx_check_dur(filter, ctx);\n\t}\n\n\tif ((ctx->width == ctx->dsi.width) && (ctx->height == ctx->dsi.height)) return;\n\n\t//copy properties at init or reconfig\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT(GF_STREAM_VISUAL));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : ctx->cur_fps.num));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_FPS, & PROP_FRAC(ctx->cur_fps));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\n\tctx->width = ctx->dsi.width;\n\tctx->height = ctx->dsi.height;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, & PROP_UINT( ctx->dsi.width));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, & PROP_UINT( ctx->dsi.height));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAR, & PROP_FRAC_INT(ctx->dsi.par_num, ctx->dsi.par_den));\n\n\tif (ctx->is_mpg12) {\n\t\tconst GF_PropertyValue *cid = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_CODECID);\n\t\tu32 PL = ctx->dsi.VideoPL;\n\t\tif (cid) {\n\t\t\tswitch (cid->value.uint) {\n\t\t\tcase GF_CODECID_MPEG2_MAIN:\n\t\t\tcase GF_CODECID_MPEG2_422:\n\t\t\tcase GF_CODECID_MPEG2_SNR:\n\t\t\tcase GF_CODECID_MPEG2_HIGH:\n\t\t\t\t//keep same signaling\n\t\t\t\tPL = cid->value.uint;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!PL) PL = GF_CODECID_MPEG2_MAIN;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(PL));\n\t} else {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(GF_CODECID_MPEG4_PART2));\n\t}\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PROFILE_LEVEL, & PROP_UINT (ctx->dsi.VideoPL) );\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n\n\tctx->b_frames = 0;\n\n\tif (vosh_size) {\n\t\tu32 i;\n\t\tchar * dcfg = gf_malloc(sizeof(char)*vosh_size);\n\t\tmemcpy(dcfg, data, sizeof(char)*vosh_size);\n\n\t\t/*remove packed flag if any (VOSH user data)*/\n\t\tctx->is_packed = ctx->is_vfr = ctx->forced_packed = GF_FALSE;\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar *frame = dcfg;\n\t\t\twhile ((i+3<vosh_size)  && ((frame[i]!=0) || (frame[i+1]!=0) || (frame[i+2]!=1))) i++;\n\t\t\tif (i+4>=vosh_size) break;\n\t\t\tif (strncmp(frame+i+4, \"DivX\", 4)) {\n\t\t\t\ti += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tframe = memchr(dcfg + i + 4, 'p', vosh_size - i - 4);\n\t\t\tif (frame) {\n\t\t\t\tctx->forced_packed = GF_TRUE;\n\t\t\t\tframe[0] = 'n';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, & PROP_DATA_NO_COPY(dcfg, vosh_size));\n\t}\n\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n}", "func_hash": 93422967886668133549690485256646815402, "file_name": "reframe_mpgvid.c", "file_hash": 148306570807841160156662867455353144265, "cwe": ["CWE-476"], "cve": "CVE-2021-40575", "cve_desc": "The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability in the mpgviddmx_process function in reframe_mpgvid.c, which allows attackers to cause a denial of service. This vulnerability is possibly due to an incomplete fix for CVE-2021-40566.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40575"}
{"idx": 220443, "project": "mruby", "commit_id": "27d1e0132a0804581dca28df042e7047fd27eaa8", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8", "commit_message": "array.c: fix `mrb_ary_shift_m` initialization bug.\n\nThe `ARY_PTR` and `ARY_LEN` may be modified in `mrb_get_args`.", "target": 0, "func": "ary_concat(mrb_state *mrb, struct RArray *a, struct RArray *a2)\n{\n  mrb_int len;\n\n  if (ARY_LEN(a) == 0) {\n    ary_replace(mrb, a, a2);\n    return;\n  }\n  if (ARY_LEN(a2) > ARY_MAX_SIZE - ARY_LEN(a)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"array size too big\");\n  }\n  len = ARY_LEN(a) + ARY_LEN(a2);\n\n  ary_modify(mrb, a);\n  if (ARY_CAPA(a) < len) {\n    ary_expand_capa(mrb, a, len);\n  }\n  array_copy(ARY_PTR(a)+ARY_LEN(a), ARY_PTR(a2), ARY_LEN(a2));\n  mrb_write_barrier(mrb, (struct RBasic*)a);\n  ARY_SET_LEN(a, len);\n}", "func_hash": 132695372254683719956007742787020397022, "file_name": "array.c", "file_hash": 295526445825727607536544634773604768998, "cwe": ["CWE-476"], "cve": "CVE-2021-4188", "cve_desc": "mruby is vulnerable to NULL Pointer Dereference", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4188"}
{"idx": 218751, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static Image *ReadEMFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  BITMAPINFO\n    DIBinfo;\n\n  HBITMAP\n    hBitmap,\n    hOldBitmap;\n\n  HDC\n    hDC;\n\n  HENHMETAFILE\n    hemf;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  RECT\n    rect;\n\n  ssize_t\n    x;\n\n  PixelPacket\n    *q;\n\n  RGBQUAD\n    *pBits,\n    *ppBits;\n\n  ssize_t\n    height,\n    width,\n    y;\n\n  image=AcquireImage(image_info);\n  hemf=ReadEnhMetaFile(image_info->filename,&width,&height);\n  if (hemf == (HENHMETAFILE) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((image->columns == 0) || (image->rows == 0))\n    {\n      double\n        y_resolution,\n        x_resolution;\n\n      y_resolution=DefaultResolution;\n      x_resolution=DefaultResolution;\n      if (image->y_resolution > 0)\n        {\n          y_resolution=image->y_resolution;\n          if (image->units == PixelsPerCentimeterResolution)\n            y_resolution*=CENTIMETERS_INCH;\n        }\n      if (image->x_resolution > 0)\n        {\n          x_resolution=image->x_resolution;\n          if (image->units == PixelsPerCentimeterResolution)\n            x_resolution*=CENTIMETERS_INCH;\n        }\n      image->rows=(size_t) ((height/1000.0/CENTIMETERS_INCH)*y_resolution+0.5);\n      image->columns=(size_t) ((width/1000.0/CENTIMETERS_INCH)*\n        x_resolution+0.5);\n    }\n  if (image_info->size != (char *) NULL)\n    {\n      image->columns=width;\n      image->rows=height;\n      (void) GetGeometry(image_info->size,(ssize_t *) NULL,(ssize_t *) NULL,\n        &image->columns,&image->rows);\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_info->page != (char *) NULL)\n    {\n      char\n        *geometry;\n\n      char\n        *p;\n\n      MagickStatusType\n        flags;\n\n      ssize_t\n        sans;\n\n      geometry=GetPageGeometry(image_info->page);\n      p=strchr(geometry,'>');\n      if (p == (char *) NULL)\n        {\n          flags=ParseMetaGeometry(geometry,&sans,&sans,&image->columns,\n            &image->rows);\n          if (image->x_resolution != 0.0)\n            image->columns=(size_t) floor((image->columns*image->x_resolution)+\n              0.5);\n          if (image->y_resolution != 0.0)\n            image->rows=(size_t) floor((image->rows*image->y_resolution)+0.5);\n        }\n      else\n        {\n          *p='\\0';\n          flags=ParseMetaGeometry(geometry,&sans,&sans,&image->columns,\n            &image->rows);\n          if (image->x_resolution != 0.0)\n            image->columns=(size_t) floor(((image->columns*image->x_resolution)/\n              DefaultResolution)+0.5);\n          if (image->y_resolution != 0.0)\n            image->rows=(size_t) floor(((image->rows*image->y_resolution)/\n              DefaultResolution)+0.5);\n        }\n      (void) flags;\n      geometry=DestroyString(geometry);\n    }\n  hDC=GetDC(NULL);\n  if (hDC == (HDC) NULL)\n    {\n      DeleteEnhMetaFile(hemf);\n      ThrowReaderException(ResourceLimitError,\"UnableToCreateADC\");\n    }\n  /*\n    Initialize the bitmap header info.\n  */\n  (void) memset(&DIBinfo,0,sizeof(BITMAPINFO));\n  DIBinfo.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);\n  DIBinfo.bmiHeader.biWidth=(LONG) image->columns;\n  DIBinfo.bmiHeader.biHeight=(-1)*(LONG) image->rows;\n  DIBinfo.bmiHeader.biPlanes=1;\n  DIBinfo.bmiHeader.biBitCount=32;\n  DIBinfo.bmiHeader.biCompression=BI_RGB;\n  hBitmap=CreateDIBSection(hDC,&DIBinfo,DIB_RGB_COLORS,(void **) &ppBits,NULL,\n    0);\n  ReleaseDC(NULL,hDC);\n  if (hBitmap == (HBITMAP) NULL)\n    {\n      DeleteEnhMetaFile(hemf);\n      ThrowReaderException(ResourceLimitError,\"UnableToCreateBitmap\");\n    }\n  hDC=CreateCompatibleDC(NULL);\n  if (hDC == (HDC) NULL)\n    {\n      DeleteEnhMetaFile(hemf);\n      DeleteObject(hBitmap);\n      ThrowReaderException(ResourceLimitError,\"UnableToCreateADC\");\n    }\n  hOldBitmap=(HBITMAP) SelectObject(hDC,hBitmap);\n  if (hOldBitmap == (HBITMAP) NULL)\n    {\n      DeleteEnhMetaFile(hemf);\n      DeleteDC(hDC);\n      DeleteObject(hBitmap);\n      ThrowReaderException(ResourceLimitError,\"UnableToCreateBitmap\");\n    }\n  /*\n    Initialize the bitmap to the image background color.\n  */\n  pBits=ppBits;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      pBits->rgbRed=ScaleQuantumToChar(image->background_color.red);\n      pBits->rgbGreen=ScaleQuantumToChar(image->background_color.green);\n      pBits->rgbBlue=ScaleQuantumToChar(image->background_color.blue);\n      pBits++;\n    }\n  }\n  rect.top=0;\n  rect.left=0;\n  rect.right=(LONG) image->columns;\n  rect.bottom=(LONG) image->rows;\n  /*\n    Convert metafile pixels.\n  */\n  PlayEnhMetaFile(hDC,hemf,&rect);\n  pBits=ppBits;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelRed(q,ScaleCharToQuantum(pBits->rgbRed));\n      SetPixelGreen(q,ScaleCharToQuantum(pBits->rgbGreen));\n      SetPixelBlue(q,ScaleCharToQuantum(pBits->rgbBlue));\n      SetPixelOpacity(q,OpaqueOpacity);\n      pBits++;\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n  DeleteEnhMetaFile(hemf);\n  SelectObject(hDC,hOldBitmap);\n  DeleteDC(hDC);\n  DeleteObject(hBitmap);\n  return(GetFirstImageInList(image));\n}", "func_hash": 122550995580190722696564351194813451780, "file_name": "emf.c", "file_hash": 107669295784465069224649926956785164656, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 208140, "project": "util-linux", "commit_id": "5ebbc3865d1e53ef42e5f121c41faab23dd59075", "project_url": "https://github.com/karelzak/util-linux", "commit_url": "http://git.kernel.org/?p=utils/util-linux/util-linux.git;a=commit;h=5ebbc3865d1e53ef42e5f121c41faab23dd59075", "commit_message": "mount: sanitize paths from non-root users\n\n $ mount /root/.ssh/../../dev/sda2\n mount: only root can mount UUID=17bc65ec-4125-4e7c-8a7d-e2795064c736 on /boot\n\nthis is too promiscuous. It seems better to ignore on command line\nspecified paths which are not resolve-able for non-root users.\n\nFixed version:\n\n  $ mount /root/.ssh/../../dev/sda2\n  mount: /root/.ssh/../../dev/sda2: Permission denied\n\n  $ mount /dev/sda2\n  mount: only root can mount UUID=17bc65ec-4125-4e7c-8a7d-e2795064c736 on /boot\n\nNote that this bug has no relation to mount(2) permissions evaluation\nin suid mode. The way how non-root user specifies paths on command\nline is completely irrelevant for comparison with fstab entries.\n\nSigned-off-by: Karel Zak <kzak@redhat.com>", "target": 1, "func": "int main(int argc, char **argv)\n{\n\tint c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0;\n\tstruct libmnt_context *cxt;\n\tstruct libmnt_table *fstab = NULL;\n\tchar *srcbuf = NULL;\n\tchar *types = NULL;\n\tunsigned long oper = 0;\n\n\tenum {\n\t\tMOUNT_OPT_SHARED = CHAR_MAX + 1,\n\t\tMOUNT_OPT_SLAVE,\n\t\tMOUNT_OPT_PRIVATE,\n\t\tMOUNT_OPT_UNBINDABLE,\n\t\tMOUNT_OPT_RSHARED,\n\t\tMOUNT_OPT_RSLAVE,\n\t\tMOUNT_OPT_RPRIVATE,\n\t\tMOUNT_OPT_RUNBINDABLE,\n\t\tMOUNT_OPT_TARGET,\n\t\tMOUNT_OPT_SOURCE\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"fake\", 0, 0, 'f' },\n\t\t{ \"fstab\", 1, 0, 'T' },\n\t\t{ \"fork\", 0, 0, 'F' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"ro\", 0, 0, 'r' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ \"read-write\", 0, 0, 'w' },\n\t\t{ \"rw\", 0, 0, 'w' },\n\t\t{ \"options\", 1, 0, 'o' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"pass-fd\", 1, 0, 'p' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"uuid\", 1, 0, 'U' },\n\t\t{ \"label\", 1, 0, 'L'},\n\t\t{ \"bind\", 0, 0, 'B' },\n\t\t{ \"move\", 0, 0, 'M' },\n\t\t{ \"rbind\", 0, 0, 'R' },\n\t\t{ \"make-shared\", 0, 0, MOUNT_OPT_SHARED },\n\t\t{ \"make-slave\", 0, 0, MOUNT_OPT_SLAVE },\n\t\t{ \"make-private\", 0, 0, MOUNT_OPT_PRIVATE },\n\t\t{ \"make-unbindable\", 0, 0, MOUNT_OPT_UNBINDABLE },\n\t\t{ \"make-rshared\", 0, 0, MOUNT_OPT_RSHARED },\n\t\t{ \"make-rslave\", 0, 0, MOUNT_OPT_RSLAVE },\n\t\t{ \"make-rprivate\", 0, 0, MOUNT_OPT_RPRIVATE },\n\t\t{ \"make-runbindable\", 0, 0, MOUNT_OPT_RUNBINDABLE },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"show-labels\", 0, 0, 'l' },\n\t\t{ \"target\", 1, 0, MOUNT_OPT_TARGET },\n\t\t{ \"source\", 1, 0, MOUNT_OPT_SOURCE },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {       /* rows and cols in in ASCII order */\n\t\t{ 'B','M','R',\t\t\t/* bind,move,rbind */\n\t\t   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,\n\t\t   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,\n\t\t   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,\n\t\t   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },\n\n\t\t{ 'L','U', MOUNT_OPT_SOURCE },\t/* label,uuid,source */\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\n\twhile ((c = getopt_long(argc, argv, \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\n\t\t/* only few options are allowed for non-root users */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    !strchr(\"hlLUVvpris\", c) &&\n\t\t    c != MOUNT_OPT_TARGET &&\n\t\t    c != MOUNT_OPT_SOURCE)\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tmnt_context_enable_fork(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (mnt_context_append_options(cxt, \"ro\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (mnt_context_append_options(cxt, \"rw\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (mnt_context_append_options(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 'p':\n                        warnx(_(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\txasprintf(&srcbuf, \"LABEL=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\txasprintf(&srcbuf, \"UUID=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tshow_labels = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tfstab = append_fstab(cxt, fstab, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmnt_context_enable_sloppy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toper |= MS_BIND;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\toper |= MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\toper |= (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SHARED:\n\t\t\toper |= MS_SHARED;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SLAVE:\n\t\t\toper |= MS_SLAVE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_PRIVATE:\n\t\t\toper |= MS_PRIVATE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_UNBINDABLE:\n\t\t\toper |= MS_UNBINDABLE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSHARED:\n\t\t\toper |= (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSLAVE:\n\t\t\toper |= (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RPRIVATE:\n\t\t\toper |= (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RUNBINDABLE:\n\t\t\toper |= (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_TARGET:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_target(cxt, optarg);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SOURCE:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (fstab && !mnt_context_is_nocanonicalize(cxt)) {\n\t\t/*\n\t\t * We have external (context independent) fstab instance, let's\n\t\t * make a connection between the fstab and the canonicalization\n\t\t * cache.\n\t\t */\n\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\tmnt_table_set_cache(fstab, cache);\n\t}\n\n\tif (!mnt_context_get_source(cxt) &&\n\t    !mnt_context_get_target(cxt) &&\n\t    !argc &&\n\t    !all) {\n\t\tif (oper)\n\t\t\tusage(stderr);\n\t\tprint_all(cxt, types, show_labels);\n\t\tgoto done;\n\t}\n\n\tif (oper && (types || all || mnt_context_get_source(cxt)))\n\t\tusage(stderr);\n\n\tif (types && (all || strchr(types, ',') ||\n\t\t\t     strncmp(types, \"no\", 2) == 0))\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\telse if (types)\n\t\tmnt_context_set_fstype(cxt, types);\n\n\tif (all) {\n\t\t/*\n\t\t * A) Mount all\n\t\t */\n\t\trc = mount_all(cxt);\n\t\tgoto done;\n\n\t} else if (argc == 0 && (mnt_context_get_source(cxt) ||\n\t\t\t\t mnt_context_get_target(cxt))) {\n\t\t/*\n\t\t * B) mount -L|-U|--source|--target\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt) &&\n\t\t    mnt_context_get_target(cxt))\n\t\t\texit_non_root(NULL);\n\n\t} else if (argc == 1) {\n\t\t/*\n\t\t * C) mount [-L|-U|--source] <target>\n\t\t *    mount <source|target>\n\t\t *\n\t\t * non-root may specify source *or* target, but not both\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt))\n\t\t\texit_non_root(NULL);\n\n\t\tmnt_context_set_target(cxt, argv[0]);\n\n\t} else if (argc == 2 && !mnt_context_get_source(cxt)\n\t\t\t     && !mnt_context_get_target(cxt)) {\n\t\t/*\n\t\t * D) mount <source> <target>\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_source(cxt, argv[0]);\n\t\tmnt_context_set_target(cxt, argv[1]);\n\n\t} else\n\t\tusage(stderr);\n\n\tif (oper) {\n\t\t/* MS_PROPAGATION operations, let's set the mount flags */\n\t\tmnt_context_set_mflags(cxt, oper);\n\n\t\t/* For -make* or --bind is fstab unnecessary */\n\t\tmnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB);\n\t}\n\n\trc = mnt_context_mount(cxt);\n\trc = mk_exit_code(cxt, rc);\n\n\tif (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt))\n\t\tsuccess_message(cxt);\ndone:\n\tmnt_free_context(cxt);\n\tmnt_free_table(fstab);\n\treturn rc;\n}", "func_hash": 219498005792940261578066564094421095366, "file_name": "mount.c", "file_hash": 324534442685972817552003935079520935664, "cwe": ["CWE-200"], "cve": "CVE-2013-0157", "cve_desc": "(a) mount and (b) umount in util-linux 2.14.1, 2.17.2, and probably other versions allow local users to determine the existence of restricted directories by (1) using the --guess-fstype command-line option or (2) attempting to mount a non-existent device, which generates different error messages depending on whether the directory exists.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-0157"}
{"idx": 90828, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  void set_db_disabled(bool db_disabled) {\n    db_disabled_ = db_disabled;\n  }\n", "func_hash": 65245838285767773216647767618793825540, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90168, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "static ConnectionState ParseState(const std::string& state) {\n  if (state == kStateIdle)\n    return STATE_IDLE;\n  if (state == kStateCarrier)\n    return STATE_CARRIER;\n  if (state == kStateAssociation)\n    return STATE_ASSOCIATION;\n  if (state == kStateConfiguration)\n    return STATE_CONFIGURATION;\n  if (state == kStateReady)\n    return STATE_READY;\n  if (state == kStateDisconnect)\n    return STATE_DISCONNECT;\n  if (state == kStateFailure)\n    return STATE_FAILURE;\n  if (state == kStateActivationFailure)\n    return STATE_ACTIVATION_FAILURE;\n  return STATE_UNKNOWN;\n}\n", "func_hash": 251788502362499443908390417562018916699, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 221694, "project": "e2guardian", "commit_id": "eae46a7e2a57103aadca903c4a24cca94dc502a2", "project_url": "https://github.com/e2guardian/e2guardian", "commit_url": "https://github.com/e2guardian/e2guardian/commit/eae46a7e2a57103aadca903c4a24cca94dc502a2", "commit_message": "Fix bug #707 cert hostnames not being checked\n- only happened when openssl v1.1 is used", "target": 0, "func": "Socket *Socket::accept() {\n    peer_adr_length = sizeof(struct sockaddr_in);\n    s_errno = 0;\n    errno = 0;\n//    int newfd = this->baseAccept((struct sockaddr *)&peer_adr, &peer_adr_length);\n    int newfd = ::accept(sck, (struct sockaddr *) &peer_adr, &peer_adr_length);\n\n    if (newfd > 0) {\n        Socket *s = new Socket(newfd, my_adr, peer_adr);\n        s->setPort(my_port);\n        return s;\n    } else {\n        s_errno = errno;\n        return NULL;\n    }\n}", "func_hash": 231120615862306967661727934831285641865, "file_name": "Socket.cpp", "file_hash": 316707147744091371767800459911917453562, "cwe": ["CWE-295"], "cve": "CVE-2021-44273", "cve_desc": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-44273"}
{"idx": 196993, "project": "libjxl", "commit_id": "7dfa400ded53919d986c5d3d23446a09e0cf481b", "project_url": "https://github.com/libjxl/libjxl", "commit_url": "https://github.com/libjxl/libjxl/commit/7dfa400ded53919d986c5d3d23446a09e0cf481b", "commit_message": "Fix handling of APNG with 0 delay_den (#313)", "target": 1, "func": "Status DecodeImageAPNG(Span<const uint8_t> bytes, ThreadPool* pool,\n                       CodecInOut* io) {\n  Reader r;\n  unsigned int id, i, j, w, h, w0, h0, x0, y0;\n  unsigned int delay_num, delay_den, dop, bop, rowbytes, imagesize;\n  unsigned char sig[8];\n  png_structp png_ptr;\n  png_infop info_ptr;\n  CHUNK chunk;\n  CHUNK chunkIHDR;\n  std::vector<CHUNK> chunksInfo;\n  bool isAnimated = false;\n  bool skipFirst = false;\n  bool hasInfo = false;\n  bool all_dispose_bg = true;\n  APNGFrame frameRaw = {};\n\n  r = {bytes.data(), bytes.data() + bytes.size()};\n  // Not an aPNG => not an error\n  unsigned char png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};\n  if (r.Read(sig, 8) || memcmp(sig, png_signature, 8) != 0) {\n    return false;\n  }\n  id = read_chunk(&r, &chunkIHDR);\n\n  io->frames.clear();\n  io->dec_pixels = 0;\n  io->metadata.m.SetUintSamples(8);\n  io->metadata.m.SetAlphaBits(8);\n  io->metadata.m.color_encoding =\n      ColorEncoding::SRGB();  // todo: get data from png metadata\n  (void)io->dec_hints.Foreach(\n      [](const std::string& key, const std::string& /*value*/) {\n        JXL_WARNING(\"APNG decoder ignoring %s hint\", key.c_str());\n        return true;\n      });\n\n  bool errorstate = true;\n  if (id == kId_IHDR && chunkIHDR.size == 25) {\n    w0 = w = png_get_uint_32(chunkIHDR.p + 8);\n    h0 = h = png_get_uint_32(chunkIHDR.p + 12);\n\n    if (w > cMaxPNGSize || h > cMaxPNGSize) {\n      return false;\n    }\n\n    x0 = 0;\n    y0 = 0;\n    delay_num = 1;\n    delay_den = 10;\n    dop = 0;\n    bop = 0;\n    rowbytes = w * 4;\n    imagesize = h * rowbytes;\n\n    frameRaw.p = new unsigned char[imagesize];\n    frameRaw.rows = new png_bytep[h * sizeof(png_bytep)];\n    for (j = 0; j < h; j++) frameRaw.rows[j] = frameRaw.p + j * rowbytes;\n\n    if (!processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,\n                          chunkIHDR, chunksInfo)) {\n      bool last_base_was_none = true;\n      while (!r.Eof()) {\n        id = read_chunk(&r, &chunk);\n        if (!id) break;\n        JXL_ASSERT(chunk.p != nullptr);\n\n        if (id == kId_acTL && !hasInfo && !isAnimated) {\n          isAnimated = true;\n          skipFirst = true;\n          io->metadata.m.have_animation = true;\n          io->metadata.m.animation.tps_numerator = 1000;\n        } else if (id == kId_IEND ||\n                   (id == kId_fcTL && (!hasInfo || isAnimated))) {\n          if (hasInfo) {\n            if (!processing_finish(png_ptr, info_ptr)) {\n              ImageBundle bundle(&io->metadata.m);\n              bundle.duration = delay_num * 1000 / delay_den;\n              bundle.origin.x0 = x0;\n              bundle.origin.y0 = y0;\n              // TODO(veluca): this could in principle be implemented.\n              if (last_base_was_none && !all_dispose_bg &&\n                  (x0 != 0 || y0 != 0 || w0 != w || h0 != h || bop != 0)) {\n                return JXL_FAILURE(\n                    \"APNG with dispose-to-0 is not supported for non-full or \"\n                    \"blended frames\");\n              }\n              switch (dop) {\n                case 0:\n                  bundle.use_for_next_frame = true;\n                  last_base_was_none = false;\n                  all_dispose_bg = false;\n                  break;\n                case 2:\n                  bundle.use_for_next_frame = false;\n                  all_dispose_bg = false;\n                  break;\n                default:\n                  bundle.use_for_next_frame = false;\n                  last_base_was_none = true;\n              }\n              bundle.blend = bop != 0;\n              io->dec_pixels += w0 * h0;\n\n              Image3F sub_frame(w0, h0);\n              ImageF sub_frame_alpha(w0, h0);\n              for (size_t y = 0; y < h0; ++y) {\n                float* const JXL_RESTRICT row_r = sub_frame.PlaneRow(0, y);\n                float* const JXL_RESTRICT row_g = sub_frame.PlaneRow(1, y);\n                float* const JXL_RESTRICT row_b = sub_frame.PlaneRow(2, y);\n                float* const JXL_RESTRICT row_alpha = sub_frame_alpha.Row(y);\n                uint8_t* const f = frameRaw.rows[y];\n                for (size_t x = 0; x < w0; ++x) {\n                  if (f[4 * x + 3] == 0) {\n                    row_alpha[x] = 0;\n                    row_r[x] = 0;\n                    row_g[x] = 0;\n                    row_b[x] = 0;\n                    continue;\n                  }\n                  row_r[x] = f[4 * x + 0] * (1.f / 255);\n                  row_g[x] = f[4 * x + 1] * (1.f / 255);\n                  row_b[x] = f[4 * x + 2] * (1.f / 255);\n                  row_alpha[x] = f[4 * x + 3] * (1.f / 255);\n                }\n              }\n              bundle.SetFromImage(std::move(sub_frame), ColorEncoding::SRGB());\n              bundle.SetAlpha(std::move(sub_frame_alpha),\n                              /*alpha_is_premultiplied=*/false);\n              io->frames.push_back(std::move(bundle));\n            } else {\n              delete[] chunk.p;\n              break;\n            }\n          }\n\n          if (id == kId_IEND) {\n            errorstate = false;\n            break;\n          }\n          // At this point the old frame is done. Let's start a new one.\n          w0 = png_get_uint_32(chunk.p + 12);\n          h0 = png_get_uint_32(chunk.p + 16);\n          x0 = png_get_uint_32(chunk.p + 20);\n          y0 = png_get_uint_32(chunk.p + 24);\n          delay_num = png_get_uint_16(chunk.p + 28);\n          delay_den = png_get_uint_16(chunk.p + 30);\n          dop = chunk.p[32];\n          bop = chunk.p[33];\n\n          if (w0 > cMaxPNGSize || h0 > cMaxPNGSize || x0 > cMaxPNGSize ||\n              y0 > cMaxPNGSize || x0 + w0 > w || y0 + h0 > h || dop > 2 ||\n              bop > 1) {\n            delete[] chunk.p;\n            break;\n          }\n\n          if (hasInfo) {\n            memcpy(chunkIHDR.p + 8, chunk.p + 12, 8);\n            if (processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,\n                                 chunkIHDR, chunksInfo)) {\n              delete[] chunk.p;\n              break;\n            }\n          } else\n            skipFirst = false;\n\n          if (io->frames.size() == (skipFirst ? 1 : 0)) {\n            bop = 0;\n            if (dop == 2) dop = 1;\n          }\n        } else if (id == kId_IDAT) {\n          hasInfo = true;\n          if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {\n            delete[] chunk.p;\n            break;\n          }\n        } else if (id == kId_fdAT && isAnimated) {\n          png_save_uint_32(chunk.p + 4, chunk.size - 16);\n          memcpy(chunk.p + 8, \"IDAT\", 4);\n          if (processing_data(png_ptr, info_ptr, chunk.p + 4, chunk.size - 4)) {\n            delete[] chunk.p;\n            break;\n          }\n        } else if (!isAbc(chunk.p[4]) || !isAbc(chunk.p[5]) ||\n                   !isAbc(chunk.p[6]) || !isAbc(chunk.p[7])) {\n          delete[] chunk.p;\n          break;\n        } else if (!hasInfo) {\n          if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {\n            delete[] chunk.p;\n            break;\n          }\n          chunksInfo.push_back(chunk);\n          continue;\n        }\n        delete[] chunk.p;\n      }\n    }\n    delete[] frameRaw.rows;\n    delete[] frameRaw.p;\n  }\n\n  for (i = 0; i < chunksInfo.size(); i++) delete[] chunksInfo[i].p;\n\n  chunksInfo.clear();\n  delete[] chunkIHDR.p;\n\n  if (errorstate) return false;\n  SetIntensityTarget(io);\n  return true;\n}", "func_hash": 313851366023244520296960010326993371914, "file_name": "codec_apng.cc", "file_hash": 303923165706235443177070807550807665571, "cwe": ["CWE-369"], "cve": "CVE-2021-36692", "cve_desc": "libjxl v0.3.7 is affected by a Divide By Zero in issue in lib/extras/codec_apng.cc jxl::DecodeImageAPNG(). When encoding a malicous APNG file using cjxl, an attacker can trigger a denial of service.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-36692"}
{"idx": 221687, "project": "e2guardian", "commit_id": "eae46a7e2a57103aadca903c4a24cca94dc502a2", "project_url": "https://github.com/e2guardian/e2guardian", "commit_url": "https://github.com/e2guardian/e2guardian/commit/eae46a7e2a57103aadca903c4a24cca94dc502a2", "commit_message": "Fix bug #707 cert hostnames not being checked\n- only happened when openssl v1.1 is used", "target": 0, "func": "bool Socket::breadyForOutput(int timeout)\n{\n    //if (!isssl) {\n        return BaseSocket::breadyForOutput(timeout);\n    //}\n    //return true;\n}", "func_hash": 340046277624637435563427412905352041685, "file_name": "Socket.cpp", "file_hash": 316707147744091371767800459911917453562, "cwe": ["CWE-295"], "cve": "CVE-2021-44273", "cve_desc": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-44273"}
{"idx": 215342, "project": "linux-2.6", "commit_id": "89f5b7da2a6bad2e84670422ab8192382a5aeb9f", "project_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6", "commit_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=89f5b7da2a6bad2e84670422ab8192382a5aeb9f", "commit_message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, int len, int write, int force,\n\t\tstruct page **pages, struct vm_area_struct **vmas)\n{\n\tint i;\n\tunsigned int vm_flags;\n\n\tif (len <= 0)\n\t\treturn 0;\n\t/* \n\t * Require read or write permissions.\n\t * If 'force' is set, we only require the \"MAY\" flags.\n\t */\n\tvm_flags  = write ? (VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);\n\tvm_flags &= force ? (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);\n\ti = 0;\n\n\tdo {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned int foll_flags;\n\n\t\tvma = find_extend_vma(mm, start);\n\t\tif (!vma && in_gate_area(tsk, start)) {\n\t\t\tunsigned long pg = start & PAGE_MASK;\n\t\t\tstruct vm_area_struct *gate_vma = get_gate_vma(tsk);\n\t\t\tpgd_t *pgd;\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\t\t\tpte_t *pte;\n\t\t\tif (write) /* user gate pages are read-only */\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tif (pg > TASK_SIZE)\n\t\t\t\tpgd = pgd_offset_k(pg);\n\t\t\telse\n\t\t\t\tpgd = pgd_offset_gate(mm, pg);\n\t\t\tBUG_ON(pgd_none(*pgd));\n\t\t\tpud = pud_offset(pgd, pg);\n\t\t\tBUG_ON(pud_none(*pud));\n\t\t\tpmd = pmd_offset(pud, pg);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tpte = pte_offset_map(pmd, pg);\n\t\t\tif (pte_none(*pte)) {\n\t\t\t\tpte_unmap(pte);\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tstruct page *page = vm_normal_page(gate_vma, start, *pte);\n\t\t\t\tpages[i] = page;\n\t\t\t\tif (page)\n\t\t\t\t\tget_page(page);\n\t\t\t}\n\t\t\tpte_unmap(pte);\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = gate_vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!vma || (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\t\t\t|| !(vm_flags & vma->vm_flags))\n\t\t\treturn i ? : -EFAULT;\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t\t&start, &len, i, write);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfoll_flags = FOLL_TOUCH;\n\t\tif (pages)\n\t\t\tfoll_flags |= FOLL_GET;\n\t\tif (!write && !(vma->vm_flags & VM_LOCKED) &&\n\t\t    (!vma->vm_ops || !vma->vm_ops->fault))\n\t\t\tfoll_flags |= FOLL_ANON;\n\n\t\tdo {\n\t\t\tstruct page *page;\n\n\t\t\t/*\n\t\t\t * If tsk is ooming, cut off its access to large memory\n\t\t\t * allocations. It has a pending SIGKILL, but it can't\n\t\t\t * be processed until returning to user space.\n\t\t\t */\n\t\t\tif (unlikely(test_tsk_thread_flag(tsk, TIF_MEMDIE)))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (write)\n\t\t\t\tfoll_flags |= FOLL_WRITE;\n\n\t\t\tcond_resched();\n\t\t\twhile (!(page = follow_page(vma, start, foll_flags))) {\n\t\t\t\tint ret;\n\t\t\t\tret = handle_mm_fault(mm, vma, start,\n\t\t\t\t\t\tfoll_flags & FOLL_WRITE);\n\t\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\t\tif (ret & VM_FAULT_OOM)\n\t\t\t\t\t\treturn i ? i : -ENOMEM;\n\t\t\t\t\telse if (ret & VM_FAULT_SIGBUS)\n\t\t\t\t\t\treturn i ? i : -EFAULT;\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\t\t\ttsk->maj_flt++;\n\t\t\t\telse\n\t\t\t\t\ttsk->min_flt++;\n\n\t\t\t\t/*\n\t\t\t\t * The VM_FAULT_WRITE bit tells us that\n\t\t\t\t * do_wp_page has broken COW when necessary,\n\t\t\t\t * even if maybe_mkwrite decided not to set\n\t\t\t\t * pte_write. We can thus safely do subsequent\n\t\t\t\t * page lookups as if they were reads.\n\t\t\t\t */\n\t\t\t\tif (ret & VM_FAULT_WRITE)\n\t\t\t\t\tfoll_flags &= ~FOLL_WRITE;\n\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tpages[i] = page;\n\n\t\t\t\tflush_anon_page(vma, page, start);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t} while (len && start < vma->vm_end);\n\t} while (len);\n\treturn i;\n}", "func_hash": 297439389611921948610845954015708789280, "file_name": "None", "file_hash": null, "cwe": ["CWE-20"], "cve": "CVE-2008-2372", "cve_desc": "The Linux kernel 2.6.24 and 2.6.25 before 2.6.25.9 allows local users to cause a denial of service (memory consumption) via a large number of calls to the get_user_pages function, which lacks a ZERO_PAGE optimization and results in allocation of \"useless newly zeroed pages.\"", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2008-2372"}
{"idx": 222495, "project": "tensorflow", "commit_id": "3d89911481ba6ebe8c88c1c0b595412121e6c645", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/3d89911481ba6ebe8c88c1c0b595412121e6c645", "commit_message": "Eliminate `CHECK`-fail from `function.cc`.\n\nPiperOrigin-RevId: 409414744\nChange-Id: Ic854e12ab2edb88b165d32e2d632c4ee654d71ad", "target": 0, "func": "FunctionCallFrame::FunctionCallFrame(DataTypeSlice arg_types,\n                                     DataTypeSlice ret_types)\n    : arg_types_(arg_types.begin(), arg_types.end()),\n      ret_types_(ret_types.begin(), ret_types.end()) {\n  args_.resize(arg_types_.size());\n  rets_.resize(ret_types_.size());\n}", "func_hash": 106520134298915519345582576981089634992, "file_name": "function.cc", "file_hash": 275755455359751936167516531130081059449, "cwe": ["CWE-617"], "cve": "CVE-2022-23586", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that assertions in `function.cc` would be falsified and crash the Python interpreter. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23586"}
{"idx": 211839, "project": "vim", "commit_id": "e3537aec2f8d6470010547af28dcbd83d41461b8", "project_url": "https://github.com/vim/vim", "commit_url": "https://github.com/vim/vim/commit/e3537aec2f8d6470010547af28dcbd83d41461b8", "commit_message": "patch 8.2.4327: may end up with no current buffer\n\nProblem:    May end up with no current buffer.\nSolution:   When deleting the current buffer to not pick a quickfix buffer as\n            the new current buffer.", "target": 1, "func": "do_buffer_ext(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tflags)\t\t// DOBUF_FORCEIT etc.\n{\n    buf_T\t*buf;\n    buf_T\t*bp;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n\n    switch (start)\n    {\n\tcase DOBUF_FIRST:   buf = firstbuf; break;\n\tcase DOBUF_LAST:    buf = lastbuf;  break;\n\tdefault:\t    buf = curbuf;   break;\n    }\n    if (start == DOBUF_MOD)\t    // find next modified buffer\n    {\n\twhile (count-- > 0)\n\t{\n\t    do\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    while (buf != curbuf && !bufIsChanged(buf));\n\t}\n\tif (!bufIsChanged(buf))\n\t{\n\t    emsg(_(e_no_modified_buffer_found));\n\t    return FAIL;\n\t}\n    }\n    else if (start == DOBUF_FIRST && count) // find specified buffer number\n    {\n\twhile (buf != NULL && buf->b_fnum != count)\n\t    buf = buf->b_next;\n    }\n    else\n    {\n\tbp = NULL;\n\twhile (count > 0 || (!unload && !buf->b_p_bl && bp != buf))\n\t{\n\t    // remember the buffer where we start, we come back there when all\n\t    // buffers are unlisted.\n\t    if (bp == NULL)\n\t\tbp = buf;\n\t    if (dir == FORWARD)\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    else\n\t    {\n\t\tbuf = buf->b_prev;\n\t\tif (buf == NULL)\n\t\t    buf = lastbuf;\n\t    }\n\t    // don't count unlisted buffers\n\t    if (unload || buf->b_p_bl)\n\t    {\n\t\t --count;\n\t\t bp = NULL;\t// use this buffer as new starting point\n\t    }\n\t    if (bp == buf)\n\t    {\n\t\t// back where we started, didn't find anything.\n\t\temsg(_(e_there_is_no_listed_buffer));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n\n    if (buf == NULL)\t    // could not find it\n    {\n\tif (start == DOBUF_FIRST)\n\t{\n\t    // don't warn when deleting\n\t    if (!unload)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\t}\n\telse if (dir == FORWARD)\n\t    emsg(_(e_cannot_go_beyond_last_buffer));\n\telse\n\t    emsg(_(e_cannot_go_before_first_buffer));\n\treturn FAIL;\n    }\n#ifdef FEAT_PROP_POPUP\n    if ((flags & DOBUF_NOPOPUP) && bt_popup(buf)\n# ifdef FEAT_TERMINAL\n\t\t\t\t&& !bt_terminal(buf)\n#endif\n       )\n\treturn OK;\n#endif\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * delete buffer \"buf\" from memory and/or the list\n     */\n    if (unload)\n    {\n\tint\tforward;\n\tbufref_T bufref;\n\n\tif (!can_unload_buffer(buf))\n\t    return FAIL;\n\n\tset_bufref(&bufref, buf);\n\n\t// When unloading or deleting a buffer that's already unloaded and\n\t// unlisted: fail silently.\n\tif (action != DOBUF_WIPE && action != DOBUF_WIPE_REUSE\n\t\t\t\t   && buf->b_ml.ml_mfp == NULL && !buf->b_p_bl)\n\t    return FAIL;\n\n\tif ((flags & DOBUF_FORCEIT) == 0 && bufIsChanged(buf))\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t    {\n\t\tdialog_changed(buf, FALSE);\n\t\tif (!bufref_valid(&bufref))\n\t\t    // Autocommand deleted buffer, oops!  It's not changed\n\t\t    // now.\n\t\t    return FAIL;\n\t\t// If it's still changed fail silently, the dialog already\n\t\t// mentioned why it fails.\n\t\tif (bufIsChanged(buf))\n\t\t    return FAIL;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tsemsg(_(e_no_write_since_last_change_for_buffer_nr_add_bang_to_override),\n\t\t\t\t\t\t\t\t buf->b_fnum);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// When closing the current buffer stop Visual mode.\n\tif (buf == curbuf && VIsual_active)\n\t    end_visual_mode();\n\n\t// If deleting the last (listed) buffer, make it empty.\n\t// The last (listed) buffer cannot be unloaded.\n\tFOR_ALL_BUFFERS(bp)\n\t    if (bp->b_p_bl && bp != buf)\n\t\tbreak;\n\tif (bp == NULL && buf == curbuf)\n\t    return empty_curbuf(TRUE, (flags & DOBUF_FORCEIT), action);\n\n\t// If the deleted buffer is the current one, close the current window\n\t// (unless it's the only window).  Repeat this so long as we end up in\n\t// a window with this buffer.\n\twhile (buf == curbuf\n\t\t   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)\n\t\t   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))\n\t{\n\t    if (win_close(curwin, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\n\t// If the buffer to be deleted is not the current one, delete it here.\n\tif (buf != curbuf)\n\t{\n\t    close_windows(buf, FALSE);\n\t    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0)\n\t\t    close_buffer(NULL, buf, action, FALSE, FALSE);\n\t    return OK;\n\t}\n\n\t/*\n\t * Deleting the current buffer: Need to find another buffer to go to.\n\t * There should be another, otherwise it would have been handled\n\t * above.  However, autocommands may have deleted all buffers.\n\t * First use au_new_curbuf.br_buf, if it is valid.\n\t * Then prefer the buffer we most recently visited.\n\t * Else try to find one that is loaded, after the current buffer,\n\t * then before the current buffer.\n\t * Finally use any buffer.\n\t */\n\tbuf = NULL;\t// selected buffer\n\tbp = NULL;\t// used when no loaded buffer found\n\tif (au_new_curbuf.br_buf != NULL && bufref_valid(&au_new_curbuf))\n\t    buf = au_new_curbuf.br_buf;\n\telse if (curwin->w_jumplistlen > 0)\n\t{\n\t    int     jumpidx;\n\n\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    if (buf == curbuf || !buf->b_p_bl)\n\t\t\tbuf = NULL;\t// skip current and unlisted bufs\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   // found a valid buffer: stop searching\n\t\t    break;\n\t\t// advance to older entry in jump list\n\t\tif (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen)\n\t\t    break;\n\t\tif (--jumpidx < 0)\n\t\t    jumpidx = curwin->w_jumplistlen - 1;\n\t\tif (jumpidx == forward)\t\t// List exhausted for sure\n\t\t    break;\n\t    }\n\t}\n\n\tif (buf == NULL)\t// No previous buffer, Try 2'nd approach\n\t{\n\t    forward = TRUE;\n\t    buf = curbuf->b_next;\n\t    for (;;)\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t// tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl)\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf)\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t// Autocommands must have wiped out all other buffers.  Only option\n\t// now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n\n    /*\n     * make \"buf\" the current buffer\n     */\n    if (action == DOBUF_SPLIT)\t    // split window first\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))\n\t    return OK;\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))\n\t    return OK;\n\tif (win_split(0, 0) == FAIL)\n\t    return FAIL;\n    }\n\n    // go to current buffer - nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    // Check if the current buffer may be abandoned.\n    if (action == DOBUF_GOTO && !can_abandon(curbuf, (flags & DOBUF_FORCEIT)))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n\t    bufref_T bufref;\n\n\t    set_bufref(&bufref, buf);\n\t    dialog_changed(curbuf, FALSE);\n\t    if (!bufref_valid(&bufref))\n\t\t// Autocommand deleted buffer, oops!\n\t\treturn FAIL;\n\t}\n\tif (bufIsChanged(curbuf))\n#endif\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n    }\n\n    // Go to the other buffer.\n    set_curbuf(buf, action);\n\n    if (action == DOBUF_SPLIT)\n\tRESET_BINDING(curwin);\t// reset 'scrollbind' and 'cursorbind'\n\n#if defined(FEAT_EVAL)\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n\n    return OK;\n}", "func_hash": 216071161227941420054722097972946187314, "file_name": "buffer.c", "file_hash": 257748180517579989542202694193677026568, "cwe": ["CWE-823"], "cve": "CVE-2022-0554", "cve_desc": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 8.2.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0554"}
{"idx": 204278, "project": "firejail", "commit_id": "1884ea22a90d225950d81c804f1771b42ae55f54", "project_url": "https://github.com/netblue30/firejail", "commit_url": "https://github.com/netblue30/firejail/commit/1884ea22a90d225950d81c804f1771b42ae55f54", "commit_message": "CVE-2022-31214: fixing the fix, one more time\n\nthe previous commit \"CVE-2022-31214: fixing the fix\"\nmade private-etc=fonts,fonts and similar commands\nfail with an error\n\nfix that regression by tolerating already existing\ndirectories", "target": 1, "func": "static void build_dirs(char *src, char *dst, size_t src_prefix_len, size_t dst_prefix_len) {\n\tchar *p = src + src_prefix_len + 1;\n\tchar *q = dst + dst_prefix_len + 1;\n\tchar *r = dst + dst_prefix_len;\n\tstruct stat s;\n\tbool last = false;\n\t*r = '\\0';\n\tfor (; !last; p++, q++) {\n\t\tif (*p == '\\0') {\n\t\t\tlast = true;\n\t\t}\n\t\tif (*p == '\\0' || (*p == '/' && *(p - 1) != '/')) {\n\t\t\t// We found a new component of our src path.\n\t\t\t// Null-terminate it temporarily here so that we can work\n\t\t\t// with it.\n\t\t\t*p = '\\0';\n\t\t\tif (stat(src, &s) == 0 && S_ISDIR(s.st_mode)) {\n\t\t\t\t// Null-terminate the dst path and undo its previous\n\t\t\t\t// termination.\n\t\t\t\t*q = '\\0';\n\t\t\t\t*r = '/';\n\t\t\t\tr = q;\n\t\t\t\tmkdir_attr(dst, s.st_mode, 0, 0);\n\t\t\t}\n\t\t\tif (!last) {\n\t\t\t\t// If we're not at the final terminating null, restore\n\t\t\t\t// the slash so that we can continue our traversal.\n\t\t\t\t*p = '/';\n\t\t\t}\n\t\t}\n\t}\n}", "func_hash": 306665336163416948713995999483700256340, "file_name": "None", "file_hash": null, "cwe": ["CWE-94"], "cve": "CVE-2022-31214", "cve_desc": "A Privilege Context Switching issue was discovered in join.c in Firejail 0.9.68. By crafting a bogus Firejail container that is accepted by the Firejail setuid-root program as a join target, a local attacker can enter an environment in which the Linux user namespace is still the initial user namespace, the NO_NEW_PRIVS prctl is not activated, and the entered mount namespace is under the attacker's control. In this way, the filesystem layout can be adjusted to gain root privileges through execution of available setuid-root binaries such as su or sudo.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-31214"}
{"idx": 163835, "project": "Chrome", "commit_id": "6d067124e87295721c62a77f0610e4b37f6098ad", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/6d067124e87295721c62a77f0610e4b37f6098ad", "commit_message": "None", "target": 0, "func": "v8::Handle<v8::Value> V8ThrowException::createDOMException(v8::Isolate* isolate, int ec, const String& sanitizedMessage, const String& unsanitizedMessage, const v8::Handle<v8::Object>& creationContext)\n{\n    if (ec <= 0 || v8::V8::IsExecutionTerminating())\n        return v8Undefined();\n\n    ASSERT(ec == SecurityError || unsanitizedMessage.isEmpty());\n\n    if (ec == V8GeneralError)\n        return V8ThrowException::createGeneralError(isolate, sanitizedMessage);\n    if (ec == V8TypeError)\n        return V8ThrowException::createTypeError(isolate, sanitizedMessage);\n    if (ec == V8RangeError)\n        return V8ThrowException::createRangeError(isolate, sanitizedMessage);\n    if (ec == V8SyntaxError)\n        return V8ThrowException::createSyntaxError(isolate, sanitizedMessage);\n     if (ec == V8ReferenceError)\n         return V8ThrowException::createReferenceError(isolate, sanitizedMessage);\n \n    v8::Handle<v8::Object> sanitizedCreationContext = creationContext;\n\n    // FIXME: Is the current context always the right choice?\n    Frame* frame = toFrameIfNotDetached(creationContext->CreationContext());\n    if (!frame || !BindingSecurity::shouldAllowAccessToFrame(isolate, frame, DoNotReportSecurityError))\n        sanitizedCreationContext = isolate->GetCurrentContext()->Global();\n\n\n     RefPtrWillBeRawPtr<DOMException> domException = DOMException::create(ec, sanitizedMessage, unsanitizedMessage);\n    v8::Handle<v8::Value> exception = toV8(domException.get(), sanitizedCreationContext, isolate);\n \n     if (exception.IsEmpty())\n         return v8Undefined();\n\n    v8::Handle<v8::Value> error = v8::Exception::Error(v8String(isolate, domException->message()));\n    ASSERT(!error.IsEmpty());\n    ASSERT(exception->IsObject());\n    exception->ToObject(isolate)->SetAccessor(v8AtomicString(isolate, \"stack\"), domExceptionStackGetter, domExceptionStackSetter, error);\n    V8HiddenValue::setHiddenValue(isolate, exception->ToObject(isolate), V8HiddenValue::error(isolate), error);\n\n    return exception;\n}\n", "func_hash": 168935182956535440218897240793107318772, "file_name": "None", "file_hash": null, "cwe": [], "cve": "CVE-2015-1210", "cve_desc": "", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1210"}
{"idx": 96947, "project": "Chrome", "commit_id": "3c1864079c441ea2e08f882acaaf441f78a6de3d", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/3c1864079c441ea2e08f882acaaf441f78a6de3d", "commit_message": "None", "target": 0, "func": "bool decode(ArgumentDecoder* decoder, RetainPtr<CFNumberRef>& result)\n{\n    CFNumberType numberType;\n    if (!decoder->decodeEnum(numberType))\n        return false;\n\n    CoreIPC::DataReference dataReference;\n    if (!decoder->decode(dataReference))\n        return false;\n\n    size_t neededBufferSize = sizeForNumberType(numberType);\n    if (!neededBufferSize || dataReference.size() != neededBufferSize)\n        return false;\n\n    ASSERT(dataReference.data());\n    CFNumberRef number = CFNumberCreate(0, numberType, dataReference.data());\n    result.adoptCF(number);\n\n    return true;\n}\n", "func_hash": 19895660395290471297813488445728147255, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90147, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "std::string CellularNetwork::GetRoamingStateString() const {\n  switch (this->roaming_state_) {\n    case ROAMING_STATE_HOME:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ROAMING_STATE_HOME);\n      break;\n    case ROAMING_STATE_ROAMING:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ROAMING_STATE_ROAMING);\n      break;\n    default:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ROAMING_STATE_UNKNOWN);\n      break;\n  };\n}\n", "func_hash": 72467369506769717092083373186802673469, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90228, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  virtual bool wifi_connecting() const { return false; }\n", "func_hash": 225440400449884495075596154526819448090, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 221672, "project": "e2guardian", "commit_id": "eae46a7e2a57103aadca903c4a24cca94dc502a2", "project_url": "https://github.com/e2guardian/e2guardian", "commit_url": "https://github.com/e2guardian/e2guardian/commit/eae46a7e2a57103aadca903c4a24cca94dc502a2", "commit_message": "Fix bug #707 cert hostnames not being checked\n- only happened when openssl v1.1 is used", "target": 0, "func": "bool Socket::bcheckForInput(int timeout)\n{\n    if (!isssl) {\n        return BaseSocket::bcheckForInput(timeout);\n    }\n    return true;\n}", "func_hash": 270027910491376438276684467152920727672, "file_name": "Socket.cpp", "file_hash": 316707147744091371767800459911917453562, "cwe": ["CWE-295"], "cve": "CVE-2021-44273", "cve_desc": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-44273"}
{"idx": 220857, "project": "tensorflow", "commit_id": "8c6f391a2282684a25cbfec7687bd5d35261a209", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/8c6f391a2282684a25cbfec7687bd5d35261a209", "commit_message": "[lite] Add check for bias_size is zero to avoid division by zero. This shouldn't happen for properly converted models. Just safety check\n\nPiperOrigin-RevId: 416383645\nChange-Id: If8e508bf696ae8ecfb927e69c139a8ccf7fe60cb", "target": 0, "func": "inline int SubscriptToIndex(const NdArrayDesc<8>& desc, int indexes[8]) {\n  return indexes[0] * desc.strides[0] + indexes[1] * desc.strides[1] +\n         indexes[2] * desc.strides[2] + indexes[3] * desc.strides[3] +\n         indexes[4] * desc.strides[4] + indexes[5] * desc.strides[5] +\n         indexes[6] * desc.strides[6] + indexes[7] * desc.strides[7];\n}", "func_hash": 241033252007328706571329087864588872501, "file_name": "common.h", "file_hash": 206010119069068373550820723284960883967, "cwe": ["CWE-369"], "cve": "CVE-2022-23557", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would trigger a division by zero in `BiasAndClamp` implementation. There is no check that the `bias_size` is non zero. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23557"}
{"idx": 220394, "project": "mruby", "commit_id": "27d1e0132a0804581dca28df042e7047fd27eaa8", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8", "commit_message": "array.c: fix `mrb_ary_shift_m` initialization bug.\n\nThe `ARY_PTR` and `ARY_LEN` may be modified in `mrb_get_args`.", "target": 0, "func": "mrb_ary_replace_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value other;\n\n  mrb_get_args(mrb, \"A\", &other);\n  mrb_ary_replace(mrb, self, other);\n\n  return self;\n}", "func_hash": 139434288397840371166199858035571491483, "file_name": "array.c", "file_hash": 295526445825727607536544634773604768998, "cwe": ["CWE-476"], "cve": "CVE-2021-4188", "cve_desc": "mruby is vulnerable to NULL Pointer Dereference", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4188"}
{"idx": 202892, "project": "pure-ftpd", "commit_id": "37ad222868e52271905b94afea4fc780d83294b4", "project_url": "https://github.com/jedisct1/pure-ftpd", "commit_url": "https://github.com/jedisct1/pure-ftpd/commit/37ad222868e52271905b94afea4fc780d83294b4", "commit_message": "Initialize the max upload file size when quotas are enabled\n\nDue to an unwanted check, files causing the quota to be exceeded\nwere deleted after the upload, but not during the upload.\n\nThe bug was introduced in 2009 in version 1.0.23\n\nSpotted by @DroidTest, thanks!", "target": 1, "func": "void dostor(char *name, const int append, const int autorename)\n{\n    ULHandler ulhandler;\n    int f;\n    const char *ul_name = NULL;\n    const char *atomic_file = NULL;\n    off_t filesize = (off_t) 0U;\n    struct stat st;\n    double started = 0.0;\n    signed char overwrite = 0;\n    int overflow = 0;\n    int ret = -1;\n    off_t max_filesize = (off_t) -1;\n#ifdef QUOTAS\n    Quota quota;\n#endif\n    const char *name2 = NULL;\n\n    if (type < 1 || (type == 1 && restartat > (off_t) 1)) {\n        addreply_noformat(503, MSG_NO_ASCII_RESUME);\n        goto end;\n    }\n#ifndef ANON_CAN_RESUME\n    if (guest != 0 && anon_noupload != 0) {\n        addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);\n        goto end;\n    }\n#endif\n    if (ul_check_free_space(name, -1.0) == 0) {\n        addreply_noformat(552, MSG_NO_DISK_SPACE);\n        goto end;\n    }\n    if (checknamesanity(name, dot_write_ok) != 0) {\n        addreply(553, MSG_SANITY_FILE_FAILURE, name);\n        goto end;\n    }\n    if (autorename != 0) {\n        no_truncate = 1;\n    }\n    if (restartat > (off_t) 0 || no_truncate != 0) {\n        if ((atomic_file = get_atomic_file(name)) == NULL) {\n            addreply(553, MSG_SANITY_FILE_FAILURE, name);\n            goto end;\n        }\n        if (restartat > (off_t) 0 &&\n            rename(name, atomic_file) != 0 && errno != ENOENT) {\n            error(553, MSG_RENAME_FAILURE);\n            atomic_file = NULL;\n            goto end;\n        }\n    }\n    if (atomic_file != NULL) {\n        ul_name = atomic_file;\n    } else {\n        ul_name = name;\n    }\n    if (atomic_file == NULL &&\n        (f = open(ul_name, O_WRONLY | O_NOFOLLOW)) != -1) {\n        overwrite++;\n    } else if ((f = open(ul_name, O_CREAT | O_WRONLY | O_NOFOLLOW,\n                         (mode_t) 0777 & ~u_mask)) == -1) {\n        error(553, MSG_OPEN_FAILURE2);\n        goto end;\n    }\n    if (fstat(f, &st) < 0) {\n        (void) close(f);\n        error(553, MSG_STAT_FAILURE2);\n        goto end;\n    }\n    if (!S_ISREG(st.st_mode)) {\n        (void) close(f);\n        addreply_noformat(550, MSG_NOT_REGULAR_FILE);\n        goto end;\n    }\n    alarm(MAX_SESSION_XFER_IDLE);\n\n    /* Anonymous users *CAN* overwrite 0-bytes files - This is the right behavior */\n    if (st.st_size > (off_t) 0) {\n#ifndef ANON_CAN_RESUME\n        if (guest != 0) {\n            addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);\n            (void) close(f);\n            goto end;\n        }\n#endif\n        if (append != 0) {\n            restartat = st.st_size;\n        }\n    } else {\n        restartat = (off_t) 0;\n    }\n    if (restartat > st.st_size) {\n        restartat = st.st_size;\n    }\n    if (restartat > (off_t) 0 && lseek(f, restartat, SEEK_SET) < (off_t) 0) {\n        (void) close(f);\n        error(451, \"seek\");\n        goto end;\n    }\n    if (restartat < st.st_size) {\n        if (ftruncate(f, restartat) < 0) {\n            (void) close(f);\n            error(451, \"ftruncate\");\n            goto end;\n        }\n#ifdef QUOTAS\n        if (restartat != st.st_size) {\n            (void) quota_update(NULL, 0LL,\n                                (long long) (restartat - st.st_size),\n                                &overflow);\n        }\n#endif\n    }\n#ifdef QUOTAS\n    if (quota_update(&quota, 0LL, 0LL, &overflow) == 0 &&\n        (overflow > 0 || quota.files >= user_quota_files ||\n         quota.size > user_quota_size ||\n         (max_filesize >= (off_t) 0 &&\n          (max_filesize = user_quota_size - quota.size) < (off_t) 0))) {\n        overflow = 1;\n        (void) close(f);\n        goto afterquota;\n    }\n#endif\n    opendata();\n    if (xferfd == -1) {\n        (void) close(f);\n        goto end;\n    }\n    doreply();\n# ifdef WITH_TLS\n    if (data_protection_level == CPL_PRIVATE) {\n        tls_init_data_session(xferfd, passive);\n    }\n# endif\n    state_needs_update = 1;\n    setprocessname(\"pure-ftpd (UPLOAD)\");\n    filesize = restartat;\n\n#ifdef FTPWHO\n    if (shm_data_cur != NULL) {\n        const size_t sl = strlen(name);\n\n        ftpwho_lock();\n        shm_data_cur->state = FTPWHO_STATE_UPLOAD;\n        shm_data_cur->download_total_size = (off_t) 0U;\n        shm_data_cur->download_current_size = (off_t) filesize;\n        shm_data_cur->restartat = restartat;\n        (void) time(&shm_data_cur->xfer_date);\n        if (sl < sizeof shm_data_cur->filename) {\n            memcpy(shm_data_cur->filename, name, sl);\n            shm_data_cur->filename[sl] = 0;\n        } else {\n            memcpy(shm_data_cur->filename,\n                   &name[sl - sizeof shm_data_cur->filename - 1U],\n                   sizeof shm_data_cur->filename);\n        }\n        ftpwho_unlock();\n    }\n#endif\n\n    /* Here starts the real upload code */\n\n    started = get_usec_time();\n\n    if (ul_init(&ulhandler, clientfd, tls_cnx, xferfd, name, f, tls_data_cnx,\n                restartat, type == 1, throttling_bandwidth_ul,\n                max_filesize) == 0) {\n        ret = ul_send(&ulhandler);\n        ul_exit(&ulhandler);\n    } else {\n        ret = -1;\n    }\n    (void) close(f);\n    closedata();\n\n    /* Here ends the real upload code */\n\n#ifdef SHOW_REAL_DISK_SPACE\n    if (FSTATFS(f, &statfsbuf) == 0) {\n        double space;\n\n        space = (double) STATFS_BAVAIL(statfsbuf) *\n            (double) STATFS_FRSIZE(statfsbuf);\n        if (space > 524288.0) {\n            addreply(0, MSG_SPACE_FREE_M, space / 1048576.0);\n        } else {\n            addreply(0, MSG_SPACE_FREE_K, space / 1024.0);\n        }\n    }\n#endif\n\n    uploaded += (unsigned long long) ulhandler.total_uploaded;\n    {\n        off_t atomic_file_size;\n        off_t original_file_size;\n        int files_count;\n\n        if (overwrite == 0) {\n            files_count = 1;\n        } else {\n            files_count = 0;\n        }\n        if (autorename != 0 && restartat == (off_t) 0) {\n            if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {\n                goto afterquota;\n            }\n            if (tryautorename(atomic_file, name, &name2) != 0) {\n                error(553, MSG_RENAME_FAILURE);\n                goto afterquota;\n            } else {\n#ifdef QUOTAS\n                ul_quota_update(name2 ? name2 : name, 1, atomic_file_size);\n#endif\n                atomic_file = NULL;\n            }\n        } else if (atomic_file != NULL) {\n            if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {\n                goto afterquota;\n            }\n            if ((original_file_size = get_file_size(name)) < (off_t) 0 ||\n                restartat > original_file_size) {\n                original_file_size = restartat;\n            }\n            if (rename(atomic_file, name) != 0) {\n                error(553, MSG_RENAME_FAILURE);\n                goto afterquota;\n            } else {\n#ifdef QUOTAS\n                overflow = ul_quota_update\n                    (name, files_count, atomic_file_size - original_file_size);\n#endif\n                atomic_file = NULL;\n            }\n        } else {\n#ifdef QUOTAS\n            overflow = ul_quota_update\n                (name, files_count, ulhandler.total_uploaded);\n#endif\n        }\n    }\n    afterquota:\n    if (overflow > 0) {\n        addreply(552, MSG_QUOTA_EXCEEDED, name);\n    } else {\n        if (ret == 0) {\n            addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL);\n        } else {\n            addreply_noformat(451, MSG_ABORTED);\n        }\n        displayrate(MSG_UPLOADED, ulhandler.total_uploaded, started,\n                    name2 ? name2 : name, 1);\n    }\n    end:\n    restartat = (off_t) 0;\n    if (atomic_file != NULL) {\n        unlink(atomic_file);\n        atomic_file = NULL;\n    }\n}", "func_hash": 206214968854253605299556693579818029977, "file_name": "ftpd.c", "file_hash": 235084351397611292950237183012549023004, "cwe": ["CWE-434"], "cve": "CVE-2021-40524", "cve_desc": "In Pure-FTPd before 1.0.50, an incorrect max_filesize quota mechanism in the server allows attackers to upload files of unbounded size, which may lead to denial of service or a server hang. This occurs because a certain greater-than-zero test does not anticipate an initial -1 value. (Versions 1.0.23 through 1.0.49 are affected.)", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40524"}
{"idx": 218933, "project": "tensorflow", "commit_id": "4f38b1ac8e42727e18a2f0bde06d3bee8e77b250", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/4f38b1ac8e42727e18a2f0bde06d3bee8e77b250", "commit_message": "Prevent null dereference read in `GetInitOp`.\n\nWe have a map of maps. We test that the key exists in the first map but then we don't have any validation that this also means the second map has the needed key. In the scenarios where this is not the case, we'll dereference a nullptr, if we don't have this check\n\nPiperOrigin-RevId: 408739325\nChange-Id: If9bb7ed759aba1f3b56a34913f209508dbaf65ce", "target": 0, "func": "Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,\n                 string* init_op_name) {\n  const auto& sig_def_map = meta_graph_def.signature_def();\n  const auto& init_op_sig_it =\n      meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);\n  if (init_op_sig_it != sig_def_map.end()) {\n    const auto& sig_def_outputs = init_op_sig_it->second.outputs();\n    const auto& sig_def_outputs_it =\n        sig_def_outputs.find(kSavedModelInitOpSignatureKey);\n    if (sig_def_outputs_it == sig_def_outputs.end()) {\n      return errors::FailedPrecondition(\"Could not find output \",\n                                        kSavedModelInitOpSignatureKey);\n    }\n    *init_op_name = sig_def_outputs_it->second.name();\n    return Status::OK();\n  }\n\n  const auto& collection_def_map = meta_graph_def.collection_def();\n  string init_op_collection_key;\n  if (collection_def_map.find(kSavedModelMainOpKey) !=\n      collection_def_map.end()) {\n    init_op_collection_key = kSavedModelMainOpKey;\n  } else {\n    init_op_collection_key = kSavedModelLegacyInitOpKey;\n  }\n\n  const auto init_op_it = collection_def_map.find(init_op_collection_key);\n  if (init_op_it != collection_def_map.end()) {\n    if (init_op_it->second.node_list().value_size() != 1) {\n      return errors::FailedPrecondition(\n          strings::StrCat(\"Expected exactly one main op in : \", export_dir));\n    }\n    *init_op_name = init_op_it->second.node_list().value(0);\n  }\n  return Status::OK();\n}", "func_hash": 120370294428908534368713689048437773064, "file_name": "loader_util.cc", "file_hash": 225205642200693417259460288987767726126, "cwe": ["CWE-476"], "cve": "CVE-2022-23577", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `GetInitOp` is vulnerable to a crash caused by dereferencing a null pointer. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23577"}
{"idx": 198399, "project": "uftpd", "commit_id": "0fb2c031ce0ace07cc19cd2cb2143c4b5a63c9dd", "project_url": "https://github.com/troglobit/uftpd", "commit_url": "https://github.com/troglobit/uftpd/commit/0fb2c031ce0ace07cc19cd2cb2143c4b5a63c9dd", "commit_message": "FTP: Fix buffer overflow in PORT parser, reported by Aaron Esau\n\nSigned-off-by: Joachim Nilsson <troglobit@gmail.com>", "target": 1, "func": "static void handle_PORT(ctrl_t *ctrl, char *str)\n{\n\tint a, b, c, d, e, f;\n\tchar addr[INET_ADDRSTRLEN];\n\tstruct sockaddr_in sin;\n\n\tif (ctrl->data_sd > 0) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t}\n\n\t/* Convert PORT command's argument to IP address + port */\n\tsscanf(str, \"%d,%d,%d,%d,%d,%d\", &a, &b, &c, &d, &e, &f);\n\tsprintf(addr, \"%d.%d.%d.%d\", a, b, c, d);\n\n\t/* Check IPv4 address using inet_aton(), throw away converted result */\n\tif (!inet_aton(addr, &(sin.sin_addr))) {\n\t\tERR(0, \"Invalid address '%s' given to PORT command\", addr);\n\t\tsend_msg(ctrl->sd, \"500 Illegal PORT command.\\r\\n\");\n\t\treturn;\n\t}\n\n\tstrlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));\n\tctrl->data_port = e * 256 + f;\n\n\tDBG(\"Client PORT command accepted for %s:%d\", ctrl->data_address, ctrl->data_port);\n\tsend_msg(ctrl->sd, \"200 PORT command successful.\\r\\n\");\n}", "func_hash": 5389607465091397932741652441661168107, "file_name": "ftpcmd.c", "file_hash": 13134413350440209021234166619599968419, "cwe": ["CWE-787"], "cve": "CVE-2020-20276", "cve_desc": "An unauthenticated stack-based buffer overflow vulnerability in common.c's handle_PORT in uftpd FTP server versions 2.10 and earlier can be abused to cause a crash and could potentially lead to remote code execution.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-20276"}
{"idx": 216949, "project": "server", "commit_id": "5ba77222e9fe7af8ff403816b5338b18b342053c", "project_url": "https://github.com/MariaDB/server", "commit_url": "https://github.com/MariaDB/server/commit/5ba77222e9fe7af8ff403816b5338b18b342053c", "commit_message": "MDEV-21028 Server crashes in Query_arena::set_query_arena upon SELECT from view\n\nif the view has algorithm=temptable it is not updatable,\nso DEFAULT() for its fields is meaningless,\nand thus it's NULL or 0/'' for NOT NULL columns.", "target": 1, "func": "Field *create_tmp_field_from_field(THD *thd, Field *org_field,\n                                   const char *name, TABLE *table,\n                                   Item_field *item)\n{\n  Field *new_field;\n\n  new_field= org_field->make_new_field(thd->mem_root, table,\n                                       table == org_field->table);\n  if (new_field)\n  {\n    new_field->init(table);\n    new_field->orig_table= org_field->orig_table;\n    if (item)\n      item->result_field= new_field;\n    else\n      new_field->field_name= name;\n    new_field->flags|= (org_field->flags & NO_DEFAULT_VALUE_FLAG);\n    if (org_field->maybe_null() || (item && item->maybe_null))\n      new_field->flags&= ~NOT_NULL_FLAG;\t// Because of outer join\n    if (org_field->type() == MYSQL_TYPE_VAR_STRING ||\n        org_field->type() == MYSQL_TYPE_VARCHAR)\n      table->s->db_create_options|= HA_OPTION_PACK_RECORD;\n    else if (org_field->type() == FIELD_TYPE_DOUBLE)\n      ((Field_double *) new_field)->not_fixed= TRUE;\n    new_field->vcol_info= 0;\n    new_field->cond_selectivity= 1.0;\n    new_field->next_equal_field= NULL;\n    new_field->option_list= NULL;\n    new_field->option_struct= NULL;\n  }\n  return new_field;\n}", "func_hash": 75060030531434597775371308590962756715, "file_name": "None", "file_hash": null, "cwe": ["CWE-89"], "cve": "CVE-2022-27386", "cve_desc": "MariaDB Server v10.7 and below was discovered to contain a segmentation fault via the component sql/sql_class.cc.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-27386"}
{"idx": 198439, "project": "mruby", "commit_id": "3cf291f72224715942beaf8553e42ba8891ab3c6", "project_url": "https://github.com/mruby/mruby", "commit_url": "https://github.com/mruby/mruby/commit/3cf291f72224715942beaf8553e42ba8891ab3c6", "commit_message": "vm.c: create break object before clearing GC arena.\n\nOtherwise it possibly cause use-after-free.", "target": 1, "func": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n        goto L_INT_OVERFLOW;\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        va = mrb_hash_get(mrb, va, vb);\n        regs[a] = va;\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          regs[a] = va;\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict, v;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      v = mrb_hash_get(mrb, kdict, k);\n      regs[a] = v;\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      mrb_int len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_ensure_hash_type(mrb, hash);\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}", "func_hash": 109885974444796302561569813029771831944, "file_name": "vm.c", "file_hash": 83886473477345826235413068203214397377, "cwe": ["CWE-288"], "cve": "CVE-2022-1212", "cve_desc": "Use-After-Free in str_escape in mruby/mruby in GitHub repository mruby/mruby prior to 3.2. Possible arbitrary code execution if being exploited.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1212"}
{"idx": 195629, "project": "tensorflow", "commit_id": "a5b89cd68c02329d793356bda85d079e9e69b4e7", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/a5b89cd68c02329d793356bda85d079e9e69b4e7", "commit_message": "Fix empty resource handle vulnerability.\n\nSome ops that attempt to extract a resource handle from user input\ncan lead to nullptr dereferences.  This returns an error in such\na case.\n\nPiperOrigin-RevId: 445571938", "target": 1, "func": "Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,\n                         TensorHandle* tensor_handle, Device** result) {\n  Device* cpu_device = ctx.HostCPU();\n  string device_name;\n  if (tensor_handle->Type() != TensorHandle::LOCAL) {\n    Device* device = tensor_handle->device();\n    device_name = device != nullptr ? device->name() : cpu_device->name();\n    *result = (device == nullptr ? cpu_device : device);\n  } else if (tensor_handle->dtype == DT_RESOURCE) {\n    // Use the resource's actual device because it is the device that will\n    // influence partitioning the multi-device function.\n    const Tensor* tensor;\n    // TODO(fishx): Avoid blocking here.\n    TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));\n    const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);\n    device_name = handle.device();\n\n    Device* input_device;\n    TF_RETURN_IF_ERROR(\n        ctx.FindDeviceFromName(device_name.c_str(), &input_device));\n    *result = input_device;\n  } else {\n    Device* device = tensor_handle->device();\n    const bool is_tpu = device != nullptr && device->device_type() == \"TPU\";\n    // int32 return values can be placed on TPUs.\n    const bool use_host_memory =\n        is_tpu ? MTypeFromDTypeIntsOnDevice(tensor_handle->dtype)\n               : MTypeFromDType(tensor_handle->dtype);\n    if (use_host_memory) {\n      *result = cpu_device;\n    } else {\n      // Eager ops executing as functions should have their preferred inputs set\n      // to the op's device. This allows us to avoid expensive D2H copies if a\n      // mirror of the tensor already exists on the op's device.\n      if (!op.is_function() && device != nullptr && device != cpu_device) {\n        device = absl::get<Device*>(op.Device());\n      }\n      *result = (device == nullptr ? cpu_device : device);\n    }\n  }\n  return Status::OK();\n}", "func_hash": 227007805370541421392187811352073944672, "file_name": "execute.cc", "file_hash": 250138698264718373642663717664797527317, "cwe": ["CWE-476"], "cve": "CVE-2022-29207", "cve_desc": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, multiple TensorFlow operations misbehave in eager mode when the resource handle provided to them is invalid. In graph mode, it would have been impossible to perform these API calls, but migration to TF 2.x eager mode opened up this vulnerability. If the resource handle is empty, then a reference is bound to a null pointer inside TensorFlow codebase (various codepaths). This is undefined behavior. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-29207"}
{"idx": 175771, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  AvailableSpaceQueryTask(\n      QuotaManager* manager,\n      scoped_refptr<base::MessageLoopProxy> db_message_loop,\n      const FilePath& profile_path,\n      AvailableSpaceCallback* callback)\n      : QuotaThreadTask(manager, db_message_loop),\n        profile_path_(profile_path),\n        space_(-1),\n        callback_(callback) {}\n", "func_hash": 211985763294167133268443076395574361343, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 206044, "project": "tigervnc", "commit_id": "d61a767d6842b530ffb532ddd5a3d233119aad40", "project_url": "https://github.com/CendioOssman/tigervnc", "commit_url": "https://github.com/CendioOssman/tigervnc/commit/d61a767d6842b530ffb532ddd5a3d233119aad40", "commit_message": "Make ZlibInStream more robust against failures\n\nMove the checks around to avoid missing cases where we might access\nmemory that is no longer valid. Also avoid touching the underlying\nstream implicitly (e.g. via the destructor) as it might also no\nlonger be valid.\n\nA malicious server could theoretically use this for remote code\nexecution in the client.\n\nIssue found by Pavel Cheremushkin from Kaspersky Lab", "target": 1, "func": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n\n      if (!rle) {\n        if (palSize == 0) {\n\n          // raw\n\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n\n        } else {\n\n          // packed pixels\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n\n          PIXEL_T* ptr = buf;\n\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n\n      } else {\n\n        if (palSize == 0) {\n\n          // plain RLE\n\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n\n            while (len-- > 0) *ptr++ = pix;\n\n          }\n        } else {\n\n          // palette RLE\n\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n\n            index &= 127;\n\n            PIXEL_T pix = palette[index];\n\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n\n      pb->imageRect(pf, t, buf);\n    }\n  }\n\n  zis->removeUnderlying();\n}", "func_hash": 266797184622822909427515310440359797331, "file_name": "None", "file_hash": null, "cwe": ["CWE-672"], "cve": "CVE-2019-15691", "cve_desc": "TigerVNC version prior to 1.10.1 is vulnerable to stack use-after-return, which occurs due to incorrect usage of stack memory in ZRLEDecoder. If decoding routine would throw an exception, ZRLEDecoder may try to access stack variable, which has been already freed during the process of stack unwinding. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-15691"}
{"idx": 90812, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  UpdatePersistentHostQuotaTask(\n      QuotaManager* manager,\n      const std::string& host,\n      int new_quota,\n      HostQuotaCallback* callback)\n      : DatabaseTaskBase(manager),\n        host_(host),\n        new_quota_(new_quota),\n        callback_(callback) {\n    DCHECK_GE(new_quota_, 0);\n  }\n", "func_hash": 270152698943883113190472169202665752851, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 221656, "project": "e2guardian", "commit_id": "eae46a7e2a57103aadca903c4a24cca94dc502a2", "project_url": "https://github.com/e2guardian/e2guardian", "commit_url": "https://github.com/e2guardian/e2guardian/commit/eae46a7e2a57103aadca903c4a24cca94dc502a2", "commit_message": "Fix bug #707 cert hostnames not being checked\n- only happened when openssl v1.1 is used", "target": 0, "func": "int Socket::readFromSocket(char *buff, int len, unsigned int flags, int timeout, bool check_first, bool honour_reloadconfig)\n{\n    if (len == 0)  // nothing to read\n         return 0;\n    if (!isssl) {\n        return BaseSocket::readFromSocket(buff, len, flags, timeout, check_first, honour_reloadconfig);\n    }\n\n    // first, return what's left from the previous buffer read, if anything\n    int cnt = len;\n    int tocopy = 0;\n    if ((bufflen - buffstart) > 0) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Socket::readFromSocket: data already in buffer; bufflen: \" << bufflen << \" buffstart: \" << buffstart << std::endl;\n#endif\n        tocopy = len;\n        if ((bufflen - buffstart) < len)\n            tocopy = bufflen - buffstart;\n        memcpy(buff, buffer + buffstart, tocopy);\n        cnt -= tocopy;\n        buffstart += tocopy;\n        buff += tocopy;\n        if (cnt == 0)\n            return len;\n    }\n\n    int rc;\n    while (cnt > 0) {\n    //if (check_first) {\n          //if(!bcheckSForInput(timeout))\n            //return -1;\n   //}\n//    while (true)\n        bool inbuffer;\n        ERR_clear_error();\n        if(true) {   //   was if (cnt > 4095)\n            inbuffer = false;\n           rc = SSL_read(ssl, buff, cnt);        //  data larger than SSL buffer so ok to read directly into output buffer\n        } else {\n            inbuffer = true;\n           rc = SSL_read(ssl, buffer, 4096);   // read into socket buffer to flush SSL buffer\n        }\n\n        if (rc < 0) {\n            s_errno = errno;\n            log_ssl_errors(\"ssl_read failed %s\", \"\");\n#ifdef NETDEBUG\n        std::cout << thread_id << \"ssl_read failed\" << s_errno << \" failed to read \" << cnt << \" bytes\" << std::endl;\n#endif\n            rc = 0;\n        }\n        if (rc == 0) { // eof\n             ishup = true;\n             return len - cnt;\n             }\n\n        if (inbuffer) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Inbuffer SSL read to return \" << cnt << \" bytes\" << std::endl;\n#endif\n\n           buffstart = 0;\n           bufflen = rc;\n           if ((bufflen - buffstart) > 0) {\n              tocopy = cnt;\n              if ((bufflen - buffstart) < cnt)\n              tocopy = bufflen - buffstart;\n              memcpy(buff, buffer + buffstart, tocopy);\n              cnt -= tocopy;\n              buffstart += tocopy;\n              buff += tocopy;\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Inbuffer SSL read to returned \" << tocopy << \" bytes\" << std::endl;\n#endif\n           }\n         } else {\n        buff += rc;\n        cnt -= rc;\n         }\n //       break;\n    }\n\n//    return rc + tocopy;\n      return len;\n}", "func_hash": 259234802154304495171974730001616246519, "file_name": "Socket.cpp", "file_hash": 316707147744091371767800459911917453562, "cwe": ["CWE-295"], "cve": "CVE-2021-44273", "cve_desc": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-44273"}
{"idx": 219011, "project": "tensorflow", "commit_id": "240655511cd3e701155f944a972db71b6c0b1bb6", "project_url": "https://github.com/tensorflow/tensorflow", "commit_url": "https://github.com/tensorflow/tensorflow/commit/240655511cd3e701155f944a972db71b6c0b1bb6", "commit_message": "Eliminate `CHECK`-fails from `IsSimplifiableReshape` via `MakeShape(<invalid shape>)`\n\nPiperOrigin-RevId: 409166738\nChange-Id: I7f0a3590b8acae3f3e3e2fe636e1f5ef285693cf", "target": 0, "func": "bool ConstantFolding::OptimizedNodeExists(const NodeDef& node,\n                                          StringPiece suffix) const {\n  return node_map_->NodeExists(OptimizedNodeName(node, suffix));\n}", "func_hash": 249744825853356507235684089450052141250, "file_name": "constant_folding.cc", "file_hash": 221573695858123615640237954647315751120, "cwe": ["CWE-617"], "cve": "CVE-2022-23581", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The Grappler optimizer in TensorFlow can be used to cause a denial of service by altering a `SavedModel` such that `IsSimplifiableReshape` would trigger `CHECK` failures. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-23581"}
{"idx": 221676, "project": "e2guardian", "commit_id": "eae46a7e2a57103aadca903c4a24cca94dc502a2", "project_url": "https://github.com/e2guardian/e2guardian", "commit_url": "https://github.com/e2guardian/e2guardian/commit/eae46a7e2a57103aadca903c4a24cca94dc502a2", "commit_message": "Fix bug #707 cert hostnames not being checked\n- only happened when openssl v1.1 is used", "target": 0, "func": "void Socket::close()\n{\n    if (isssl) {\n        stopSsl();\n    }\n    BaseSocket::close();\n}", "func_hash": 159904369968594743091011695118972248491, "file_name": "Socket.cpp", "file_hash": 316707147744091371767800459911917453562, "cwe": ["CWE-295"], "cve": "CVE-2021-44273", "cve_desc": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-44273"}
{"idx": 90235, "project": "Chrome", "commit_id": "a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a3e2afaedd8190398ae45ccef34fcdee00fb19aa", "commit_message": "None", "target": 0, "func": "  ~NetworkLibraryStubImpl() { if (ethernet_) delete ethernet_; }\n", "func_hash": 250987366564575109273869948743187776891, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 201913, "project": "libarchive", "commit_id": "e2ad1a2c3064fa9eba6274b3641c4c1beed25c0b", "project_url": "https://github.com/libarchive/libarchive", "commit_url": "https://github.com/libarchive/libarchive/commit/e2ad1a2c3064fa9eba6274b3641c4c1beed25c0b", "commit_message": "Never follow symlinks when setting file flags on Linux\n\nWhen opening a file descriptor to set file flags on linux, ensure\nno symbolic links are followed. This fixes the case when an archive\ncontains a directory entry followed by a symlink entry with the same\npath. The fixup code would modify file flags of the symlink target.", "target": 1, "func": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\t/*\n\t * Linux has no define for the flags that are only settable by\n\t * the root user.  This code may seem a little complex, but\n\t * there seem to be some Linux systems that lack these\n\t * defines. (?)  The code below degrades reasonably gracefully\n\t * if sf_mask is incomplete.\n\t */\n\tconst int sf_mask = 0\n#if defined(FS_IMMUTABLE_FL)\n\t    | FS_IMMUTABLE_FL\n#elif defined(EXT2_IMMUTABLE_FL)\n\t    | EXT2_IMMUTABLE_FL\n#endif\n#if defined(FS_APPEND_FL)\n\t    | FS_APPEND_FL\n#elif defined(EXT2_APPEND_FL)\n\t    | EXT2_APPEND_FL\n#endif\n#if defined(FS_JOURNAL_DATA_FL)\n\t    | FS_JOURNAL_DATA_FL\n#endif\n\t;\n\n\tif (set == 0 && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\t/* Only regular files and dirs can have flags. */\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\n\t/* If we weren't given an fd, open it ourselves. */\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\n\t/*\n\t * XXX As above, this would be way simpler if we didn't have\n\t * to read the current flags from disk. XXX\n\t */\n\tret = ARCHIVE_OK;\n\n\t/* Read the current file flags. */\n\tif (ioctl(myfd,\n#ifdef FS_IOC_GETFLAGS\n\t    FS_IOC_GETFLAGS,\n#else\n\t    EXT2_IOC_GETFLAGS,\n#endif\n\t    &oldflags) < 0)\n\t\tgoto fail;\n\n\t/* Try setting the flags as given. */\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\n\t/* If we couldn't set all the flags, try again with a subset. */\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\n\n\t/* We couldn't set the flags, so report the failure. */\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}", "func_hash": 23055553245958282946404395843765567799, "file_name": "None", "file_hash": null, "cwe": ["CWE-59"], "cve": "CVE-2021-31566", "cve_desc": "An improper link resolution flaw can occur while extracting an archive leading to changing modes, times, access control lists, and flags of a file outside of the archive. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to gain more privileges in a system.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-31566"}
{"idx": 221467, "project": "flatpak", "commit_id": "89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "project_url": "https://github.com/flatpak/flatpak", "commit_url": "https://github.com/flatpak/flatpak/commit/89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "commit_message": "run: Add cross-references for some other seccomp syscall filters\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "target": 0, "func": "add_document_portal_args (FlatpakBwrap *bwrap,\n                          const char   *app_id,\n                          char        **out_mount_path)\n{\n  g_autoptr(GDBusConnection) session_bus = NULL;\n  g_autofree char *doc_mount_path = NULL;\n\n  session_bus = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  if (session_bus)\n    {\n      g_autoptr(GError) local_error = NULL;\n      g_autoptr(GDBusMessage) reply = NULL;\n      g_autoptr(GDBusMessage) msg =\n        g_dbus_message_new_method_call (\"org.freedesktop.portal.Documents\",\n                                        \"/org/freedesktop/portal/documents\",\n                                        \"org.freedesktop.portal.Documents\",\n                                        \"GetMountPoint\");\n      g_dbus_message_set_body (msg, g_variant_new (\"()\"));\n      reply =\n        g_dbus_connection_send_message_with_reply_sync (session_bus, msg,\n                                                        G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                        30000,\n                                                        NULL,\n                                                        NULL,\n                                                        NULL);\n      if (reply)\n        {\n          if (g_dbus_message_to_gerror (reply, &local_error))\n            {\n              if (g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN))\n                g_debug (\"Document portal not available, not mounting /run/flatpak/doc\");\n              else\n                g_message (\"Can't get document portal: %s\", local_error->message);\n            }\n          else\n            {\n              static const char dst_path[] = \"/run/flatpak/doc\";\n              g_autofree char *src_path = NULL;\n              g_variant_get (g_dbus_message_get_body (reply),\n                             \"(^ay)\", &doc_mount_path);\n\n              src_path = g_strdup_printf (\"%s/by-app/%s\",\n                                          doc_mount_path, app_id);\n              flatpak_bwrap_add_args (bwrap, \"--bind\", src_path, dst_path, NULL);\n              flatpak_bwrap_add_runtime_dir_member (bwrap, \"doc\");\n            }\n        }\n    }\n\n  *out_mount_path = g_steal_pointer (&doc_mount_path);\n}", "func_hash": 282946161110542946532166377072770414526, "file_name": "flatpak-run.c", "file_hash": 32398709380082441128978861691951488575, "cwe": ["CWE-20"], "cve": "CVE-2021-41133", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-41133"}
{"idx": 90809, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "void QuotaManager::StartEviction() {\n  DCHECK(!temporary_storage_evictor_.get());\n  temporary_storage_evictor_.reset(new QuotaTemporaryStorageEvictor(this,\n      kEvictionIntervalInMilliSeconds));\n  temporary_storage_evictor_->Start();\n}\n", "func_hash": 307577243601854639342283289386358217455, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 90839, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  void DidDumpQuotaTable(const QuotaTableEntries& entries) {\n    quota_entries_ = entries;\n  }\n", "func_hash": 219969577054585516743561590926308385178, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 218826, "project": "ImageMagick6", "commit_id": "450949ed017f009b399c937cf362f0058eacc5fa", "project_url": "https://github.com/ImageMagick/ImageMagick6", "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "commit_message": "Pull request: https://github.com/ImageMagick/ImageMagick/pull/4963", "target": 0, "func": "static void XSetMatteColor(Display *display,const XWindowInfo *window_info,\n  const MagickStatusType raised)\n{\n  if (window_info->depth == 1)\n    {\n      /*\n        Monochrome window.\n      */\n      if (raised)\n        (void) XSetForeground(display,window_info->widget_context,\n          XWhitePixel(display,window_info->screen));\n      else\n        (void) XSetForeground(display,window_info->widget_context,\n          XBlackPixel(display,window_info->screen));\n    }\n  else\n    if (raised)\n      (void) XSetForeground(display,window_info->widget_context,\n        window_info->pixel_info->matte_color.pixel);\n    else\n      (void) XSetForeground(display,window_info->widget_context,\n        window_info->pixel_info->depth_color.pixel);\n}", "func_hash": 32137050615397731234685756673547579668, "file_name": "widget.c", "file_hash": 31318598747823313517201273606802259325, "cwe": ["CWE-190"], "cve": "CVE-2022-32545", "cve_desc": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-32545"}
{"idx": 139220, "project": "Chrome", "commit_id": "fb83de09f2c986ee91741f3a2776feea0e18e3f6", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/fb83de09f2c986ee91741f3a2776feea0e18e3f6", "commit_message": "None", "target": 0, "func": "gfx::Rect OverlayWindowViews::GetFirstCustomControlsBounds() {\n  if (!first_custom_controls_view_)\n    return gfx::Rect();\n  return first_custom_controls_view_->GetMirroredBounds();\n}\n", "func_hash": 301120450789669239444216016296921335123, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
{"idx": 216861, "project": "openssl", "commit_id": "94d23fcff9b2a7a8368dfe52214d5c2569882c11", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://github.com/openssl/openssl/commit/94d23fcff9b2a7a8368dfe52214d5c2569882c11", "commit_message": "Fix EC_GROUP_new_from_ecparameters to check the base length\n\nCheck that there's at least one byte in params->base before trying to\nread it.\n\nCVE-2021-3712\n\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>", "target": 1, "func": "EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)\n{\n    int ok = 0, tmp;\n    EC_GROUP *ret = NULL, *dup = NULL;\n    BIGNUM *p = NULL, *a = NULL, *b = NULL;\n    EC_POINT *point = NULL;\n    long field_bits;\n    int curve_name = NID_undef;\n    BN_CTX *ctx = NULL;\n\n    if (!params->fieldID || !params->fieldID->fieldType ||\n        !params->fieldID->p.ptr) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n\n    /*\n     * Now extract the curve parameters a and b. Note that, although SEC 1\n     * specifies the length of their encodings, historical versions of OpenSSL\n     * encoded them incorrectly, so we must accept any length for backwards\n     * compatibility.\n     */\n    if (!params->curve || !params->curve->a ||\n        !params->curve->a->data || !params->curve->b ||\n        !params->curve->b->data) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n    a = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);\n    if (a == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n    b = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);\n    if (b == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* get the field parameters */\n    tmp = OBJ_obj2nid(params->fieldID->fieldType);\n    if (tmp == NID_X9_62_characteristic_two_field)\n#ifdef OPENSSL_NO_EC2M\n    {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);\n        goto err;\n    }\n#else\n    {\n        X9_62_CHARACTERISTIC_TWO *char_two;\n\n        char_two = params->fieldID->p.char_two;\n\n        field_bits = char_two->m;\n        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n            goto err;\n        }\n\n        if ((p = BN_new()) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /* get the base type */\n        tmp = OBJ_obj2nid(char_two->type);\n\n        if (tmp == NID_X9_62_tpBasis) {\n            long tmp_long;\n\n            if (!char_two->p.tpBasis) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                goto err;\n            }\n\n            tmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);\n\n            if (!(char_two->m > tmp_long && tmp_long > 0)) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                      EC_R_INVALID_TRINOMIAL_BASIS);\n                goto err;\n            }\n\n            /* create the polynomial */\n            if (!BN_set_bit(p, (int)char_two->m))\n                goto err;\n            if (!BN_set_bit(p, (int)tmp_long))\n                goto err;\n            if (!BN_set_bit(p, 0))\n                goto err;\n        } else if (tmp == NID_X9_62_ppBasis) {\n            X9_62_PENTANOMIAL *penta;\n\n            penta = char_two->p.ppBasis;\n            if (!penta) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                goto err;\n            }\n\n            if (!\n                (char_two->m > penta->k3 && penta->k3 > penta->k2\n                 && penta->k2 > penta->k1 && penta->k1 > 0)) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                      EC_R_INVALID_PENTANOMIAL_BASIS);\n                goto err;\n            }\n\n            /* create the polynomial */\n            if (!BN_set_bit(p, (int)char_two->m))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k1))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k2))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k3))\n                goto err;\n            if (!BN_set_bit(p, 0))\n                goto err;\n        } else if (tmp == NID_X9_62_onBasis) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);\n            goto err;\n        } else {                /* error */\n\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n            goto err;\n        }\n\n        /* create the EC_GROUP structure */\n        ret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);\n    }\n#endif\n    else if (tmp == NID_X9_62_prime_field) {\n        /* we have a curve over a prime field */\n        /* extract the prime number */\n        if (!params->fieldID->p.prime) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n            goto err;\n        }\n        p = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);\n        if (p == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n            goto err;\n        }\n\n        if (BN_is_negative(p) || BN_is_zero(p)) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n            goto err;\n        }\n\n        field_bits = BN_num_bits(p);\n        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n            goto err;\n        }\n\n        /* create the EC_GROUP structure */\n        ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);\n    } else {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n        goto err;\n    }\n\n    if (ret == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /* extract seed (optional) */\n    if (params->curve->seed != NULL) {\n        OPENSSL_free(ret->seed);\n        if ((ret->seed = OPENSSL_malloc(params->curve->seed->length)) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        memcpy(ret->seed, params->curve->seed->data,\n               params->curve->seed->length);\n        ret->seed_len = params->curve->seed->length;\n    }\n\n    if (!params->order || !params->base || !params->base->data) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n\n    if ((point = EC_POINT_new(ret)) == NULL)\n        goto err;\n\n    /* set the point conversion form */\n    EC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)\n                                       (params->base->data[0] & ~0x01));\n\n    /* extract the ec point */\n    if (!EC_POINT_oct2point(ret, point, params->base->data,\n                            params->base->length, NULL)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /* extract the order */\n    if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    if (BN_is_negative(a) || BN_is_zero(a)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n    if (BN_num_bits(a) > (int)field_bits + 1) { /* Hasse bound */\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n\n    /* extract the cofactor (optional) */\n    if (params->cofactor == NULL) {\n        BN_free(b);\n        b = NULL;\n    } else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    /* set the generator, order and cofactor (if present) */\n    if (!EC_GROUP_set_generator(ret, point, a, b)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /*\n     * Check if the explicit parameters group just created matches one of the\n     * built-in curves.\n     *\n     * We create a copy of the group just built, so that we can remove optional\n     * fields for the lookup: we do this to avoid the possibility that one of\n     * the optional parameters is used to force the library into using a less\n     * performant and less secure EC_METHOD instead of the specialized one.\n     * In any case, `seed` is not really used in any computation, while a\n     * cofactor different from the one in the built-in table is just\n     * mathematically wrong anyway and should not be used.\n     */\n    if ((ctx = BN_CTX_new()) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n    if ((dup = EC_GROUP_dup(ret)) == NULL\n            || EC_GROUP_set_seed(dup, NULL, 0) != 1\n            || !EC_GROUP_set_generator(dup, point, a, NULL)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n    if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {\n        /*\n         * The input explicit parameters successfully matched one of the\n         * built-in curves: often for built-in curves we have specialized\n         * methods with better performance and hardening.\n         *\n         * In this case we replace the `EC_GROUP` created through explicit\n         * parameters with one created from a named group.\n         */\n        EC_GROUP *named_group = NULL;\n\n#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n        /*\n         * NID_wap_wsg_idm_ecid_wtls12 and NID_secp224r1 are both aliases for\n         * the same curve, we prefer the SECP nid when matching explicit\n         * parameters as that is associated with a specialized EC_METHOD.\n         */\n        if (curve_name == NID_wap_wsg_idm_ecid_wtls12)\n            curve_name = NID_secp224r1;\n#endif /* !def(OPENSSL_NO_EC_NISTP_64_GCC_128) */\n\n        if ((named_group = EC_GROUP_new_by_curve_name(curve_name)) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n            goto err;\n        }\n        EC_GROUP_free(ret);\n        ret = named_group;\n\n        /*\n         * Set the flag so that EC_GROUPs created from explicit parameters are\n         * serialized using explicit parameters by default.\n         */\n        EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);\n\n        /*\n         * If the input params do not contain the optional seed field we make\n         * sure it is not added to the returned group.\n         *\n         * The seed field is not really used inside libcrypto anyway, and\n         * adding it to parsed explicit parameter keys would alter their DER\n         * encoding output (because of the extra field) which could impact\n         * applications fingerprinting keys by their DER encoding.\n         */\n        if (params->curve->seed == NULL) {\n            if (EC_GROUP_set_seed(ret, NULL, 0) != 1)\n                goto err;\n        }\n    }\n\n    ok = 1;\n\n err:\n    if (!ok) {\n        EC_GROUP_free(ret);\n        ret = NULL;\n    }\n    EC_GROUP_free(dup);\n\n    BN_free(p);\n    BN_free(a);\n    BN_free(b);\n    EC_POINT_free(point);\n\n    BN_CTX_free(ctx);\n\n    return ret;\n}", "func_hash": 80540639516178112864890741931948685257, "file_name": "None", "file_hash": null, "cwe": ["CWE-125"], "cve": "CVE-2021-3712", "cve_desc": "ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING structure which contains a buffer holding the string data and a field holding the buffer length. This contrasts with normal C strings which are repesented as a buffer for the string data which is terminated with a NUL (0) byte. Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL's own \"d2i\" functions (and other similar parsing functions) as well as any string whose value has been set with the ASN1_STRING_set() function will additionally NUL terminate the byte array in the ASN1_STRING structure. However, it is possible for applications to directly construct valid ASN1_STRING structures which do not NUL terminate the byte array by directly setting the \"data\" and \"length\" fields in the ASN1_STRING array. This can also happen by using the ASN1_STRING_set0() function. Numerous OpenSSL functions that print ASN.1 data have been found to assume that the ASN1_STRING byte array will be NUL terminated, even though this is not guaranteed for strings that have been directly constructed. Where an application requests an ASN.1 structure to be printed, and where that ASN.1 structure contains ASN1_STRINGs that have been directly constructed by the application without NUL terminating the \"data\" field, then a read buffer overrun can occur. The same thing can also occur during name constraints processing of certificates (for example if a certificate has been directly constructed by the application instead of loading it via the OpenSSL parsing functions, and the certificate contains non NUL terminated ASN1_STRING structures). It can also occur in the X509_get1_email(), X509_REQ_get1_email() and X509_get1_ocsp() functions. If a malicious actor can cause an application to directly construct an ASN1_STRING and then process it through one of the affected OpenSSL functions then this issue could be hit. This might result in a crash (causing a Denial of Service attack). It could also result in the disclosure of private memory contents (such as private keys, or sensitive plaintext). Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k). Fixed in OpenSSL 1.0.2za (Affected 1.0.2-1.0.2y).", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3712"}
{"idx": 90868, "project": "Chrome", "commit_id": "610f904d8215075c4681be4eb413f4348860bf9f", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/610f904d8215075c4681be4eb413f4348860bf9f", "commit_message": "None", "target": 0, "func": "  void SetPersistentHostQuota(const std::string& host, int64 new_quota) {\n    quota_status_ = kQuotaStatusUnknown;\n    host_.clear();\n    type_ = kStorageTypeUnknown;\n    quota_ = -1;\n    quota_manager_->SetPersistentHostQuota(host, new_quota,\n        callback_factory_.NewCallback(\n            &QuotaManagerTest::DidGetHostQuota));\n  }\n", "func_hash": 88562105476777681432253865808780772284, "file_name": "None", "file_hash": null, "cwe": [], "cve": "None", "cve_desc": "None", "nvd_url": "https://nvd.nist.gov/vuln/detail/None"}
