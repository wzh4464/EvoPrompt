###
# File: ./run_vulnerability_detection.py
# Created Date: Friday, July 18th 2025
# Author: Zihan
# -----
# Last Modified: Friday, 18th July 2025 9:47:38 am
# Modified By: the developer formerly known as Zihan at <wzh4464@gmail.com>
# -----
# HISTORY:
# Date      		By   	Comments
# ----------		------	---------------------------------------------------------
###

# run_vulnerability_detection.py
# 专门用于漏洞检测任务的EvoPrompt运行器

import json
import os
import sys
import argparse
from typing import List, Dict, Any
import numpy as np
from tqdm import tqdm

# 添加EvoPrompt路径
sys.path.append("./")

from args import parse_args
from utils import set_seed, load_cls_data, setup_log, cal_mean_std
# from llm_client import llm_init, llm_query  # 原来的LLM客户端
from sven_llm_client import sven_llm_init, sven_llm_query  # 使用SVEN的LLM客户端
from evolution import de_evo, ga_evo
# 不再继承原来的Evaluator，创建独立的评估器

class VulnerabilityDetectionEvaluator:
    """
    专门用于漏洞检测任务的评估器，独立实现不依赖原有基类
    """
    
    def __init__(self, args):
        self.args = args
        self.verbalizers = ["benign", "vulnerable"]
        self.task_type = "vulnerability_detection"
        
        # 初始化SVEN风格的LLM客户端
        self.client = sven_llm_init()
        # 为了兼容性，设置空的llm_config
        self.llm_config = {}
        
        # 设置路径和日志
        self.public_out_path = args.output
        os.makedirs(self.public_out_path, exist_ok=True)
        log_file = os.path.join(self.public_out_path, "vulnerability_detection.log")
        self.logger = setup_log(log_file)
        
        # 设置模型相关属性（SVEN使用API，不需要本地模型）
        self.tokenizer = None
        self.model = None
        
        # 设置指令占位符（用于兼容原框架）
        self.instruction_placeholder = "{instruction}"
        
        # 设置数据路径
        self.setup_data_paths(args)
        
        # 加载数据
        self.load_vulnerability_data(args)
        
        self.logger.info(f"Loaded {len(self.dev_src)} dev samples")
        self.logger.info(f"Loaded {len(self.test_src)} test samples")
    
    def setup_data_paths(self, args):
        """设置数据路径"""
        data_dir = f"./data/vul_detection/{args.dataset}"
        
        args.dev_file = args.dev_file or f"{data_dir}/dev.txt"
        args.test_file = args.test_file or f"{data_dir}/test.txt"
        
        # 创建目录
        os.makedirs(data_dir, exist_ok=True)
    
    def load_vulnerability_data(self, args):
        """加载漏洞检测数据"""
        # 加载开发集
        self.dev_src, self.dev_tgt = self.load_vul_data(args.dev_file)
        
        # 加载测试集
        if args.test_file and os.path.exists(args.test_file):
            self.test_src, self.test_tgt = self.load_vul_data(args.test_file)
        else:
            self.test_src, self.test_tgt = self.dev_src, self.dev_tgt
    
    def load_vul_data(self, file_path: str):
        """加载漏洞检测数据文件"""
        if not os.path.exists(file_path):
            self.logger.warning(f"Data file not found: {file_path}")
            return [], []
        
        src_data = []
        tgt_data = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                
                parts = line.split('\t')
                if len(parts) >= 2:
                    code = parts[0]
                    label = parts[1]
                    src_data.append(code)
                    tgt_data.append(label)
        
        return src_data, tgt_data
    
    def create_vulnerability_prompt(self, code_snippet: str, instruction: str) -> str:
        """创建漏洞检测提示词"""
        template = f"""{instruction}

Code to analyze:
```c
{code_snippet}
```

Analysis: """
        
        return template
    
    def forward(self, prompt_pre="", eval_src=None, ref_texts=None, output=None):
        """
        评估提示词在漏洞检测任务上的性能
        """
        if eval_src is None:
            eval_src = self.dev_src
        if ref_texts is None:
            ref_texts = self.dev_tgt
        
        # 构建完整的提示词
        full_prompts = []
        for code_snippet in eval_src:
            full_prompt = self.create_vulnerability_prompt(code_snippet, prompt_pre)
            full_prompts.append(full_prompt)
        
        # 使用LLM进行推理
        predictions = self.get_llm_predictions(full_prompts)
        
        # 标准化预测结果
        normalized_preds = self.normalize_predictions(predictions)
        
        # 计算评估指标
        scores = self.calculate_vulnerability_metrics(normalized_preds, ref_texts)
        
        return {"hypos": normalized_preds, "scores": scores}
    
    def get_llm_predictions(self, prompts: List[str]) -> List[str]:
        """使用SVEN风格的LLM客户端进行推理"""
        predictions = []
        
        try:
            # 使用SVEN客户端的批量查询功能
            self.logger.info(f"Starting batch prediction for {len(prompts)} prompts...")
            
            responses = sven_llm_query(
                data=prompts,
                client=self.client,
                task=False,  # 不截断回答
                temperature=0.0,
                delay=0.1  # 控制请求间隔
            )
            
            for i, response in enumerate(responses):
                if response == "error":
                    self.logger.warning(f"Error in query {i+1}, using default prediction")
                    predictions.append("benign")
                else:
                    predictions.append(response)
                    
        except Exception as e:
            self.logger.error(f"Batch prediction failed: {e}")
            # 回退到单个查询
            self.logger.info("Falling back to single queries...")
            
            for i, prompt in enumerate(tqdm(prompts, desc="Getting LLM predictions")):
                try:
                    response = sven_llm_query(
                        data=prompt,
                        client=self.client,
                        task=False,
                        temperature=0.0
                    )
                    predictions.append(response)
                except Exception as e:
                    self.logger.warning(f"Error in LLM query {i+1}: {e}")
                    predictions.append("benign")  # 默认预测
        
        return predictions
    
    def normalize_predictions(self, predictions: List[str]) -> List[str]:
        """标准化预测结果"""
        normalized = []
        
        for pred in predictions:
            pred_lower = pred.lower().strip()
            
            # 检查是否包含关键词
            if any(keyword in pred_lower for keyword in ["vulnerable", "vulnerability", "yes", "unsafe", "dangerous"]):
                normalized.append("vulnerable")
            elif any(keyword in pred_lower for keyword in ["benign", "safe", "secure", "no", "clean"]):
                normalized.append("benign")
            else:
                # 如果都不包含，默认为benign
                normalized.append("benign")
        
        return normalized
    
    def calculate_vulnerability_metrics(self, predictions: List[str], ground_truth: List[str]) -> List[float]:
        """计算漏洞检测的评估指标"""
        # 确保长度一致
        min_len = min(len(predictions), len(ground_truth))
        predictions = predictions[:min_len]
        ground_truth = ground_truth[:min_len]
        
        # 计算基本指标
        tp = sum(1 for p, t in zip(predictions, ground_truth) if p == "vulnerable" and t == "vulnerable")
        fp = sum(1 for p, t in zip(predictions, ground_truth) if p == "vulnerable" and t == "benign")
        fn = sum(1 for p, t in zip(predictions, ground_truth) if p == "benign" and t == "vulnerable")
        tn = sum(1 for p, t in zip(predictions, ground_truth) if p == "benign" and t == "benign")
        
        # 计算指标
        accuracy = (tp + tn) / (tp + fp + fn + tn) if (tp + fp + fn + tn) > 0 else 0
        precision = tp / (tp + fp) if (tp + fp) > 0 else 0
        recall = tp / (tp + fn) if (tp + fn) > 0 else 0
        f1 = 2 * precision * recall / (precision + recall) if (precision + recall) > 0 else 0
        
        # 计算特异性（True Negative Rate）
        specificity = tn / (tn + fp) if (tn + fp) > 0 else 0
        
        self.logger.info(f"Metrics - Acc: {accuracy:.4f}, Prec: {precision:.4f}, Rec: {recall:.4f}, F1: {f1:.4f}")
        
        return [accuracy, precision, recall, f1, specificity]
    
    def paraphrase(self, sentence):
        """
        重新表述句子，用于进化算法的变异操作
        """
        try:
            result = self.client.paraphrase(sentence, temperature=0.7)
            return result
        except Exception as e:
            self.logger.warning(f"Paraphrase failed: {e}")
            return sentence  # 返回原句子

def convert_sven_to_evoprompt(sven_file: str, output_file: str):
    """将SVEN数据转换为EvoPrompt格式"""
    converted_data = []
    
    with open(sven_file, 'r', encoding='utf-8') as f:
        for line in f:
            try:
                item = json.loads(line.strip())
                # SVEN数据格式：func_src_before包含漏洞代码
                code = item.get('func_src_before', '').strip()
                vul_type = item.get('vul_type', '').strip()
                
                if code and vul_type:  # 确保代码和漏洞类型不为空
                    # 所有SVEN数据都是有漏洞的
                    label = "vulnerable"
                    # 可以选择性地包含漏洞类型信息
                    code_with_type = f"// {vul_type}\n{code}"
                    converted_data.append(f"{code_with_type}\t{label}")
            except json.JSONDecodeError:
                continue
    
    # 写入转换后的数据
    with open(output_file, 'w', encoding='utf-8') as f:
        for item in converted_data:
            f.write(item + '\n')
    
    print(f"Converted {len(converted_data)} SVEN samples to {output_file}")

def convert_primevul_to_evoprompt(primevul_file: str, output_file: str):
    """将PrimeVul数据转换为EvoPrompt格式"""
    converted_data = []
    
    with open(primevul_file, 'r', encoding='utf-8') as f:
        for line in f:
            try:
                item = json.loads(line.strip())
                code = item.get('func', '').strip()
                target = item.get('target', 0)
                
                if code:  # 确保代码不为空
                    label = "vulnerable" if target == 1 else "benign"
                    converted_data.append(f"{code}\t{label}")
            except json.JSONDecodeError:
                continue
    
    # 写入转换后的数据
    with open(output_file, 'w', encoding='utf-8') as f:
        for item in converted_data:
            f.write(item + '\n')
    
    print(f"Converted {len(converted_data)} samples to {output_file}")

def setup_vulnerability_detection_data(args):
    """设置漏洞检测数据"""
    data_dir = f"./data/vul_detection/{args.dataset}"
    os.makedirs(data_dir, exist_ok=True)
    
    # 如果数据文件不存在，尝试从不同数据源转换
    dev_file = f"{data_dir}/dev.txt"
    test_file = f"{data_dir}/test.txt"
    
    if not os.path.exists(dev_file):
        # 优先尝试从SVEN数据转换
        if args.dataset == "sven":
            sven_val_files = [
                "./sven/data_train_val/val/cwe-022.jsonl",
                "./sven/data_train_val/val/cwe-078.jsonl", 
                "./sven/data_train_val/val/cwe-079.jsonl",
                "./sven/data_train_val/val/cwe-089.jsonl",
                "./sven/data_train_val/val/cwe-125.jsonl",
                "./sven/data_train_val/val/cwe-190.jsonl",
                "./sven/data_train_val/val/cwe-416.jsonl",
                "./sven/data_train_val/val/cwe-476.jsonl",
                "./sven/data_train_val/val/cwe-787.jsonl"
            ]
            
            # 合并所有SVEN验证数据
            combined_data = []
            for sven_file in sven_val_files:
                if os.path.exists(sven_file):
                    with open(sven_file, 'r', encoding='utf-8') as f:
                        for line in f:
                            try:
                                item = json.loads(line.strip())
                                code = item.get('func_src_before', '').strip()
                                vul_type = item.get('vul_type', '').strip()
                                
                                if code and vul_type:
                                    # 清理代码中的换行符和制表符，避免分割问题
                                    code_clean = code.replace('\n', ' ').replace('\r', ' ').replace('\t', ' ').strip()
                                    # 压缩多个空格为单个空格
                                    import re
                                    code_clean = re.sub(r'\s+', ' ', code_clean)
                                    code_with_type = f"// {vul_type} {code_clean}"
                                    # 使用数字标签：1表示vulnerable，0表示benign
                                    combined_data.append(f"{code_with_type}\t1")
                            except json.JSONDecodeError:
                                continue
            
            # 写入合并的开发集数据
            if combined_data:
                with open(dev_file, 'w', encoding='utf-8') as f:
                    for item in combined_data:
                        f.write(item + '\n')
                print(f"Created SVEN dev set with {len(combined_data)} samples")
        
        # 尝试从PrimeVul数据转换
        else:
            primevul_dev = f"./data/primevul/{args.dataset}/dev.jsonl"
            if os.path.exists(primevul_dev):
                convert_primevul_to_evoprompt(primevul_dev, dev_file)
    
    if not os.path.exists(test_file):
        # 优先尝试从SVEN数据转换
        if args.dataset == "sven":
            # 使用SVEN训练数据的一部分作为测试集
            sven_train_files = [
                "./sven/data_train_val/train/cwe-022.jsonl",
                "./sven/data_train_val/train/cwe-078.jsonl",
                "./sven/data_train_val/train/cwe-079.jsonl", 
                "./sven/data_train_val/train/cwe-089.jsonl",
                "./sven/data_train_val/train/cwe-125.jsonl",
                "./sven/data_train_val/train/cwe-190.jsonl",
                "./sven/data_train_val/train/cwe-416.jsonl",
                "./sven/data_train_val/train/cwe-476.jsonl",
                "./sven/data_train_val/train/cwe-787.jsonl"
            ]
            
            # 合并所有SVEN训练数据，取前50个作为测试集
            combined_data = []
            for sven_file in sven_train_files:
                if os.path.exists(sven_file):
                    with open(sven_file, 'r', encoding='utf-8') as f:
                        count = 0
                        for line in f:
                            if count >= 5:  # 每个CWE类型取5个样本
                                break
                            try:
                                item = json.loads(line.strip())
                                code = item.get('func_src_before', '').strip()
                                vul_type = item.get('vul_type', '').strip()
                                
                                if code and vul_type:
                                    # 清理代码中的换行符和制表符，避免分割问题
                                    code_clean = code.replace('\n', ' ').replace('\r', ' ').replace('\t', ' ').strip()
                                    # 压缩多个空格为单个空格
                                    import re
                                    code_clean = re.sub(r'\s+', ' ', code_clean)
                                    code_with_type = f"// {vul_type} {code_clean}"
                                    # 使用数字标签：1表示vulnerable，0表示benign
                                    combined_data.append(f"{code_with_type}\t1")
                                    count += 1
                            except json.JSONDecodeError:
                                continue
            
            # 写入测试集数据
            if combined_data:
                with open(test_file, 'w', encoding='utf-8') as f:
                    for item in combined_data:
                        f.write(item + '\n')
                print(f"Created SVEN test set with {len(combined_data)} samples")
        
        # 尝试从PrimeVul数据转换
        else:
            primevul_test = f"./data/primevul/{args.dataset}/test.jsonl"
            if os.path.exists(primevul_test):
                convert_primevul_to_evoprompt(primevul_test, test_file)
    
    # 创建初始提示词文件
    prompts_file = f"{data_dir}/prompts.txt"
    if not os.path.exists(prompts_file):
        if args.dataset == "sven":
            # 为SVEN数据集创建专门的提示词
            initial_prompts = [
                "Analyze this C/C++ code for CWE security vulnerabilities. Look for common weaknesses like buffer overflows, injection attacks, memory corruption, and logic errors. Respond with 'vulnerable' if you find any security issues, or 'benign' if the code appears safe.",
                "You are a security researcher specializing in CWE vulnerability detection. Examine this C/C++ function and identify potential security weaknesses. Consider patterns like improper bounds checking, unsafe memory operations, and input validation issues. Answer 'vulnerable' or 'benign'.",
                "Review this C/C++ code for CWE-categorized vulnerabilities including CWE-078 (Command Injection), CWE-089 (SQL Injection), CWE-125 (Out-of-bounds Read), CWE-787 (Out-of-bounds Write), and others. Classify as 'vulnerable' or 'benign'.",
                "As a code security auditor, assess this C/C++ function for vulnerabilities based on the CWE taxonomy. Focus on memory safety issues, injection vulnerabilities, and improper validation. Respond with 'vulnerable' or 'benign'.",
                "Perform a security analysis of this C/C++ code snippet. Check for CWE weaknesses such as buffer overflows, null pointer dereferences, use-after-free, integer overflows, and path traversal vulnerabilities. Answer 'vulnerable' or 'benign'."
            ]
        else:
            # 通用的漏洞检测提示词
            initial_prompts = [
                "Analyze this code for security vulnerabilities. Respond with 'vulnerable' if you find any security issues, or 'benign' if the code appears safe.",
                "You are a cybersecurity expert. Examine this code and determine if it contains vulnerabilities. Answer 'vulnerable' or 'benign'.",
                "Review this code for potential security flaws like buffer overflows, injection vulnerabilities, or memory corruption. Classify as 'vulnerable' or 'benign'.",
                "As a security analyst, assess this code for vulnerabilities. Consider common attack vectors and respond with 'vulnerable' or 'benign'.",
                "Check this code for security weaknesses including but not limited to improper input validation, memory issues, or logic errors. Answer 'vulnerable' or 'benign'."
            ]
        
        with open(prompts_file, 'w', encoding='utf-8') as f:
            for prompt in initial_prompts:
                f.write(prompt + '\n')

def main():
    """主函数"""
    # 解析参数
    args = parse_args()
    
    # 设置任务类型（如果未指定）
    if not hasattr(args, 'task') or not args.task:
        args.task = "vul_detection"
    
    # 设置默认参数
    if not hasattr(args, 'dataset') or not args.dataset:
        args.dataset = "primevul"
    
    # 设置language_model参数（evaluator.py需要）
    if not hasattr(args, 'language_model') or not args.language_model:
        args.language_model = "gpt-3.5-turbo"  # 默认模型
    
    # 设置输出目录
    if not hasattr(args, 'output') or not args.output:
        args.output = f"./outputs/vul_detection/{args.dataset}/"
    
    # 设置种子
    set_seed(args.seed)
    
    # 设置数据
    setup_vulnerability_detection_data(args)
    
    # 创建评估器
    evaluator = VulnerabilityDetectionEvaluator(args)
    
    # 运行进化算法
    evaluator.logger.info("Starting vulnerability detection prompt evolution...")
    
    if args.evo_mode == "de":
        de_evo(args=args, evaluator=evaluator)
    elif args.evo_mode == "ga":
        ga_evo(args=args, evaluator=evaluator)
    else:
        raise ValueError(f"Unknown evolution mode: {args.evo_mode}")
    
    evaluator.logger.info("Evolution completed!")

if __name__ == "__main__":
    main()